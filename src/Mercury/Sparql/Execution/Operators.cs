using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Threading;
using SkyOmega.Mercury.Runtime.Buffers;
using SkyOmega.Mercury.Sparql;
using SkyOmega.Mercury.Sparql.Patterns;
using SkyOmega.Mercury.Storage;

namespace SkyOmega.Mercury.Sparql.Execution;

/// <summary>
/// Thread-static cancellation token for query execution.
/// Allows operators to check for cancellation without passing token through all constructors.
/// </summary>
internal static class QueryCancellation
{
    [ThreadStatic]
    private static CancellationToken _token;

    /// <summary>
    /// Set the cancellation token for the current thread's query execution.
    /// </summary>
    public static void SetToken(CancellationToken token) => _token = token;

    /// <summary>
    /// Clear the cancellation token after query execution completes.
    /// </summary>
    public static void ClearToken() => _token = default;

    /// <summary>
    /// Throw OperationCanceledException if cancellation has been requested.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void ThrowIfCancellationRequested() => _token.ThrowIfCancellationRequested();
}

/// <summary>
/// Helper for resolving synthetic terms generated by SPARQL-star expansion.
/// Synthetic terms use negative Start offsets to indicate they're not in the source.
/// </summary>
internal static class SyntheticTermHelper
{
    // RDF namespace IRIs for reification patterns
    public const string RdfType = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#type>";
    public const string RdfStatement = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#Statement>";
    public const string RdfSubject = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#subject>";
    public const string RdfPredicate = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate>";
    public const string RdfObject = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#object>";

    // Pre-allocated synthetic variable names for reifier bindings (up to 32 per query)
    private static readonly string[] SyntheticVarNames = new string[32];

    // Pre-allocated synthetic variable names for sequence path intermediates (up to 32 per query)
    private static readonly string[] SyntheticSeqVarNames = new string[32];

    static SyntheticTermHelper()
    {
        for (int i = 0; i < SyntheticVarNames.Length; i++)
            SyntheticVarNames[i] = $"?_qt{i}";
        for (int i = 0; i < SyntheticSeqVarNames.Length; i++)
            SyntheticSeqVarNames[i] = $"?_seq{i}";
    }

    /// <summary>
    /// Check if a term has a synthetic (negative) offset.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsSynthetic(int start) => start < 0;

    /// <summary>
    /// Get the synthetic IRI for a negative offset.
    /// Offsets: -1 = rdf:type, -2 = rdf:Statement, -3 = rdf:subject, -4 = rdf:predicate, -5 = rdf:object
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan<char> GetSyntheticIri(int start)
    {
        return start switch
        {
            -1 => RdfType.AsSpan(),
            -2 => RdfStatement.AsSpan(),
            -3 => RdfSubject.AsSpan(),
            -4 => RdfPredicate.AsSpan(),
            -5 => RdfObject.AsSpan(),
            _ => ReadOnlySpan<char>.Empty
        };
    }

    /// <summary>
    /// Get the synthetic variable name for a negative offset.
    /// Reifier variables: -100 to -131 = ?_qt0 to ?_qt31
    /// Sequence variables: -200 to -231 = ?_seq0 to ?_seq31
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan<char> GetSyntheticVarName(int start)
    {
        // Check for sequence variables first (-200 to -231)
        if (start <= -200 && start > -232)
        {
            var index = -start - 200;
            if (index < SyntheticSeqVarNames.Length)
                return SyntheticSeqVarNames[index].AsSpan();
        }

        // Reifier variables (-100 to -131)
        var qtIndex = -start - 100;
        if (qtIndex >= 0 && qtIndex < SyntheticVarNames.Length)
            return SyntheticVarNames[qtIndex].AsSpan();
        return ReadOnlySpan<char>.Empty;
    }

    /// <summary>
    /// Get the synthetic offset for a sequence intermediate variable.
    /// Index 0 = offset -200, index 1 = offset -201, etc.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int GetSeqVarOffset(int index) => -(200 + index);
}

/// <summary>
/// Scans a single triple pattern against the QuadStore.
/// Conforms to <see cref="IScan"/> contract (duck typing).
/// </summary>
internal ref struct TriplePatternScan
{
    private readonly QuadStore _store;
    private readonly ReadOnlySpan<char> _source;
    private readonly TriplePattern _pattern;
    private TemporalResultEnumerator _enumerator;
    private bool _initialized;
    private readonly BindingTable _initialBindings;
    private readonly int _initialBindingsCount;
    private readonly ReadOnlySpan<char> _graph;

    // Temporal query parameters
    private readonly TemporalQueryMode _temporalMode;
    private readonly DateTimeOffset _asOfTime;
    private readonly DateTimeOffset _rangeStart;
    private readonly DateTimeOffset _rangeEnd;

    // For property path traversal
    private readonly bool _isInverse;
    private readonly bool _isZeroOrMore;
    private readonly bool _isOneOrMore;
    private readonly bool _isZeroOrOne;
    private readonly bool _isAlternative;
    private readonly bool _isNegatedSet;

    // State for transitive path traversal
    private HashSet<string>? _visited;
    private Queue<string>? _frontier;
    private string? _currentNode;
    private string? _startNode;  // Original start node for binding
    private bool _emittedReflexive;

    // State for alternative path traversal (p1|p2)
    private int _alternativePhase; // 0 = first predicate, 1 = second predicate

    // Prefix mappings for expansion
    private readonly PrefixMapping[]? _prefixes;
    // Expanded IRIs stored as strings to ensure span lifetime safety
    // Each position needs its own storage since Initialize() resolves all three
    // before calling ExecuteTemporalQuery
    private string? _expandedSubject;
    private string? _expandedPredicate;
    private string? _expandedObject;

    public TriplePatternScan(QuadStore store, ReadOnlySpan<char> source,
        TriplePattern pattern, BindingTable initialBindings, ReadOnlySpan<char> graph = default)
        : this(store, source, pattern, initialBindings, graph,
               TemporalQueryMode.Current, default, default, default, null)
    {
    }

    public TriplePatternScan(QuadStore store, ReadOnlySpan<char> source,
        TriplePattern pattern, BindingTable initialBindings, ReadOnlySpan<char> graph,
        TemporalQueryMode temporalMode, DateTimeOffset asOfTime,
        DateTimeOffset rangeStart, DateTimeOffset rangeEnd,
        PrefixMapping[]? prefixes = null)
    {
        _store = store;
        _source = source;
        _pattern = pattern;
        _initialBindings = initialBindings;
        _initialBindingsCount = initialBindings.Count;
        _graph = graph;
        _initialized = false;
        _enumerator = default;

        // Temporal parameters
        _temporalMode = temporalMode;
        _asOfTime = asOfTime;
        _rangeStart = rangeStart;
        _rangeEnd = rangeEnd;

        // Check property path type
        _isInverse = pattern.Path.Type == PathType.Inverse;
        _isZeroOrMore = pattern.Path.Type == PathType.ZeroOrMore;
        _isOneOrMore = pattern.Path.Type == PathType.OneOrMore;
        _isZeroOrOne = pattern.Path.Type == PathType.ZeroOrOne;
        _isAlternative = pattern.Path.Type == PathType.Alternative;
        _isNegatedSet = pattern.Path.Type == PathType.NegatedSet;

        _visited = null;
        _frontier = null;
        _currentNode = null;
        _startNode = null;
        _emittedReflexive = false;
        _alternativePhase = 0;

        _prefixes = prefixes;
        _expandedSubject = null;
        _expandedPredicate = null;
        _expandedObject = null;
    }

    public bool MoveNext(ref BindingTable bindings)
    {
        if (!_initialized)
        {
            Initialize();
            _initialized = true;
        }

        // Handle transitive paths with BFS
        if (_isZeroOrMore || _isOneOrMore)
        {
            return MoveNextTransitive(ref bindings);
        }

        while (true)
        {
            QueryCancellation.ThrowIfCancellationRequested();

            while (_enumerator.MoveNext())
            {
                var triple = _enumerator.Current;

                // Preserve initial bindings (from subquery join), only clear added bindings
                bindings.TruncateTo(_initialBindingsCount);

                if (_isInverse)
                {
                    // For inverse, swap subject and object bindings
                    if (!TryBindVariable(_pattern.Subject, triple.Object, ref bindings))
                        continue;
                    if (!TryBindVariable(_pattern.Object, triple.Subject, ref bindings))
                        continue;
                }
                else if (_isNegatedSet)
                {
                    // For negated property set, filter out predicates that ARE in the negated set
                    if (IsPredicateInNegatedSet(triple.Predicate))
                        continue;

                    // Bind subject and object (no predicate binding for negated sets)
                    if (!TryBindVariable(_pattern.Subject, triple.Subject, ref bindings))
                        continue;
                    if (!TryBindVariable(_pattern.Object, triple.Object, ref bindings))
                        continue;
                }
                else
                {
                    // Normal binding
                    if (!TryBindVariable(_pattern.Subject, triple.Subject, ref bindings))
                        continue;
                    if (!TryBindVariable(_pattern.Predicate, triple.Predicate, ref bindings))
                        continue;
                    if (!TryBindVariable(_pattern.Object, triple.Object, ref bindings))
                        continue;
                }

                return true;
            }

            // Current predicate exhausted - check for alternative path
            if (_isAlternative && _alternativePhase == 0)
            {
                // Switch to second predicate in the alternative
                _alternativePhase = 1;
                _enumerator.Dispose();

                // Re-initialize with second predicate from path's Right offsets
                var subject = ResolveTermForQuery(_pattern.Subject);
                var obj = ResolveTermForQuery(_pattern.Object);
                var predicate2 = _source.Slice(_pattern.Path.RightStart, _pattern.Path.RightLength);

                _enumerator = ExecuteTemporalQuery(subject, predicate2, obj);
                continue; // Try again with second predicate
            }

            break; // No more alternatives
        }

        // For zero-or-one, also emit reflexive case if subject == object and not yet emitted
        if (_isZeroOrOne && !_emittedReflexive)
        {
            _emittedReflexive = true;
            bindings.TruncateTo(_initialBindingsCount);

            // Only emit reflexive if subject variable is bound or is concrete
            var subjectSpan = ResolveTermForQuery(_pattern.Subject);
            if (!subjectSpan.IsEmpty)
            {
                // Bind subject to both subject and object positions
                if (TryBindVariable(_pattern.Subject, subjectSpan, ref bindings) &&
                    TryBindVariable(_pattern.Object, subjectSpan, ref bindings))
                {
                    return true;
                }
            }
        }

        return false;
    }

    private bool MoveNextTransitive(ref BindingTable bindings)
    {
        // For zero-or-more (p*), emit reflexive case first: start node matches itself at 0 hops
        if (_isZeroOrMore && !_emittedReflexive)
        {
            _emittedReflexive = true;
            bindings.TruncateTo(_initialBindingsCount);

            // Bind subject to start node, object to start node (reflexive)
            if (TryBindVariable(_pattern.Subject, _startNode.AsSpan(), ref bindings) &&
                TryBindVariable(_pattern.Object, _startNode.AsSpan(), ref bindings))
            {
                return true;
            }
        }

        // BFS for transitive closure
        while (true)
        {
            QueryCancellation.ThrowIfCancellationRequested();

            // Try to get next result from current frontier node
            while (_enumerator.MoveNext())
            {
                var triple = _enumerator.Current;
                var targetNode = triple.Object.ToString();

                if (!_visited!.Contains(targetNode))
                {
                    _visited.Add(targetNode);
                    _frontier!.Enqueue(targetNode);

                    bindings.TruncateTo(_initialBindingsCount);
                    // Bind subject to original start node, object to the discovered target
                    if (TryBindVariable(_pattern.Subject, _startNode.AsSpan(), ref bindings) &&
                        TryBindVariable(_pattern.Object, triple.Object, ref bindings))
                    {
                        return true;
                    }
                }
            }

            // Move to next frontier node
            _enumerator.Dispose();
            if (_frontier!.Count == 0)
                return false;

            _currentNode = _frontier.Dequeue();
            var predicate = _pattern.HasPropertyPath
                ? ResolveTermForQuery(_pattern.Path.Iri)
                : ResolveTermForQuery(_pattern.Predicate);

            _enumerator = ExecuteTemporalQuery(
                _currentNode.AsSpan(),
                predicate,
                ReadOnlySpan<char>.Empty);
        }
    }

    private void Initialize()
    {
        if (_isZeroOrMore || _isOneOrMore)
        {
            InitializeTransitive();
            return;
        }

        // Resolve terms to spans for querying
        // ResolveTermWithStorage stores expanded IRIs as strings, returning spans over them
        // This ensures spans remain valid until ExecuteTemporalQuery completes
        var subject = ResolveTermWithStorage(_pattern.Subject, TermPosition.Subject);
        var obj = ResolveTermWithStorage(_pattern.Object, TermPosition.Object);

        ReadOnlySpan<char> predicate;
        if (_isInverse)
        {
            // For inverse path, query with swapped subject/object
            predicate = ResolveTermWithStorage(_pattern.Path.Iri, TermPosition.Predicate);
            _enumerator = ExecuteTemporalQuery(obj, predicate, subject);
        }
        else if (_isAlternative)
        {
            // For alternative path (p1|p2), start with first predicate from Left offsets
            predicate = _source.Slice(_pattern.Path.LeftStart, _pattern.Path.LeftLength);
            _enumerator = ExecuteTemporalQuery(subject, predicate, obj);
        }
        else if (_isNegatedSet)
        {
            // For negated property set !(p1|p2|...), query all predicates (wildcard)
            // and filter in MoveNext
            _enumerator = ExecuteTemporalQuery(subject, ReadOnlySpan<char>.Empty, obj);
        }
        else
        {
            predicate = ResolveTermWithStorage(_pattern.Predicate, TermPosition.Predicate);
            _enumerator = ExecuteTemporalQuery(subject, predicate, obj);
        }
    }

    private enum TermPosition { Subject, Predicate, Object }

    private TemporalResultEnumerator ExecuteTemporalQuery(
        ReadOnlySpan<char> subject, ReadOnlySpan<char> predicate, ReadOnlySpan<char> obj)
    {
        return _temporalMode switch
        {
            TemporalQueryMode.AsOf =>
                _store.QueryAsOf(subject, predicate, obj, _asOfTime, _graph),
            TemporalQueryMode.During =>
                _store.QueryChanges(_rangeStart, _rangeEnd, subject, predicate, obj, _graph),
            TemporalQueryMode.AllVersions =>
                _store.QueryEvolution(subject, predicate, obj, _graph),
            _ => _store.QueryCurrent(subject, predicate, obj, _graph)
        };
    }

    private void InitializeTransitive()
    {
        _visited = new HashSet<string>();
        _frontier = new Queue<string>();

        var subject = ResolveTermForQuery(_pattern.Subject);
        _startNode = subject.ToString();

        // For zero-or-more, we'll emit reflexive first in MoveNextTransitive
        // For one-or-more, we skip the reflexive case
        _emittedReflexive = false;

        _visited.Add(_startNode);
        _currentNode = _startNode;

        var predicate = _pattern.HasPropertyPath
            ? ResolveTermForQuery(_pattern.Path.Iri)
            : ResolveTermForQuery(_pattern.Predicate);

        _enumerator = ExecuteTemporalQuery(
            _startNode.AsSpan(),
            predicate,
            ReadOnlySpan<char>.Empty);
    }

    /// <summary>
    /// Resolve term for query with position-based string storage.
    /// Expanded IRIs are stored as strings in position-specific fields to ensure
    /// span lifetime safety when multiple terms are resolved simultaneously.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ReadOnlySpan<char> ResolveTermWithStorage(Term term, TermPosition position)
    {
        // Handle synthetic terms (negative offsets from SPARQL-star expansion)
        if (SyntheticTermHelper.IsSynthetic(term.Start))
        {
            if (term.IsVariable)
            {
                var varName = SyntheticTermHelper.GetSyntheticVarName(term.Start);
                var idx = _initialBindings.FindBinding(varName);
                if (idx >= 0)
                    return _initialBindings.GetString(idx);
                return ReadOnlySpan<char>.Empty;
            }
            return SyntheticTermHelper.GetSyntheticIri(term.Start);
        }

        if (term.IsVariable)
        {
            var varName = _source.Slice(term.Start, term.Length);
            var idx = _initialBindings.FindBinding(varName);
            if (idx >= 0)
                return _initialBindings.GetString(idx);
            return ReadOnlySpan<char>.Empty;
        }

        if (term.IsBlankNode)
            return ReadOnlySpan<char>.Empty;

        var termSpan = _source.Slice(term.Start, term.Length);

        // Check if this is a prefixed name that needs expansion
        if (_prefixes != null && termSpan.Length > 0 && termSpan[0] != '<' && termSpan[0] != '"')
        {
            var colonIdx = termSpan.IndexOf(':');
            if (colonIdx >= 0)
            {
                var prefix = termSpan.Slice(0, colonIdx + 1);
                var localName = termSpan.Slice(colonIdx + 1);

                for (int i = 0; i < _prefixes.Length; i++)
                {
                    var mapping = _prefixes[i];
                    var mappedPrefix = _source.Slice(mapping.PrefixStart, mapping.PrefixLength);

                    if (prefix.SequenceEqual(mappedPrefix))
                    {
                        var iriNs = _source.Slice(mapping.IriStart, mapping.IriLength);
                        var nsWithoutClose = iriNs.Slice(0, iriNs.Length - 1);

                        // Build expanded IRI and store as string
                        var expanded = string.Concat(nsWithoutClose, localName, ">");

                        // Store in position-specific field and return span over it
                        switch (position)
                        {
                            case TermPosition.Subject:
                                _expandedSubject = expanded;
                                return _expandedSubject.AsSpan();
                            case TermPosition.Predicate:
                                _expandedPredicate = expanded;
                                return _expandedPredicate.AsSpan();
                            default:
                                _expandedObject = expanded;
                                return _expandedObject.AsSpan();
                        }
                    }
                }
            }
        }

        return termSpan;
    }

    /// <summary>
    /// Simple term resolution for single-term use cases (transitive paths).
    /// Uses shared buffer since only one term is resolved at a time.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ReadOnlySpan<char> ResolveTermForQuery(Term term)
    {
        if (SyntheticTermHelper.IsSynthetic(term.Start))
        {
            if (term.IsVariable)
            {
                var varName = SyntheticTermHelper.GetSyntheticVarName(term.Start);
                var idx = _initialBindings.FindBinding(varName);
                if (idx >= 0)
                    return _initialBindings.GetString(idx);
                return ReadOnlySpan<char>.Empty;
            }
            return SyntheticTermHelper.GetSyntheticIri(term.Start);
        }

        if (term.IsVariable)
        {
            var varName = _source.Slice(term.Start, term.Length);
            var idx = _initialBindings.FindBinding(varName);
            if (idx >= 0)
                return _initialBindings.GetString(idx);
            return ReadOnlySpan<char>.Empty;
        }

        if (term.IsBlankNode)
            return ReadOnlySpan<char>.Empty;

        var termSpan = _source.Slice(term.Start, term.Length);

        // Check for prefix expansion
        if (_prefixes != null && termSpan.Length > 0 && termSpan[0] != '<' && termSpan[0] != '"')
        {
            var colonIdx = termSpan.IndexOf(':');
            if (colonIdx >= 0)
            {
                var prefix = termSpan.Slice(0, colonIdx + 1);
                var localName = termSpan.Slice(colonIdx + 1);

                for (int i = 0; i < _prefixes.Length; i++)
                {
                    var mapping = _prefixes[i];
                    var mappedPrefix = _source.Slice(mapping.PrefixStart, mapping.PrefixLength);

                    if (prefix.SequenceEqual(mappedPrefix))
                    {
                        var iriNs = _source.Slice(mapping.IriStart, mapping.IriLength);
                        var nsWithoutClose = iriNs.Slice(0, iriNs.Length - 1);

                        // For single-term resolution, store in subject field (reusable)
                        _expandedSubject = string.Concat(nsWithoutClose, localName, ">");
                        return _expandedSubject.AsSpan();
                    }
                }
            }
        }

        return termSpan;
    }

    /// <summary>
    /// Check if a predicate is in the negated property set.
    /// The negated set content is stored as IRIs separated by '|'.
    /// </summary>
    private bool IsPredicateInNegatedSet(ReadOnlySpan<char> predicate)
    {
        var content = _source.Slice(_pattern.Path.LeftStart, _pattern.Path.LeftLength);

        // Parse the content looking for IRIs separated by '|'
        var remaining = content;
        while (!remaining.IsEmpty)
        {
            // Find next separator or end
            var sepIndex = remaining.IndexOf('|');
            ReadOnlySpan<char> current;

            if (sepIndex < 0)
            {
                current = remaining.Trim();
                remaining = ReadOnlySpan<char>.Empty;
            }
            else
            {
                current = remaining[..sepIndex].Trim();
                remaining = remaining[(sepIndex + 1)..];
            }

            // Compare with predicate (exact match)
            if (current.SequenceEqual(predicate))
                return true;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool TryBindVariable(Term term, ReadOnlySpan<char> value, ref BindingTable bindings)
    {
        if (!term.IsVariable)
        {
            // Constant - verify it matches (should already match from query)
            return true;
        }

        // Handle synthetic variables (from SPARQL-star expansion)
        ReadOnlySpan<char> varName;
        if (SyntheticTermHelper.IsSynthetic(term.Start))
            varName = SyntheticTermHelper.GetSyntheticVarName(term.Start);
        else
            varName = _source.Slice(term.Start, term.Length);

        // Check if already bound (from earlier pattern in join)
        var existingIndex = bindings.FindBinding(varName);
        if (existingIndex >= 0)
        {
            // Must match existing binding
            var existingValue = bindings.GetString(existingIndex);
            return value.SequenceEqual(existingValue);
        }

        // Bind new variable
        bindings.Bind(varName, value);
        return true;
    }

    public void Dispose()
    {
        _enumerator.Dispose();
    }
}

/// <summary>
/// Executes multiple triple patterns using nested loop join.
/// Conforms to <see cref="IScan"/> contract (duck typing).
/// Due to ref struct limitations, we store resolved term strings in fixed buffers
/// to avoid span scoping issues with enumerator initialization.
/// </summary>
internal ref struct MultiPatternScan
{
    /// <summary>
    /// Wrapper class to box GraphPattern on the heap for subquery execution.
    /// This prevents stack overflow from nested subqueries since each MultiPatternScan
    /// would otherwise embed a ~4KB GraphPattern on the stack.
    /// </summary>
    internal sealed class BoxedPattern
    {
        public GraphPattern Pattern;
    }

    private readonly QuadStore _store;
    private readonly ReadOnlySpan<char> _source;
    // Pattern can be stored inline (for main queries) or via reference (for subqueries)
    private readonly GraphPattern _pattern;
    private readonly BoxedPattern? _boxedPattern;
    private readonly bool _useBoxedPattern;
    private readonly bool _unionMode;
    private readonly ReadOnlySpan<char> _graph;
    private readonly int[]? _patternOrder;  // Optimized pattern execution order

    // Temporal query parameters
    private readonly TemporalQueryMode _temporalMode;
    private readonly DateTimeOffset _asOfTime;
    private readonly DateTimeOffset _rangeStart;
    private readonly DateTimeOffset _rangeEnd;

    // Prefix expansion support
    private readonly PrefixMapping[]? _prefixes;
    private char[]? _expandBuffer;

    // Current state for each pattern level (support up to 12 patterns for SPARQL-star with multiple annotations)
    private TemporalResultEnumerator _enum0;
    private TemporalResultEnumerator _enum1;
    private TemporalResultEnumerator _enum2;
    private TemporalResultEnumerator _enum3;
    private TemporalResultEnumerator _enum4;
    private TemporalResultEnumerator _enum5;
    private TemporalResultEnumerator _enum6;
    private TemporalResultEnumerator _enum7;
    private TemporalResultEnumerator _enum8;
    private TemporalResultEnumerator _enum9;
    private TemporalResultEnumerator _enum10;
    private TemporalResultEnumerator _enum11;

    private int _currentLevel;
    private bool _init0, _init1, _init2, _init3;
    private bool _init4, _init5, _init6, _init7;
    private bool _init8, _init9, _init10, _init11;
    private bool _exhausted;

    // Track binding count at entry to each level for rollback
    private int _bindingCount0, _bindingCount1, _bindingCount2, _bindingCount3;
    private int _bindingCount4, _bindingCount5, _bindingCount6, _bindingCount7;
    private int _bindingCount8, _bindingCount9, _bindingCount10, _bindingCount11;

    // Pushed filter assignments: for each level (0-11), which filter indices to evaluate
    // Using fixed arrays to avoid heap allocations in ref struct
    // Supports up to 8 levels of filter pushing (levels 0-7)
    private int _levelFilterCount0, _levelFilterCount1, _levelFilterCount2, _levelFilterCount3;
    private int _levelFilterCount4, _levelFilterCount5, _levelFilterCount6, _levelFilterCount7;

    // Filter indices per level (max 4 filters per level)
    private int _f0_0, _f0_1, _f0_2, _f0_3;  // Level 0 filters
    private int _f1_0, _f1_1, _f1_2, _f1_3;  // Level 1 filters
    private int _f2_0, _f2_1, _f2_2, _f2_3;  // Level 2 filters
    private int _f3_0, _f3_1, _f3_2, _f3_3;  // Level 3 filters
    private int _f4_0, _f4_1, _f4_2, _f4_3;  // Level 4 filters
    private int _f5_0, _f5_1, _f5_2, _f5_3;  // Level 5 filters
    private int _f6_0, _f6_1, _f6_2, _f6_3;  // Level 6 filters
    private int _f7_0, _f7_1, _f7_2, _f7_3;  // Level 7 filters

    private bool _hasPushedFilters;

    /// <summary>
    /// Get the current pattern (from boxed or inline storage).
    /// </summary>
    private readonly GraphPattern CurrentPattern =>
        _useBoxedPattern ? _boxedPattern!.Pattern : _pattern;

    public MultiPatternScan(QuadStore store, ReadOnlySpan<char> source, GraphPattern pattern,
        bool unionMode = false, ReadOnlySpan<char> graph = default, PrefixMapping[]? prefixes = null)
        : this(store, source, pattern, unionMode, graph,
               TemporalQueryMode.Current, default, default, default, null, null, prefixes)
    {
    }

    /// <summary>
    /// Constructor for subqueries that takes a boxed pattern to avoid stack overflow.
    /// The pattern is stored by reference on the heap instead of being copied inline.
    /// </summary>
    public MultiPatternScan(QuadStore store, ReadOnlySpan<char> source, BoxedPattern boxedPattern,
        PrefixMapping[]? prefixes = null)
    {
        _store = store;
        _source = source;
        _pattern = default;  // Not used when boxed
        _boxedPattern = boxedPattern;
        _useBoxedPattern = true;
        _unionMode = false;
        _graph = default;
        _patternOrder = null;
        _temporalMode = TemporalQueryMode.Current;
        _asOfTime = default;
        _rangeStart = default;
        _rangeEnd = default;
        _prefixes = prefixes;
        _expandBuffer = null;
        _currentLevel = 0;
        _init0 = _init1 = _init2 = _init3 = false;
        _init4 = _init5 = _init6 = _init7 = false;
        _init8 = _init9 = _init10 = _init11 = false;
        _exhausted = false;
        _enum0 = default; _enum1 = default; _enum2 = default; _enum3 = default;
        _enum4 = default; _enum5 = default; _enum6 = default; _enum7 = default;
        _enum8 = default; _enum9 = default; _enum10 = default; _enum11 = default;
        _bindingCount0 = _bindingCount1 = _bindingCount2 = _bindingCount3 = 0;
        _bindingCount4 = _bindingCount5 = _bindingCount6 = _bindingCount7 = 0;
        _bindingCount8 = _bindingCount9 = _bindingCount10 = _bindingCount11 = 0;
        _levelFilterCount0 = _levelFilterCount1 = _levelFilterCount2 = _levelFilterCount3 = 0;
        _levelFilterCount4 = _levelFilterCount5 = _levelFilterCount6 = _levelFilterCount7 = 0;
        _f0_0 = _f0_1 = _f0_2 = _f0_3 = 0;
        _f1_0 = _f1_1 = _f1_2 = _f1_3 = 0;
        _f2_0 = _f2_1 = _f2_2 = _f2_3 = 0;
        _f3_0 = _f3_1 = _f3_2 = _f3_3 = 0;
        _f4_0 = _f4_1 = _f4_2 = _f4_3 = 0;
        _f5_0 = _f5_1 = _f5_2 = _f5_3 = 0;
        _f6_0 = _f6_1 = _f6_2 = _f6_3 = 0;
        _f7_0 = _f7_1 = _f7_2 = _f7_3 = 0;
        _hasPushedFilters = false;
    }

    public MultiPatternScan(QuadStore store, ReadOnlySpan<char> source, GraphPattern pattern,
        bool unionMode, ReadOnlySpan<char> graph,
        TemporalQueryMode temporalMode, DateTimeOffset asOfTime,
        DateTimeOffset rangeStart, DateTimeOffset rangeEnd,
        int[]? patternOrder = null, List<int>[]? levelFilters = null,
        PrefixMapping[]? prefixes = null)
    {
        _store = store;
        _source = source;
        _pattern = pattern;
        _boxedPattern = null;
        _useBoxedPattern = false;
        _unionMode = unionMode;
        _graph = graph;
        _patternOrder = patternOrder;
        _temporalMode = temporalMode;
        _asOfTime = asOfTime;
        _rangeStart = rangeStart;
        _rangeEnd = rangeEnd;
        _prefixes = prefixes;
        _expandBuffer = null;
        _currentLevel = 0;
        _init0 = _init1 = _init2 = _init3 = false;
        _init4 = _init5 = _init6 = _init7 = false;
        _init8 = _init9 = _init10 = _init11 = false;
        _exhausted = false;
        _enum0 = default;
        _enum1 = default;
        _enum2 = default;
        _enum3 = default;
        _enum4 = default;
        _enum5 = default;
        _enum6 = default;
        _enum7 = default;
        _enum8 = default;
        _enum9 = default;
        _enum10 = default;
        _enum11 = default;
        _bindingCount0 = _bindingCount1 = _bindingCount2 = _bindingCount3 = 0;
        _bindingCount4 = _bindingCount5 = _bindingCount6 = _bindingCount7 = 0;
        _bindingCount8 = _bindingCount9 = _bindingCount10 = _bindingCount11 = 0;

        // Initialize pushed filter fields (levels 0-7)
        _levelFilterCount0 = _levelFilterCount1 = _levelFilterCount2 = _levelFilterCount3 = 0;
        _levelFilterCount4 = _levelFilterCount5 = _levelFilterCount6 = _levelFilterCount7 = 0;
        _f0_0 = _f0_1 = _f0_2 = _f0_3 = 0;
        _f1_0 = _f1_1 = _f1_2 = _f1_3 = 0;
        _f2_0 = _f2_1 = _f2_2 = _f2_3 = 0;
        _f3_0 = _f3_1 = _f3_2 = _f3_3 = 0;
        _f4_0 = _f4_1 = _f4_2 = _f4_3 = 0;
        _f5_0 = _f5_1 = _f5_2 = _f5_3 = 0;
        _f6_0 = _f6_1 = _f6_2 = _f6_3 = 0;
        _f7_0 = _f7_1 = _f7_2 = _f7_3 = 0;
        _hasPushedFilters = false;

        // Copy pushed filter assignments
        if (levelFilters != null)
        {
            _hasPushedFilters = true;
            for (int level = 0; level < Math.Min(levelFilters.Length, 8); level++)
            {
                var filters = levelFilters[level];
                if (filters == null || filters.Count == 0)
                    continue;

                var count = Math.Min(filters.Count, 4);
                SetLevelFilterCount(level, count);

                for (int i = 0; i < count; i++)
                    SetLevelFilter(level, i, filters[i]);
            }
        }
    }

    /// <summary>
    /// Get pattern at level, respecting union mode and pattern ordering.
    /// When _patternOrder is set, maps level to pattern index for optimized execution.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private TriplePattern GetPatternAt(int level)
    {
        // Apply pattern order mapping if set
        var patternIndex = _patternOrder != null && level < _patternOrder.Length
            ? _patternOrder[level]
            : level;

        var pattern = CurrentPattern;
        return _unionMode ? pattern.GetUnionPattern(patternIndex) : pattern.GetPattern(patternIndex);
    }

    /// <summary>
    /// Get the number of patterns to process.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private int GetPatternCount()
    {
        var pattern = CurrentPattern;
        return _unionMode ? pattern.UnionBranchPatternCount : pattern.RequiredPatternCount;
    }

    #region Pushed Filter Helpers

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void SetLevelFilterCount(int level, int count)
    {
        switch (level)
        {
            case 0: _levelFilterCount0 = count; break;
            case 1: _levelFilterCount1 = count; break;
            case 2: _levelFilterCount2 = count; break;
            case 3: _levelFilterCount3 = count; break;
            case 4: _levelFilterCount4 = count; break;
            case 5: _levelFilterCount5 = count; break;
            case 6: _levelFilterCount6 = count; break;
            case 7: _levelFilterCount7 = count; break;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private readonly int GetLevelFilterCount(int level)
    {
        return level switch
        {
            0 => _levelFilterCount0,
            1 => _levelFilterCount1,
            2 => _levelFilterCount2,
            3 => _levelFilterCount3,
            4 => _levelFilterCount4,
            5 => _levelFilterCount5,
            6 => _levelFilterCount6,
            7 => _levelFilterCount7,
            _ => 0
        };
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void SetLevelFilter(int level, int index, int filterIndex)
    {
        switch (level)
        {
            case 0:
                switch (index) { case 0: _f0_0 = filterIndex; break; case 1: _f0_1 = filterIndex; break; case 2: _f0_2 = filterIndex; break; case 3: _f0_3 = filterIndex; break; }
                break;
            case 1:
                switch (index) { case 0: _f1_0 = filterIndex; break; case 1: _f1_1 = filterIndex; break; case 2: _f1_2 = filterIndex; break; case 3: _f1_3 = filterIndex; break; }
                break;
            case 2:
                switch (index) { case 0: _f2_0 = filterIndex; break; case 1: _f2_1 = filterIndex; break; case 2: _f2_2 = filterIndex; break; case 3: _f2_3 = filterIndex; break; }
                break;
            case 3:
                switch (index) { case 0: _f3_0 = filterIndex; break; case 1: _f3_1 = filterIndex; break; case 2: _f3_2 = filterIndex; break; case 3: _f3_3 = filterIndex; break; }
                break;
            case 4:
                switch (index) { case 0: _f4_0 = filterIndex; break; case 1: _f4_1 = filterIndex; break; case 2: _f4_2 = filterIndex; break; case 3: _f4_3 = filterIndex; break; }
                break;
            case 5:
                switch (index) { case 0: _f5_0 = filterIndex; break; case 1: _f5_1 = filterIndex; break; case 2: _f5_2 = filterIndex; break; case 3: _f5_3 = filterIndex; break; }
                break;
            case 6:
                switch (index) { case 0: _f6_0 = filterIndex; break; case 1: _f6_1 = filterIndex; break; case 2: _f6_2 = filterIndex; break; case 3: _f6_3 = filterIndex; break; }
                break;
            case 7:
                switch (index) { case 0: _f7_0 = filterIndex; break; case 1: _f7_1 = filterIndex; break; case 2: _f7_2 = filterIndex; break; case 3: _f7_3 = filterIndex; break; }
                break;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private readonly int GetLevelFilter(int level, int index)
    {
        return level switch
        {
            0 => index switch { 0 => _f0_0, 1 => _f0_1, 2 => _f0_2, 3 => _f0_3, _ => 0 },
            1 => index switch { 0 => _f1_0, 1 => _f1_1, 2 => _f1_2, 3 => _f1_3, _ => 0 },
            2 => index switch { 0 => _f2_0, 1 => _f2_1, 2 => _f2_2, 3 => _f2_3, _ => 0 },
            3 => index switch { 0 => _f3_0, 1 => _f3_1, 2 => _f3_2, 3 => _f3_3, _ => 0 },
            4 => index switch { 0 => _f4_0, 1 => _f4_1, 2 => _f4_2, 3 => _f4_3, _ => 0 },
            5 => index switch { 0 => _f5_0, 1 => _f5_1, 2 => _f5_2, 3 => _f5_3, _ => 0 },
            6 => index switch { 0 => _f6_0, 1 => _f6_1, 2 => _f6_2, 3 => _f6_3, _ => 0 },
            7 => index switch { 0 => _f7_0, 1 => _f7_1, 2 => _f7_2, 3 => _f7_3, _ => 0 },
            _ => 0
        };
    }

    /// <summary>
    /// Evaluate pushed filters at the given level.
    /// Returns true if all filters pass, false if any filter fails.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool PassesLevelFilters(int level, ref BindingTable bindings)
    {
        if (!_hasPushedFilters)
            return true;

        var count = GetLevelFilterCount(level);
        if (count == 0)
            return true;

        for (int i = 0; i < count; i++)
        {
            var filterIndex = GetLevelFilter(level, i);
            var filter = CurrentPattern.GetFilter(filterIndex);
            var filterExpr = _source.Slice(filter.Start, filter.Length);
            var evaluator = new FilterEvaluator(filterExpr);
            if (!evaluator.Evaluate(bindings.GetBindings(), bindings.Count, bindings.GetStringBuffer()))
            {
                return false;
            }
        }
        return true;
    }

    #endregion

    public bool MoveNext(ref BindingTable bindings)
    {
        if (_exhausted)
            return false;

        // Get pattern count based on mode (support up to 12 patterns for SPARQL-star with multiple annotations)
        var patternCount = Math.Min(GetPatternCount(), 12);
        if (patternCount == 0)
            return false;

        while (true)
        {
            QueryCancellation.ThrowIfCancellationRequested();

            bool advanced;
            switch (_currentLevel)
            {
                case 0: advanced = TryAdvanceLevel0(ref bindings); break;
                case 1: advanced = TryAdvanceLevel1(ref bindings); break;
                case 2: advanced = TryAdvanceLevel2(ref bindings); break;
                case 3: advanced = TryAdvanceLevel3(ref bindings); break;
                case 4: advanced = TryAdvanceLevel4(ref bindings); break;
                case 5: advanced = TryAdvanceLevel5(ref bindings); break;
                case 6: advanced = TryAdvanceLevel6(ref bindings); break;
                case 7: advanced = TryAdvanceLevel7(ref bindings); break;
                case 8: advanced = TryAdvanceLevel8(ref bindings); break;
                case 9: advanced = TryAdvanceLevel9(ref bindings); break;
                case 10: advanced = TryAdvanceLevel10(ref bindings); break;
                case 11: advanced = TryAdvanceLevel11(ref bindings); break;
                default: advanced = false; break;
            }

            if (advanced)
            {
                // Check pushed filters at this level before proceeding
                if (!PassesLevelFilters(_currentLevel, ref bindings))
                {
                    // Filters failed - continue trying next match at this level
                    continue;
                }

                if (_currentLevel == patternCount - 1)
                {
                    // At deepest level - we have a complete result
                    return true;
                }
                else
                {
                    // Go deeper
                    _currentLevel++;
                    SetInitialized(_currentLevel, false);
                }
            }
            else
            {
                // Current level exhausted, backtrack
                if (_currentLevel == 0)
                {
                    _exhausted = true;
                    return false;
                }

                // Go up
                _currentLevel--;
            }
        }
    }

    private void SetInitialized(int level, bool value)
    {
        switch (level)
        {
            case 0: _init0 = value; break;
            case 1: _init1 = value; break;
            case 2: _init2 = value; break;
            case 3: _init3 = value; break;
            case 4: _init4 = value; break;
            case 5: _init5 = value; break;
            case 6: _init6 = value; break;
            case 7: _init7 = value; break;
            case 8: _init8 = value; break;
            case 9: _init9 = value; break;
            case 10: _init10 = value; break;
            case 11: _init11 = value; break;
        }
    }

    private bool TryAdvanceLevel0(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(0);

        if (!_init0)
        {
            _bindingCount0 = bindings.Count;
            InitializeEnumerator0(pattern, ref bindings);
            _init0 = true;
        }
        else
        {
            // Rolling back bindings from previous attempt at this level
            bindings.TruncateTo(_bindingCount0);
        }

        return TryAdvanceEnumerator(ref _enum0, pattern, ref bindings);
    }

    private bool TryAdvanceLevel1(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(1);

        if (!_init1)
        {
            _bindingCount1 = bindings.Count;
            InitializeEnumerator1(pattern, ref bindings);
            _init1 = true;
        }
        else
        {
            // Rolling back bindings from previous attempt at this level
            bindings.TruncateTo(_bindingCount1);
        }

        return TryAdvanceEnumerator(ref _enum1, pattern, ref bindings);
    }

    private bool TryAdvanceLevel2(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(2);

        if (!_init2)
        {
            _bindingCount2 = bindings.Count;
            InitializeEnumerator2(pattern, ref bindings);
            _init2 = true;
        }
        else
        {
            // Rolling back bindings from previous attempt at this level
            bindings.TruncateTo(_bindingCount2);
        }

        return TryAdvanceEnumerator(ref _enum2, pattern, ref bindings);
    }

    private bool TryAdvanceLevel3(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(3);

        if (!_init3)
        {
            _bindingCount3 = bindings.Count;
            InitializeEnumerator3(pattern, ref bindings);
            _init3 = true;
        }
        else
        {
            // Rolling back bindings from previous attempt at this level
            bindings.TruncateTo(_bindingCount3);
        }

        return TryAdvanceEnumerator(ref _enum3, pattern, ref bindings);
    }

    private bool TryAdvanceLevel4(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(4);

        if (!_init4)
        {
            _bindingCount4 = bindings.Count;
            InitializeEnumerator4(pattern, ref bindings);
            _init4 = true;
        }
        else
        {
            bindings.TruncateTo(_bindingCount4);
        }

        return TryAdvanceEnumerator(ref _enum4, pattern, ref bindings);
    }

    private bool TryAdvanceLevel5(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(5);

        if (!_init5)
        {
            _bindingCount5 = bindings.Count;
            InitializeEnumerator5(pattern, ref bindings);
            _init5 = true;
        }
        else
        {
            bindings.TruncateTo(_bindingCount5);
        }

        return TryAdvanceEnumerator(ref _enum5, pattern, ref bindings);
    }

    private bool TryAdvanceLevel6(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(6);

        if (!_init6)
        {
            _bindingCount6 = bindings.Count;
            InitializeEnumerator6(pattern, ref bindings);
            _init6 = true;
        }
        else
        {
            bindings.TruncateTo(_bindingCount6);
        }

        return TryAdvanceEnumerator(ref _enum6, pattern, ref bindings);
    }

    private bool TryAdvanceLevel7(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(7);

        if (!_init7)
        {
            _bindingCount7 = bindings.Count;
            InitializeEnumerator7(pattern, ref bindings);
            _init7 = true;
        }
        else
        {
            bindings.TruncateTo(_bindingCount7);
        }

        return TryAdvanceEnumerator(ref _enum7, pattern, ref bindings);
    }

    private bool TryAdvanceLevel8(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(8);

        if (!_init8)
        {
            _bindingCount8 = bindings.Count;
            InitializeEnumerator8(pattern, ref bindings);
            _init8 = true;
        }
        else
        {
            bindings.TruncateTo(_bindingCount8);
        }

        return TryAdvanceEnumerator(ref _enum8, pattern, ref bindings);
    }

    private bool TryAdvanceLevel9(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(9);

        if (!_init9)
        {
            _bindingCount9 = bindings.Count;
            InitializeEnumerator9(pattern, ref bindings);
            _init9 = true;
        }
        else
        {
            bindings.TruncateTo(_bindingCount9);
        }

        return TryAdvanceEnumerator(ref _enum9, pattern, ref bindings);
    }

    private bool TryAdvanceLevel10(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(10);

        if (!_init10)
        {
            _bindingCount10 = bindings.Count;
            InitializeEnumerator10(pattern, ref bindings);
            _init10 = true;
        }
        else
        {
            bindings.TruncateTo(_bindingCount10);
        }

        return TryAdvanceEnumerator(ref _enum10, pattern, ref bindings);
    }

    private bool TryAdvanceLevel11(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(11);

        if (!_init11)
        {
            _bindingCount11 = bindings.Count;
            InitializeEnumerator11(pattern, ref bindings);
            _init11 = true;
        }
        else
        {
            bindings.TruncateTo(_bindingCount11);
        }

        return TryAdvanceEnumerator(ref _enum11, pattern, ref bindings);
    }

    // Each init method resolves terms and creates the enumerator.
    // Terms resolve to either a slice of _source (for constants) or empty span (for unbound variables).
    // Bound variables need their value copied to avoid span escaping issues.
    private void InitializeEnumerator0(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum0);
    }

    private void InitializeEnumerator1(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum1);
    }

    private void InitializeEnumerator2(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum2);
    }

    private void InitializeEnumerator3(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum3);
    }

    private void InitializeEnumerator4(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum4);
    }

    private void InitializeEnumerator5(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum5);
    }

    private void InitializeEnumerator6(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum6);
    }

    private void InitializeEnumerator7(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum7);
    }

    private void InitializeEnumerator8(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum8);
    }

    private void InitializeEnumerator9(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum9);
    }

    private void InitializeEnumerator10(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum10);
    }

    private void InitializeEnumerator11(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum11);
    }

    private void ResolveAndQuery(TriplePattern pattern, scoped ref BindingTable bindings, out TemporalResultEnumerator enumerator)
    {
        // For each term, resolve to a span. Constants come from _source (stable),
        // unbound variables become empty span. Bound variables need special handling.
        // Synthetic terms (negative offsets) come from SPARQL-star expansion.
        ReadOnlySpan<char> subject, predicate, obj;

        // Check if this is an inverse path
        bool isInverse = pattern.Path.Type == PathType.Inverse;

        // Resolve subject
        subject = ResolveTerm(pattern.Subject, ref bindings);

        // Resolve predicate - for inverse paths, use Path.Iri
        predicate = isInverse
            ? ResolveTerm(pattern.Path.Iri, ref bindings)
            : ResolveTerm(pattern.Predicate, ref bindings);

        // Resolve object
        obj = ResolveTerm(pattern.Object, ref bindings);

        // For inverse paths, swap subject and object in the query
        if (isInverse)
        {
            enumerator = ExecuteTemporalQuery(obj, predicate, subject);
        }
        else
        {
            enumerator = ExecuteTemporalQuery(subject, predicate, obj);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ReadOnlySpan<char> ResolveTerm(Term term, scoped ref BindingTable bindings)
    {
        // Handle synthetic terms (negative offsets from SPARQL-star expansion)
        if (SyntheticTermHelper.IsSynthetic(term.Start))
        {
            if (term.IsVariable)
            {
                var varName = SyntheticTermHelper.GetSyntheticVarName(term.Start);
                var idx = bindings.FindBinding(varName);
                return idx >= 0 ? bindings.GetString(idx) : ReadOnlySpan<char>.Empty;
            }
            return SyntheticTermHelper.GetSyntheticIri(term.Start);
        }

        // Blank nodes in patterns (e.g., [] or _:b) act as wildcards - they match any value
        if (term.IsBlankNode)
        {
            return ReadOnlySpan<char>.Empty;
        }

        if (!term.IsVariable)
        {
            var termSpan = _source.Slice(term.Start, term.Length);

            // Check if this is a prefixed name that needs expansion
            if (_prefixes != null && termSpan.Length > 0 && termSpan[0] != '<' && termSpan[0] != '"')
            {
                var colonIdx = termSpan.IndexOf(':');
                if (colonIdx >= 0)
                {
                    var prefix = termSpan.Slice(0, colonIdx + 1);
                    var localName = termSpan.Slice(colonIdx + 1);

                    for (int i = 0; i < _prefixes.Length; i++)
                    {
                        var mapping = _prefixes[i];
                        var mappedPrefix = _source.Slice(mapping.PrefixStart, mapping.PrefixLength);

                        if (prefix.SequenceEqual(mappedPrefix))
                        {
                            // Found matching prefix - expand to full IRI
                            var iriNs = _source.Slice(mapping.IriStart, mapping.IriLength);

                            // IRI namespace is like <http://example.org/> - we need to strip angle brackets and append local name
                            var nsWithoutClose = iriNs.Slice(0, iriNs.Length - 1); // Remove trailing >

                            _expandBuffer ??= new char[512];
                            int pos = 0;

                            // Copy namespace (without closing >)
                            for (int j = 0; j < nsWithoutClose.Length; j++)
                                _expandBuffer[pos++] = nsWithoutClose[j];

                            // Copy local name
                            for (int j = 0; j < localName.Length; j++)
                                _expandBuffer[pos++] = localName[j];

                            // Add closing bracket
                            _expandBuffer[pos++] = '>';

                            return new ReadOnlySpan<char>(_expandBuffer, 0, pos);
                        }
                    }
                }
            }

            return termSpan;
        }

        var name = _source.Slice(term.Start, term.Length);
        var index = bindings.FindBinding(name);
        return index >= 0 ? bindings.GetString(index) : ReadOnlySpan<char>.Empty;
    }

    private TemporalResultEnumerator ExecuteTemporalQuery(
        ReadOnlySpan<char> subject, ReadOnlySpan<char> predicate, ReadOnlySpan<char> obj)
    {
        return _temporalMode switch
        {
            TemporalQueryMode.AsOf =>
                _store.QueryAsOf(subject, predicate, obj, _asOfTime, _graph),
            TemporalQueryMode.During =>
                _store.QueryChanges(_rangeStart, _rangeEnd, subject, predicate, obj, _graph),
            TemporalQueryMode.AllVersions =>
                _store.QueryEvolution(subject, predicate, obj, _graph),
            _ => _store.QueryCurrent(subject, predicate, obj, _graph)
        };
    }

    private bool TryAdvanceEnumerator(ref TemporalResultEnumerator enumerator,
        TriplePattern pattern, scoped ref BindingTable bindings)
    {
        bool isInverse = pattern.Path.Type == PathType.Inverse;

        while (enumerator.MoveNext())
        {
            var triple = enumerator.Current;

            // Try to bind variables, checking consistency with existing bindings
            // For inverse paths, swap subject and object bindings
            if (isInverse)
            {
                // Inverse: pattern.Subject binds to triple.Object, pattern.Object binds to triple.Subject
                if (TryBindVariable(pattern.Subject, triple.Object, ref bindings) &&
                    TryBindVariable(pattern.Object, triple.Subject, ref bindings))
                {
                    return true;
                }
            }
            else
            {
                if (TryBindVariable(pattern.Subject, triple.Subject, ref bindings) &&
                    TryBindVariable(pattern.Predicate, triple.Predicate, ref bindings) &&
                    TryBindVariable(pattern.Object, triple.Object, ref bindings))
                {
                    return true;
                }
            }
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool TryBindVariable(Term term, ReadOnlySpan<char> value, scoped ref BindingTable bindings)
    {
        if (!term.IsVariable)
            return true;

        // Handle synthetic variables (from SPARQL-star expansion)
        ReadOnlySpan<char> varName;
        if (SyntheticTermHelper.IsSynthetic(term.Start))
            varName = SyntheticTermHelper.GetSyntheticVarName(term.Start);
        else
            varName = _source.Slice(term.Start, term.Length);

        var existingIndex = bindings.FindBinding(varName);

        if (existingIndex >= 0)
        {
            var existingValue = bindings.GetString(existingIndex);
            return value.SequenceEqual(existingValue);
        }

        bindings.Bind(varName, value);
        return true;
    }

    public void Dispose()
    {
        _enum0.Dispose();
        _enum1.Dispose();
        _enum2.Dispose();
        _enum3.Dispose();
        _enum4.Dispose();
        _enum5.Dispose();
        _enum6.Dispose();
        _enum7.Dispose();
        _enum8.Dispose();
        _enum9.Dispose();
        _enum10.Dispose();
        _enum11.Dispose();
    }
}

/// <summary>
/// Scans triple patterns across all named graphs, binding a graph variable.
/// Conforms to <see cref="IScan"/> contract (duck typing).
/// For queries like: SELECT ?g ?s ?p ?o WHERE { GRAPH ?g { ?s ?p ?o } }
/// Supports FROM NAMED restriction: only iterate specified named graphs.
/// </summary>
internal ref struct VariableGraphScan
{
    private readonly QuadStore _store;
    private readonly ReadOnlySpan<char> _source;
    private readonly GraphClause _graphClause;
    private NamedGraphEnumerator _graphEnum;
    private MultiPatternScan _currentScan;
    private GraphPattern _innerPattern;
    private ReadOnlySpan<char> _currentGraph;
    private readonly int _graphVarHash;
    private bool _initialized;
    private bool _exhausted;

    // FROM NAMED restriction: if non-null, only iterate these graphs
    private readonly string[]? _allowedNamedGraphs;
    private int _allowedGraphIndex;  // For iterating _allowedNamedGraphs directly

    public VariableGraphScan(QuadStore store, ReadOnlySpan<char> source, GraphClause graphClause,
        string[]? allowedNamedGraphs = null)
    {
        _store = store;
        _source = source;
        _graphClause = graphClause;
        _graphEnum = allowedNamedGraphs == null ? store.GetNamedGraphs() : default;
        _currentScan = default;
        _innerPattern = default;
        _currentGraph = default;
        _initialized = false;
        _exhausted = false;
        _allowedNamedGraphs = allowedNamedGraphs;
        _allowedGraphIndex = 0;

        // Compute hash for graph variable name for binding
        var graphVarName = source.Slice(graphClause.Graph.Start, graphClause.Graph.Length);
        _graphVarHash = ComputeHash(graphVarName);

        // Build inner pattern from graph clause patterns
        _innerPattern = new GraphPattern();
        for (int i = 0; i < graphClause.PatternCount; i++)
        {
            _innerPattern.AddPattern(graphClause.GetPattern(i));
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeHash(ReadOnlySpan<char> s)
    {
        unchecked
        {
            int hash = (int)2166136261;
            foreach (var c in s)
                hash = (hash ^ c) * 16777619;
            return hash;
        }
    }

    public bool MoveNext(ref BindingTable bindings)
    {
        if (_exhausted)
            return false;

        while (true)
        {
            QueryCancellation.ThrowIfCancellationRequested();

            // Try to get next result from current graph's scan
            if (_initialized && _currentScan.MoveNext(ref bindings))
            {
                // Bind the graph variable
                var graphVarName = _source.Slice(_graphClause.Graph.Start, _graphClause.Graph.Length);
                bindings.Bind(graphVarName, _currentGraph);
                return true;
            }

            // Move to next graph
            if (!MoveToNextGraph())
            {
                _exhausted = true;
                return false;
            }

            // Initialize scan for new graph
            _currentScan = new MultiPatternScan(_store, _source, _innerPattern, false, _currentGraph);
            _initialized = true;
        }
    }

    private bool MoveToNextGraph()
    {
        if (_allowedNamedGraphs != null)
        {
            // Iterate through allowed graphs list
            if (_allowedGraphIndex >= _allowedNamedGraphs.Length)
                return false;
            _currentGraph = _allowedNamedGraphs[_allowedGraphIndex++].AsSpan();
            return true;
        }
        else
        {
            // Iterate all named graphs
            if (!_graphEnum.MoveNext())
                return false;
            _currentGraph = _graphEnum.Current;
            return true;
        }
    }

    public void Dispose()
    {
        _currentScan.Dispose();
    }
}

/// <summary>
/// Boxed executor for subqueries that isolates large scan operator stack usage.
/// This class exists to break the ref struct stack chain: when SubQueryScan (ref struct)
/// calls this class's methods, the scan operators are created in a fresh stack frame
/// that doesn't inherit the accumulated ref struct field sizes from the call chain.
/// </summary>
internal sealed class BoxedSubQueryExecutor
{
    private readonly QuadStore _store;
    private readonly string _source;
    private readonly SubSelect _subSelect;
    private readonly bool _distinct;
    private readonly PrefixMapping[]? _prefixes;

    public BoxedSubQueryExecutor(QuadStore store, string source, SubSelect subSelect, PrefixMapping[]? prefixes = null)
    {
        _store = store;
        _source = source;
        _subSelect = subSelect;
        _distinct = subSelect.Distinct;
        _prefixes = prefixes;
    }

    /// <summary>
    /// Execute the subquery and return materialized results.
    /// This method creates scan operators locally - their stack usage is isolated.
    /// </summary>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public List<MaterializedRow> Execute()
    {
        var results = new List<MaterializedRow>();
        var innerBindings = new Binding[16];
        var innerStringBuffer = PooledBufferManager.Shared.Rent<char>(512).Array!;
        var bindingTable = new BindingTable(innerBindings, innerStringBuffer);
        HashSet<int>? seenHashes = _distinct ? new HashSet<int>() : null;

        try
        {
            // If subquery has aggregates, use aggregation path
            if (_subSelect.HasAggregates)
            {
                return ExecuteWithAggregation(ref bindingTable);
            }

            int skipped = 0;
            int returned = 0;

            if (_subSelect.PatternCount == 1)
            {
                MaterializeSinglePattern(ref bindingTable, results, seenHashes, ref skipped, ref returned);
            }
            else
            {
                MaterializeMultiPattern(ref bindingTable, results, seenHashes, ref skipped, ref returned);
            }
        }
        finally
        {
            PooledBufferManager.Shared.Return(innerStringBuffer);
        }

        return results;
    }

    /// <summary>
    /// Execute subquery with aggregation support.
    /// Collects raw rows, groups them, computes aggregates, and returns aggregated results.
    /// </summary>
    [MethodImpl(MethodImplOptions.NoInlining)]
    private List<MaterializedRow> ExecuteWithAggregation(ref BindingTable bindingTable)
    {
        var groups = new Dictionary<string, SubQueryGroupedRow>();
        var source = _source;

        // Collect all raw rows
        if (_subSelect.PatternCount == 1)
        {
            CollectRawResultsSingle(ref bindingTable, groups, source);
        }
        else
        {
            CollectRawResultsMulti(ref bindingTable, groups, source);
        }

        // Handle implicit aggregation with empty result set:
        // When there are aggregates but no GROUP BY and no matching rows,
        // SPARQL requires returning one row with default aggregate values
        if (groups.Count == 0 && _subSelect.HasAggregates && !_subSelect.HasGroupBy)
        {
            bindingTable.Clear();
            var emptyGroup = new SubQueryGroupedRow(_subSelect, bindingTable, source);
            groups[""] = emptyGroup;
        }

        // Finalize aggregates and convert to MaterializedRow
        var results = new List<MaterializedRow>(groups.Count);
        foreach (var group in groups.Values)
        {
            group.FinalizeAggregates();
            results.Add(group.ToMaterializedRow());
        }

        // Apply LIMIT/OFFSET if specified
        if (_subSelect.Offset > 0 || _subSelect.Limit > 0)
        {
            int skip = _subSelect.Offset;
            int take = _subSelect.Limit > 0 ? _subSelect.Limit : results.Count;
            if (skip >= results.Count)
            {
                results.Clear();
            }
            else
            {
                int available = results.Count - skip;
                int actualTake = Math.Min(take, available);
                results = results.GetRange(skip, actualTake);
            }
        }

        return results;
    }

    /// <summary>
    /// Collect raw results from single pattern for aggregation.
    /// </summary>
    [MethodImpl(MethodImplOptions.NoInlining)]
    private void CollectRawResultsSingle(ref BindingTable bindingTable,
        Dictionary<string, SubQueryGroupedRow> groups, string source)
    {
        var tp = _subSelect.GetPattern(0);
        var sourceSpan = source.AsSpan();
        var scan = new TriplePatternScan(_store, sourceSpan, tp, bindingTable, default,
            TemporalQueryMode.Current, default, default, default, _prefixes);
        try
        {
            while (scan.MoveNext(ref bindingTable))
            {
                // Apply filters if any
                if (_subSelect.FilterCount > 0)
                {
                    bool passedFilters = true;
                    for (int i = 0; i < _subSelect.FilterCount; i++)
                    {
                        var filter = _subSelect.GetFilter(i);
                        var filterExpr = sourceSpan.Slice(filter.Start, filter.Length);
                        var evaluator = new FilterEvaluator(filterExpr);
                        if (!evaluator.Evaluate(bindingTable.GetBindings(), bindingTable.Count, bindingTable.GetStringBuffer()))
                        {
                            passedFilters = false;
                            break;
                        }
                    }
                    if (!passedFilters)
                    {
                        bindingTable.Clear();
                        continue;
                    }
                }

                // Build group key from GROUP BY variables
                var groupKey = BuildGroupKey(ref bindingTable, source);

                // Get or create group
                if (!groups.TryGetValue(groupKey, out var group))
                {
                    group = new SubQueryGroupedRow(_subSelect, bindingTable, source);
                    groups[groupKey] = group;
                }

                // Update aggregates for this group
                group.UpdateAggregates(bindingTable, source);
                bindingTable.Clear();
            }
        }
        finally
        {
            scan.Dispose();
        }
    }

    /// <summary>
    /// Collect raw results from multi-pattern for aggregation.
    /// </summary>
    [MethodImpl(MethodImplOptions.NoInlining)]
    private void CollectRawResultsMulti(ref BindingTable bindingTable,
        Dictionary<string, SubQueryGroupedRow> groups, string source)
    {
        if (_subSelect.HasUnion)
        {
            CollectRawResultsUnion(ref bindingTable, groups, source);
        }
        else
        {
            var boxedPattern = new MultiPatternScan.BoxedPattern();
            for (int i = 0; i < _subSelect.PatternCount; i++)
            {
                boxedPattern.Pattern.AddPattern(_subSelect.GetPattern(i));
            }

            var sourceSpan = source.AsSpan();
            var scan = new MultiPatternScan(_store, sourceSpan, boxedPattern, _prefixes);
            try
            {
                while (scan.MoveNext(ref bindingTable))
                {
                    // Apply filters if any
                    if (_subSelect.FilterCount > 0)
                    {
                        bool passedFilters = true;
                        for (int i = 0; i < _subSelect.FilterCount; i++)
                        {
                            var filter = _subSelect.GetFilter(i);
                            var filterExpr = sourceSpan.Slice(filter.Start, filter.Length);
                            var evaluator = new FilterEvaluator(filterExpr);
                            if (!evaluator.Evaluate(bindingTable.GetBindings(), bindingTable.Count, bindingTable.GetStringBuffer()))
                            {
                                passedFilters = false;
                                break;
                            }
                        }
                        if (!passedFilters)
                        {
                            bindingTable.Clear();
                            continue;
                        }
                    }

                    var groupKey = BuildGroupKey(ref bindingTable, source);

                    if (!groups.TryGetValue(groupKey, out var group))
                    {
                        group = new SubQueryGroupedRow(_subSelect, bindingTable, source);
                        groups[groupKey] = group;
                    }

                    group.UpdateAggregates(bindingTable, source);
                    bindingTable.Clear();
                }
            }
            finally
            {
                scan.Dispose();
            }
        }
    }

    /// <summary>
    /// Collect raw results from UNION branches for aggregation.
    /// </summary>
    [MethodImpl(MethodImplOptions.NoInlining)]
    private void CollectRawResultsUnion(ref BindingTable bindingTable,
        Dictionary<string, SubQueryGroupedRow> groups, string source)
    {
        var sourceSpan = source.AsSpan();

        // Execute first branch
        if (_subSelect.FirstBranchPatternCount > 0)
        {
            if (_subSelect.FirstBranchPatternCount > 1)
            {
                var firstBranch = new MultiPatternScan.BoxedPattern();
                for (int i = 0; i < _subSelect.FirstBranchPatternCount; i++)
                {
                    firstBranch.Pattern.AddPattern(_subSelect.GetPattern(i));
                }

                var firstScan = new MultiPatternScan(_store, sourceSpan, firstBranch, _prefixes);
                try
                {
                    while (firstScan.MoveNext(ref bindingTable))
                    {
                        ProcessRowForAggregation(ref bindingTable, groups, source, sourceSpan);
                        bindingTable.Clear();
                    }
                }
                finally
                {
                    firstScan.Dispose();
                }
            }
            else
            {
                var tp = _subSelect.GetPattern(0);
                var scan = new TriplePatternScan(_store, sourceSpan, tp, bindingTable, default,
                    TemporalQueryMode.Current, default, default, default, _prefixes);
                try
                {
                    while (scan.MoveNext(ref bindingTable))
                    {
                        ProcessRowForAggregation(ref bindingTable, groups, source, sourceSpan);
                        bindingTable.Clear();
                    }
                }
                finally
                {
                    scan.Dispose();
                }
            }
        }

        // Execute union branch patterns
        for (int i = _subSelect.UnionStartIndex; i < _subSelect.PatternCount; i++)
        {
            var tp = _subSelect.GetPattern(i);
            var scan = new TriplePatternScan(_store, sourceSpan, tp, bindingTable, default,
                TemporalQueryMode.Current, default, default, default, _prefixes);
            try
            {
                while (scan.MoveNext(ref bindingTable))
                {
                    ProcessRowForAggregation(ref bindingTable, groups, source, sourceSpan);
                    bindingTable.Clear();
                }
            }
            finally
            {
                scan.Dispose();
            }
        }
    }

    /// <summary>
    /// Process a single row for aggregation: apply filters, build group key, update aggregates.
    /// </summary>
    private void ProcessRowForAggregation(ref BindingTable bindingTable,
        Dictionary<string, SubQueryGroupedRow> groups, string source, ReadOnlySpan<char> sourceSpan)
    {
        // Apply filters if any
        if (_subSelect.FilterCount > 0)
        {
            for (int i = 0; i < _subSelect.FilterCount; i++)
            {
                var filter = _subSelect.GetFilter(i);
                var filterExpr = sourceSpan.Slice(filter.Start, filter.Length);
                var evaluator = new FilterEvaluator(filterExpr);
                if (!evaluator.Evaluate(bindingTable.GetBindings(), bindingTable.Count, bindingTable.GetStringBuffer()))
                    return;
            }
        }

        var groupKey = BuildGroupKey(ref bindingTable, source);

        if (!groups.TryGetValue(groupKey, out var group))
        {
            group = new SubQueryGroupedRow(_subSelect, bindingTable, source);
            groups[groupKey] = group;
        }

        group.UpdateAggregates(bindingTable, source);
    }

    /// <summary>
    /// Build a group key from GROUP BY variables.
    /// </summary>
    private string BuildGroupKey(ref BindingTable bindings, string source)
    {
        if (!_subSelect.HasGroupBy || _subSelect.GroupBy.Count == 0)
            return "";

        var keyBuilder = new System.Text.StringBuilder();
        for (int i = 0; i < _subSelect.GroupBy.Count; i++)
        {
            var (start, len) = _subSelect.GroupBy.GetVariable(i);
            var varName = source.AsSpan(start, len);
            var bindingIdx = bindings.FindBinding(varName);
            if (bindingIdx >= 0)
            {
                if (i > 0) keyBuilder.Append('\0');
                keyBuilder.Append(bindings.GetString(bindingIdx));
            }
        }
        return keyBuilder.ToString();
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private void MaterializeSinglePattern(ref BindingTable bindingTable, List<MaterializedRow> results,
        HashSet<int>? seenHashes, ref int skipped, ref int returned)
    {
        var tp = _subSelect.GetPattern(0);
        var source = _source.AsSpan();
        var scan = new TriplePatternScan(_store, source, tp, bindingTable);
        try
        {
            while (scan.MoveNext(ref bindingTable))
            {
                if (ProcessAndAddResult(ref bindingTable, results, seenHashes, ref skipped, ref returned))
                {
                    if (_subSelect.Limit > 0 && returned >= _subSelect.Limit)
                        break;
                }
                bindingTable.Clear();
            }
        }
        finally
        {
            scan.Dispose();
        }
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private void MaterializeMultiPattern(ref BindingTable bindingTable, List<MaterializedRow> results,
        HashSet<int>? seenHashes, ref int skipped, ref int returned)
    {
        if (_subSelect.HasUnion)
        {
            // Execute UNION: first branch then union branch
            MaterializeUnionBranches(ref bindingTable, results, seenHashes, ref skipped, ref returned);
        }
        else
        {
            // Build pattern on heap
            var boxedPattern = new MultiPatternScan.BoxedPattern();
            for (int i = 0; i < _subSelect.PatternCount; i++)
            {
                boxedPattern.Pattern.AddPattern(_subSelect.GetPattern(i));
            }

            var source = _source.AsSpan();
            var scan = new MultiPatternScan(_store, source, boxedPattern);
            try
            {
                while (scan.MoveNext(ref bindingTable))
                {
                    if (ProcessAndAddResult(ref bindingTable, results, seenHashes, ref skipped, ref returned))
                    {
                        if (_subSelect.Limit > 0 && returned >= _subSelect.Limit)
                            break;
                    }
                    bindingTable.Clear();
                }
            }
            finally
            {
                scan.Dispose();
            }
        }
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private void MaterializeUnionBranches(ref BindingTable bindingTable, List<MaterializedRow> results,
        HashSet<int>? seenHashes, ref int skipped, ref int returned)
    {
        var source = _source.AsSpan();

        // Execute first branch (patterns before UNION)
        if (_subSelect.FirstBranchPatternCount > 0)
        {
            // If first branch has multiple patterns, execute as multi-pattern scan
            if (_subSelect.FirstBranchPatternCount > 1)
            {
                var firstBranch = new MultiPatternScan.BoxedPattern();
                for (int i = 0; i < _subSelect.FirstBranchPatternCount; i++)
                {
                    firstBranch.Pattern.AddPattern(_subSelect.GetPattern(i));
                }

                var firstScan = new MultiPatternScan(_store, source, firstBranch);
                try
                {
                    while (firstScan.MoveNext(ref bindingTable))
                    {
                        if (ProcessAndAddResult(ref bindingTable, results, seenHashes, ref skipped, ref returned))
                        {
                            if (_subSelect.Limit > 0 && returned >= _subSelect.Limit)
                                return;
                        }
                        bindingTable.Clear();
                    }
                }
                finally
                {
                    firstScan.Dispose();
                }
            }
            else
            {
                // Single pattern - use TriplePatternScan
                var tp = _subSelect.GetPattern(0);
                var scan = new TriplePatternScan(_store, source, tp, bindingTable);
                try
                {
                    while (scan.MoveNext(ref bindingTable))
                    {
                        if (ProcessAndAddResult(ref bindingTable, results, seenHashes, ref skipped, ref returned))
                        {
                            if (_subSelect.Limit > 0 && returned >= _subSelect.Limit)
                                return;
                        }
                        bindingTable.Clear();
                    }
                }
                finally
                {
                    scan.Dispose();
                }
            }
        }

        // Execute union branch - each pattern separately as an alternative
        for (int i = _subSelect.UnionStartIndex; i < _subSelect.PatternCount; i++)
        {
            var tp = _subSelect.GetPattern(i);
            var scan = new TriplePatternScan(_store, source, tp, bindingTable);
            try
            {
                while (scan.MoveNext(ref bindingTable))
                {
                    if (ProcessAndAddResult(ref bindingTable, results, seenHashes, ref skipped, ref returned))
                    {
                        if (_subSelect.Limit > 0 && returned >= _subSelect.Limit)
                            return;
                    }
                    bindingTable.Clear();
                }
            }
            finally
            {
                scan.Dispose();
            }
        }
    }

    private bool ProcessAndAddResult(ref BindingTable innerBindings, List<MaterializedRow> results,
        HashSet<int>? seenHashes, ref int skipped, ref int returned)
    {
        var source = _source.AsSpan();

        // Apply filters if any
        if (_subSelect.FilterCount > 0)
        {
            for (int i = 0; i < _subSelect.FilterCount; i++)
            {
                var filter = _subSelect.GetFilter(i);
                var filterExpr = source.Slice(filter.Start, filter.Length);
                var evaluator = new FilterEvaluator(filterExpr);
                if (!evaluator.Evaluate(innerBindings.GetBindings(), innerBindings.Count, innerBindings.GetStringBuffer()))
                    return false;
            }
        }

        // Apply OFFSET
        if (skipped < _subSelect.Offset)
        {
            skipped++;
            return false;
        }

        // Apply DISTINCT on projected variables
        if (seenHashes != null)
        {
            var hash = ComputeProjectedBindingsHash(ref innerBindings, source);
            if (!seenHashes.Add(hash))
                return false;
        }

        // Project and materialize the result
        var projectedRow = ProjectToMaterializedRow(ref innerBindings, source);
        results.Add(projectedRow);
        returned++;
        return true;
    }

    private int ComputeProjectedBindingsHash(ref BindingTable innerBindings, ReadOnlySpan<char> source)
    {
        int hash = 17;
        if (_subSelect.SelectAll)
        {
            for (int i = 0; i < innerBindings.Count; i++)
            {
                hash = hash * 31 + innerBindings.GetVariableHash(i);
                hash = hash * 31 + string.GetHashCode(innerBindings.GetString(i));
            }
        }
        else
        {
            for (int i = 0; i < _subSelect.ProjectedVarCount; i++)
            {
                var (start, len) = _subSelect.GetProjectedVariable(i);
                var varName = source.Slice(start, len);
                var idx = innerBindings.FindBinding(varName);
                if (idx >= 0)
                {
                    hash = hash * 31 + innerBindings.GetVariableHash(idx);
                    hash = hash * 31 + string.GetHashCode(innerBindings.GetString(idx));
                }
            }
        }
        return hash;
    }

    private MaterializedRow ProjectToMaterializedRow(ref BindingTable innerBindings, ReadOnlySpan<char> source)
    {
        var projectedBindings = new Binding[16];
        var projectedBuffer = new char[512];
        var projectedTable = new BindingTable(projectedBindings, projectedBuffer);

        if (_subSelect.SelectAll)
        {
            for (int i = 0; i < innerBindings.Count; i++)
            {
                var varHash = innerBindings.GetVariableHash(i);
                var value = innerBindings.GetString(i);
                projectedTable.BindWithHash(varHash, value);
            }
        }
        else
        {
            for (int i = 0; i < _subSelect.ProjectedVarCount; i++)
            {
                var (start, len) = _subSelect.GetProjectedVariable(i);
                var varName = source.Slice(start, len);
                var idx = innerBindings.FindBinding(varName);
                if (idx >= 0)
                {
                    projectedTable.Bind(varName, innerBindings.GetString(idx));
                }
            }
        }

        return new MaterializedRow(projectedTable);
    }
}

/// <summary>
/// Groups results and computes aggregates for subqueries with GROUP BY and/or aggregates.
/// Similar to GroupedRow but works with SubSelect instead of SelectClause.
/// </summary>
internal sealed class SubQueryGroupedRow
{
    // Group key storage
    private readonly int[] _keyHashes;
    private readonly string[] _keyValues;
    private readonly int _keyCount;

    // Aggregate storage
    private readonly int[] _aggHashes;        // Hash of alias variable name
    private readonly string[] _aggValues;      // Final computed values
    private readonly AggregateFunction[] _aggFunctions;
    private readonly int[] _aggVarHashes;      // Hash of source variable name
    private readonly int _aggCount;
    private readonly bool[] _aggDistinct;      // DISTINCT flag per aggregate

    // Aggregate accumulators
    private readonly long[] _counts;
    private readonly double[] _sums;
    private readonly double[] _mins;
    private readonly double[] _maxes;
    private readonly HashSet<string>?[] _distinctSets;
    private readonly List<string>?[] _concatValues;  // For GROUP_CONCAT
    private readonly string[] _separators;           // For GROUP_CONCAT
    private readonly string?[] _sampleValues;        // For SAMPLE

    public int KeyCount => _keyCount;
    public int AggregateCount => _aggCount;

    public SubQueryGroupedRow(SubSelect subSelect, BindingTable bindings, string source)
    {
        // Store group key values from GROUP BY clause
        _keyCount = subSelect.HasGroupBy ? subSelect.GroupBy.Count : 0;
        _keyHashes = new int[_keyCount];
        _keyValues = new string[_keyCount];

        for (int i = 0; i < _keyCount; i++)
        {
            var (start, len) = subSelect.GroupBy.GetVariable(i);
            var varName = source.AsSpan(start, len);
            _keyHashes[i] = ComputeHash(varName);
            var idx = bindings.FindBinding(varName);
            _keyValues[i] = idx >= 0 ? bindings.GetString(idx).ToString() : "";
        }

        // Initialize aggregate accumulators from SubSelect
        _aggCount = subSelect.AggregateCount;
        _aggHashes = new int[_aggCount];
        _aggValues = new string[_aggCount];
        _aggFunctions = new AggregateFunction[_aggCount];
        _aggVarHashes = new int[_aggCount];
        _aggDistinct = new bool[_aggCount];
        _counts = new long[_aggCount];
        _sums = new double[_aggCount];
        _mins = new double[_aggCount];
        _maxes = new double[_aggCount];
        _distinctSets = new HashSet<string>?[_aggCount];
        _concatValues = new List<string>?[_aggCount];
        _separators = new string[_aggCount];
        _sampleValues = new string?[_aggCount];

        for (int i = 0; i < _aggCount; i++)
        {
            var agg = subSelect.GetAggregate(i);
            _aggFunctions[i] = agg.Function;
            _aggDistinct[i] = agg.Distinct;

            // Hash of alias (result variable name)
            var aliasName = source.AsSpan(agg.AliasStart, agg.AliasLength);
            _aggHashes[i] = ComputeHash(aliasName);

            // Hash of source variable
            if (agg.VariableLength > 0)
            {
                var varName = source.AsSpan(agg.VariableStart, agg.VariableLength);
                _aggVarHashes[i] = ComputeHash(varName);
            }
            else
            {
                // COUNT(*) case
                _aggVarHashes[i] = ComputeHash("*".AsSpan());
            }

            // Initialize accumulators
            _mins[i] = double.MaxValue;
            _maxes[i] = double.MinValue;
            if (agg.Distinct)
            {
                _distinctSets[i] = new HashSet<string>();
            }

            // Initialize GROUP_CONCAT accumulators
            if (agg.Function == AggregateFunction.GroupConcat)
            {
                _concatValues[i] = new List<string>();
                // Extract separator from source, default to space
                _separators[i] = agg.SeparatorLength > 0
                    ? source.Substring(agg.SeparatorStart, agg.SeparatorLength)
                    : " ";
            }
        }
    }

    public void UpdateAggregates(BindingTable bindings, string source)
    {
        for (int i = 0; i < _aggCount; i++)
        {
            var func = _aggFunctions[i];
            var varHash = _aggVarHashes[i];

            // Find the value for this aggregate's variable
            string? valueStr = null;
            double numValue = 0;
            bool hasNumValue = false;

            // For COUNT(*), we don't need a specific variable
            if (varHash != ComputeHash("*".AsSpan()))
            {
                var idx = bindings.FindBindingByHash(varHash);
                if (idx >= 0)
                {
                    valueStr = bindings.GetString(idx).ToString();
                    // Use RDF-aware numeric parsing to handle typed literals
                    hasNumValue = TryParseRdfNumeric(valueStr, out numValue);
                }
                else
                {
                    // Variable not bound - skip for most aggregates
                    if (func != AggregateFunction.Count)
                        continue;
                }
            }

            // Handle DISTINCT
            if (_distinctSets[i] != null)
            {
                var val = valueStr ?? "";
                if (!_distinctSets[i]!.Add(val))
                    continue; // Already seen this value
            }

            // Update accumulator based on function
            switch (func)
            {
                case AggregateFunction.Count:
                    _counts[i]++;
                    break;
                case AggregateFunction.Sum:
                    if (hasNumValue) _sums[i] += numValue;
                    break;
                case AggregateFunction.Avg:
                    if (hasNumValue)
                    {
                        _sums[i] += numValue;
                        _counts[i]++;
                    }
                    break;
                case AggregateFunction.Min:
                    if (hasNumValue && numValue < _mins[i])
                        _mins[i] = numValue;
                    break;
                case AggregateFunction.Max:
                    if (hasNumValue && numValue > _maxes[i])
                        _maxes[i] = numValue;
                    break;
                case AggregateFunction.GroupConcat:
                    if (valueStr != null)
                        _concatValues[i]!.Add(valueStr);
                    break;
                case AggregateFunction.Sample:
                    // SAMPLE returns an arbitrary value - we take the first one
                    if (_sampleValues[i] == null && valueStr != null)
                        _sampleValues[i] = valueStr;
                    break;
            }
        }
    }

    public void FinalizeAggregates()
    {
        for (int i = 0; i < _aggCount; i++)
        {
            _aggValues[i] = _aggFunctions[i] switch
            {
                AggregateFunction.Count => _counts[i].ToString(),
                AggregateFunction.Sum => _sums[i].ToString(CultureInfo.InvariantCulture),
                AggregateFunction.Avg => _counts[i] > 0
                    ? (_sums[i] / _counts[i]).ToString(CultureInfo.InvariantCulture)
                    : "0",
                AggregateFunction.Min => _mins[i] == double.MaxValue ? "" : _mins[i].ToString(CultureInfo.InvariantCulture),
                AggregateFunction.Max => _maxes[i] == double.MinValue ? "" : _maxes[i].ToString(CultureInfo.InvariantCulture),
                AggregateFunction.GroupConcat => _concatValues[i] != null
                    ? string.Join(_separators[i], _concatValues[i]!)
                    : "",
                AggregateFunction.Sample => _sampleValues[i] ?? "",
                _ => ""
            };
        }
    }

    public int GetKeyHash(int index) => _keyHashes[index];
    public ReadOnlySpan<char> GetKeyValue(int index) => _keyValues[index];
    public int GetAggregateHash(int index) => _aggHashes[index];
    public ReadOnlySpan<char> GetAggregateValue(int index) => _aggValues[index];

    /// <summary>
    /// Converts this grouped row to a MaterializedRow with all key and aggregate bindings.
    /// </summary>
    public MaterializedRow ToMaterializedRow()
    {
        var bindings = new Binding[16];
        var buffer = new char[512];
        var table = new BindingTable(bindings, buffer);

        // Add group key bindings
        for (int i = 0; i < _keyCount; i++)
        {
            table.BindWithHash(_keyHashes[i], _keyValues[i]);
        }

        // Add aggregate bindings
        for (int i = 0; i < _aggCount; i++)
        {
            table.BindWithHash(_aggHashes[i], _aggValues[i]);
        }

        return new MaterializedRow(table);
    }

    private static int ComputeHash(ReadOnlySpan<char> s)
    {
        uint hash = 2166136261;
        foreach (var ch in s)
        {
            hash ^= ch;
            hash *= 16777619;
        }
        return (int)hash;
    }

    /// <summary>
    /// Try to parse a numeric value from an RDF literal string.
    /// </summary>
    private static bool TryParseRdfNumeric(string str, out double result)
    {
        result = 0;

        if (string.IsNullOrEmpty(str))
            return false;

        // Handle typed literals: "value"^^<datatype>
        if (str.StartsWith('"'))
        {
            int endQuote = str.IndexOf('"', 1);
            if (endQuote <= 0)
                return false;

            var valueStr = str.AsSpan(1, endQuote - 1);
            return double.TryParse(valueStr, NumberStyles.Float, CultureInfo.InvariantCulture, out result);
        }

        // Try direct numeric parse
        return double.TryParse(str, NumberStyles.Float, CultureInfo.InvariantCulture, out result);
    }
}

/// <summary>
/// Executes a subquery and yields only projected variable bindings.
/// Conforms to <see cref="IScan"/> contract (duck typing).
/// Handles variable scoping: only SELECT-ed variables are visible to outer query.
///
/// Design note: Results are materialized eagerly during Initialize() by delegating
/// to BoxedSubQueryExecutor, which isolates large scan operator stack usage.
/// </summary>
internal ref struct SubQueryScan
{
    private readonly QuadStore _store;
    private readonly ReadOnlySpan<char> _source;
    private readonly SubSelect _subSelect;
    private readonly PrefixMapping[]? _prefixes;
    // Materialized results - populated during Initialize() via BoxedSubQueryExecutor
    private List<MaterializedRow>? _materializedResults;
    private int _currentIndex;
    private bool _initialized;
    private bool _exhausted;

    public SubQueryScan(QuadStore store, ReadOnlySpan<char> source, SubSelect subSelect)
        : this(store, source, subSelect, null)
    {
    }

    public SubQueryScan(QuadStore store, ReadOnlySpan<char> source, SubSelect subSelect, PrefixMapping[]? prefixes)
    {
        _store = store;
        _source = source;
        _subSelect = subSelect;
        _prefixes = prefixes;
        _materializedResults = null;
        _currentIndex = 0;
        _initialized = false;
        _exhausted = false;
    }

    public bool MoveNext(ref BindingTable outerBindings)
    {
        if (_exhausted)
            return false;

        if (!_initialized)
        {
            Initialize();
            _initialized = true;
        }

        if (_materializedResults == null || _currentIndex >= _materializedResults.Count)
        {
            _exhausted = true;
            return false;
        }

        // Clear outer bindings before projecting new values
        outerBindings.Clear();

        // Copy bindings from materialized row to outer bindings
        var row = _materializedResults[_currentIndex++];
        for (int i = 0; i < row.BindingCount; i++)
        {
            outerBindings.BindWithHash(row.GetHash(i), row.GetValue(i));
        }

        return true;
    }

    /// <summary>
    /// Materializes all subquery results during initialization.
    /// Delegates to BoxedSubQueryExecutor to isolate large scan operator stack usage.
    /// </summary>
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
    private void Initialize()
    {
        // Convert span to string for boxed executor (one allocation per subquery is acceptable)
        var sourceString = _source.ToString();

        // Use boxed executor to isolate scan operator stack usage
        // The class methods have fresh stack frames without accumulated ref struct overhead
        // Pass prefix mappings for expanding prefixed names in subquery patterns
        var executor = new BoxedSubQueryExecutor(_store, sourceString, _subSelect, _prefixes);
        _materializedResults = executor.Execute();
    }

    public void Dispose()
    {
        // No-op: scans are created and disposed in BoxedSubQueryExecutor
        // Results are stored in _materializedResults (managed List<T>)
    }
}

/// <summary>
/// Joins subquery results with outer triple patterns using nested loop join.
/// Conforms to <see cref="IScan"/> contract (duck typing).
/// For queries like: SELECT * WHERE { ?s ?p ?o . { SELECT ?s WHERE { ... } } }
/// Subquery is the driving (outer) relation; outer patterns are filtered using bound variables.
/// </summary>
internal ref struct SubQueryJoinScan
{
    private readonly QuadStore _store;
    private readonly ReadOnlySpan<char> _source;
    private readonly GraphPattern _pattern;
    private readonly SubSelect _subSelect;
    private readonly PrefixMapping[]? _prefixes;

    // Subquery execution state
    private SubQueryScan _subQueryScan;
    private Binding[] _subBindingStorage;
    private char[] _subStringBuffer;
    private BindingTable _subBindings;

    // Outer pattern execution state
    private MultiPatternScan _outerScan;
    private TriplePatternScan _singleOuterScan;
    private GraphPattern _outerPattern;
    private bool _outerInitialized;
    private bool _useMultiPattern;

    // Current binding checkpoint for rollback
    private int _bindingCheckpoint;

    public SubQueryJoinScan(QuadStore store, ReadOnlySpan<char> source,
        GraphPattern pattern, SubSelect subSelect)
        : this(store, source, pattern, subSelect, null)
    {
    }

    public SubQueryJoinScan(QuadStore store, ReadOnlySpan<char> source,
        GraphPattern pattern, SubSelect subSelect, PrefixMapping[]? prefixes)
    {
        _store = store;
        _source = source;
        _pattern = pattern;
        _subSelect = subSelect;
        _prefixes = prefixes;

        // Initialize subquery state with prefix mappings
        _subQueryScan = new SubQueryScan(store, source, subSelect, prefixes);
        _subBindingStorage = new Binding[16];
        _subStringBuffer = PooledBufferManager.Shared.Rent<char>(512).Array!;
        _subBindings = new BindingTable(_subBindingStorage, _subStringBuffer);

        // Build outer pattern from non-subquery patterns
        _outerPattern = new GraphPattern();
        for (int i = 0; i < pattern.PatternCount; i++)
        {
            _outerPattern.AddPattern(pattern.GetPattern(i));
        }
        _useMultiPattern = _outerPattern.PatternCount > 1;

        _outerScan = default;
        _singleOuterScan = default;
        _outerInitialized = false;
        _bindingCheckpoint = 0;
    }

    public bool MoveNext(ref BindingTable bindings)
    {
        // If no outer patterns, just return subquery results directly
        if (_outerPattern.PatternCount == 0)
        {
            if (!_subQueryScan.MoveNext(ref _subBindings))
                return false;
            CopySubQueryBindings(ref bindings);
            return true;
        }

        while (true)
        {
            QueryCancellation.ThrowIfCancellationRequested();

            // Try to get next result from current outer pattern scan
            if (_outerInitialized)
            {
                bool hasOuter;
                if (_useMultiPattern)
                    hasOuter = _outerScan.MoveNext(ref bindings);
                else
                    hasOuter = _singleOuterScan.MoveNext(ref bindings);

                if (hasOuter)
                {
                    // We have a joined result: subquery bindings + outer pattern bindings
                    return true;
                }

                // Outer patterns exhausted for this subquery row
                // Reset for next subquery row
                _outerInitialized = false;
                if (_useMultiPattern)
                    _outerScan.Dispose();
                else
                    _singleOuterScan.Dispose();
                bindings.TruncateTo(_bindingCheckpoint);
            }

            // Get next subquery result
            if (!_subQueryScan.MoveNext(ref _subBindings))
            {
                return false;
            }

            // Save checkpoint and copy subquery bindings to outer bindings
            _bindingCheckpoint = bindings.Count;
            CopySubQueryBindings(ref bindings);

            // Initialize outer pattern scan with current bindings
            InitializeOuterScan(ref bindings);
            _outerInitialized = true;
        }
    }

    private void CopySubQueryBindings(ref BindingTable bindings)
    {
        // Project subquery variables to outer binding table
        for (int i = 0; i < _subBindings.Count; i++)
        {
            var hash = _subBindings.GetVariableHash(i);
            var value = _subBindings.GetString(i);
            bindings.BindWithHash(hash, value);
        }
        _subBindings.Clear();
    }

    private void InitializeOuterScan(ref BindingTable bindings)
    {
        if (_useMultiPattern)
        {
            // MultiPatternScan with initial bindings
            // MultiPatternScan resolves variables from bindings in ResolveAndQuery
            _outerScan = new MultiPatternScan(_store, _source, _outerPattern);
        }
        else if (_outerPattern.PatternCount == 1)
        {
            var tp = _outerPattern.GetPattern(0);
            _singleOuterScan = new TriplePatternScan(_store, _source, tp, bindings);
        }
    }

    public void Dispose()
    {
        _subQueryScan.Dispose();
        if (_outerInitialized)
        {
            if (_useMultiPattern)
                _outerScan.Dispose();
            else
                _singleOuterScan.Dispose();
        }
        if (_subStringBuffer != null)
            PooledBufferManager.Shared.Return(_subStringBuffer);
    }
}

/// <summary>
/// Scans triple patterns across multiple default graphs (FROM clauses), unioning results.
/// Conforms to <see cref="IScan"/> contract (duck typing).
/// This is a streaming operator that avoids materializing all results upfront.
/// </summary>
internal ref struct DefaultGraphUnionScan
{
    private readonly QuadStore _store;
    private readonly ReadOnlySpan<char> _source;
    private readonly GraphPattern _pattern;
    private readonly string[] _defaultGraphs;
    private int _currentGraphIndex;
    private TriplePatternScan _singleScan;
    private MultiPatternScan _multiScan;
    private bool _isMultiPattern;
    private bool _initialized;
    private bool _exhausted;

    public DefaultGraphUnionScan(QuadStore store, ReadOnlySpan<char> source, GraphPattern pattern, string[] defaultGraphs)
    {
        _store = store;
        _source = source;
        _pattern = pattern;
        _defaultGraphs = defaultGraphs;
        _currentGraphIndex = 0;
        _singleScan = default;
        _multiScan = default;
        _isMultiPattern = pattern.RequiredPatternCount > 1;
        _initialized = false;
        _exhausted = false;
    }

    public bool MoveNext(ref BindingTable bindings)
    {
        if (_exhausted)
            return false;

        while (true)
        {
            QueryCancellation.ThrowIfCancellationRequested();

            // Try to get next result from current graph's scan
            if (_initialized)
            {
                bool hasNext = _isMultiPattern
                    ? _multiScan.MoveNext(ref bindings)
                    : _singleScan.MoveNext(ref bindings);

                if (hasNext)
                    return true;

                // Current graph exhausted, dispose and move to next
                if (_isMultiPattern)
                    _multiScan.Dispose();
                else
                    _singleScan.Dispose();
                _initialized = false;
            }

            // Move to next graph
            if (_currentGraphIndex >= _defaultGraphs.Length)
            {
                _exhausted = true;
                return false;
            }

            // Clear bindings before switching to new graph
            // Each graph should start fresh (FROM semantics = union of independent queries)
            bindings.Clear();

            // Initialize scan for new graph
            var graphIri = _defaultGraphs[_currentGraphIndex++].AsSpan();
            InitializeScan(graphIri, ref bindings);
            _initialized = true;
        }
    }

    private void InitializeScan(ReadOnlySpan<char> graphIri, ref BindingTable bindings)
    {
        if (_isMultiPattern)
        {
            _multiScan = new MultiPatternScan(_store, _source, _pattern, false, graphIri);
        }
        else
        {
            // Find the first required pattern
            int requiredIdx = 0;
            for (int i = 0; i < _pattern.PatternCount; i++)
            {
                if (!_pattern.IsOptional(i)) { requiredIdx = i; break; }
            }

            var tp = _pattern.GetPattern(requiredIdx);
            _singleScan = new TriplePatternScan(_store, _source, tp, bindings, graphIri);
        }
    }

    public void Dispose()
    {
        if (_initialized)
        {
            if (_isMultiPattern)
                _multiScan.Dispose();
            else
                _singleScan.Dispose();
        }
    }
}

/// <summary>
/// Scans triple patterns across multiple graphs with cross-graph joins.
/// Conforms to <see cref="IScan"/> contract (duck typing).
/// Unlike DefaultGraphUnionScan which runs each complete pattern against each graph independently,
/// this operator allows joins where one pattern matches in graph1 and another in graph2.
///
/// For example, with FROM graph1 FROM graph2 and pattern { ?s name ?name . ?s age ?age }:
/// - First pattern queries both graph1 and graph2
/// - For each match, second pattern also queries both graph1 and graph2
/// This allows joining ?s=Alice from graph1's name with ?s=Alice from graph2's age.
/// </summary>
internal ref struct CrossGraphMultiPatternScan
{
    private readonly QuadStore _store;
    private readonly ReadOnlySpan<char> _source;
    private readonly GraphPattern _pattern;
    private readonly string[] _graphs;

    // Current state for each pattern level
    private TemporalResultEnumerator _enum0;
    private TemporalResultEnumerator _enum1;
    private TemporalResultEnumerator _enum2;
    private TemporalResultEnumerator _enum3;

    // Current graph index at each level
    private int _graphIndex0, _graphIndex1, _graphIndex2, _graphIndex3;

    private int _currentLevel;
    private bool _init0, _init1, _init2, _init3;
    private bool _exhausted;

    // Track binding count at entry to each level for rollback
    private int _bindingCount0, _bindingCount1, _bindingCount2, _bindingCount3;

    public CrossGraphMultiPatternScan(QuadStore store, ReadOnlySpan<char> source, GraphPattern pattern, string[] graphs)
    {
        _store = store;
        _source = source;
        _pattern = pattern;
        _graphs = graphs;
        _currentLevel = 0;
        _init0 = _init1 = _init2 = _init3 = false;
        _exhausted = false;
        _enum0 = default;
        _enum1 = default;
        _enum2 = default;
        _enum3 = default;
        _graphIndex0 = _graphIndex1 = _graphIndex2 = _graphIndex3 = 0;
        _bindingCount0 = _bindingCount1 = _bindingCount2 = _bindingCount3 = 0;
    }

    public bool MoveNext(ref BindingTable bindings)
    {
        if (_exhausted)
            return false;

        var patternCount = Math.Min(_pattern.RequiredPatternCount, 4);
        if (patternCount == 0)
            return false;

        while (true)
        {
            QueryCancellation.ThrowIfCancellationRequested();

            bool advanced;
            switch (_currentLevel)
            {
                case 0: advanced = TryAdvanceLevel0(ref bindings); break;
                case 1: advanced = TryAdvanceLevel1(ref bindings); break;
                case 2: advanced = TryAdvanceLevel2(ref bindings); break;
                case 3: advanced = TryAdvanceLevel3(ref bindings); break;
                default: advanced = false; break;
            }

            if (advanced)
            {
                if (_currentLevel == patternCount - 1)
                {
                    // At deepest level - we have a complete result
                    return true;
                }
                else
                {
                    // Go deeper
                    _currentLevel++;
                    SetInitialized(_currentLevel, false);
                    SetGraphIndex(_currentLevel, 0);
                }
            }
            else
            {
                // Current level exhausted across all graphs, backtrack
                if (_currentLevel == 0)
                {
                    _exhausted = true;
                    return false;
                }

                // Go up
                _currentLevel--;
            }
        }
    }

    private void SetInitialized(int level, bool value)
    {
        switch (level)
        {
            case 0: _init0 = value; break;
            case 1: _init1 = value; break;
            case 2: _init2 = value; break;
            case 3: _init3 = value; break;
        }
    }

    private void SetGraphIndex(int level, int value)
    {
        switch (level)
        {
            case 0: _graphIndex0 = value; break;
            case 1: _graphIndex1 = value; break;
            case 2: _graphIndex2 = value; break;
            case 3: _graphIndex3 = value; break;
        }
    }

    private bool TryAdvanceLevel0(scoped ref BindingTable bindings)
    {
        var pattern = GetRequiredPattern(0);

        while (true)
        {
            QueryCancellation.ThrowIfCancellationRequested();

            if (!_init0)
            {
                _bindingCount0 = bindings.Count;
                if (_graphIndex0 >= _graphs.Length)
                    return false; // All graphs exhausted at this level
                InitializeEnumerator(pattern, ref bindings, _graphs[_graphIndex0].AsSpan(), out _enum0);
                _init0 = true;
            }
            else
            {
                // Rolling back bindings from previous attempt
                bindings.TruncateTo(_bindingCount0);
            }

            if (TryAdvanceEnumerator(ref _enum0, pattern, ref bindings))
                return true;

            // Current graph exhausted, try next graph
            _enum0.Dispose();
            _graphIndex0++;
            _init0 = false;

            if (_graphIndex0 >= _graphs.Length)
                return false;
        }
    }

    private bool TryAdvanceLevel1(scoped ref BindingTable bindings)
    {
        var pattern = GetRequiredPattern(1);

        while (true)
        {
            QueryCancellation.ThrowIfCancellationRequested();

            if (!_init1)
            {
                _bindingCount1 = bindings.Count;
                if (_graphIndex1 >= _graphs.Length)
                    return false;
                InitializeEnumerator(pattern, ref bindings, _graphs[_graphIndex1].AsSpan(), out _enum1);
                _init1 = true;
            }
            else
            {
                bindings.TruncateTo(_bindingCount1);
            }

            if (TryAdvanceEnumerator(ref _enum1, pattern, ref bindings))
                return true;

            _enum1.Dispose();
            _graphIndex1++;
            _init1 = false;

            if (_graphIndex1 >= _graphs.Length)
                return false;
        }
    }

    private bool TryAdvanceLevel2(scoped ref BindingTable bindings)
    {
        var pattern = GetRequiredPattern(2);

        while (true)
        {
            QueryCancellation.ThrowIfCancellationRequested();

            if (!_init2)
            {
                _bindingCount2 = bindings.Count;
                if (_graphIndex2 >= _graphs.Length)
                    return false;
                InitializeEnumerator(pattern, ref bindings, _graphs[_graphIndex2].AsSpan(), out _enum2);
                _init2 = true;
            }
            else
            {
                bindings.TruncateTo(_bindingCount2);
            }

            if (TryAdvanceEnumerator(ref _enum2, pattern, ref bindings))
                return true;

            _enum2.Dispose();
            _graphIndex2++;
            _init2 = false;

            if (_graphIndex2 >= _graphs.Length)
                return false;
        }
    }

    private bool TryAdvanceLevel3(scoped ref BindingTable bindings)
    {
        var pattern = GetRequiredPattern(3);

        while (true)
        {
            QueryCancellation.ThrowIfCancellationRequested();

            if (!_init3)
            {
                _bindingCount3 = bindings.Count;
                if (_graphIndex3 >= _graphs.Length)
                    return false;
                InitializeEnumerator(pattern, ref bindings, _graphs[_graphIndex3].AsSpan(), out _enum3);
                _init3 = true;
            }
            else
            {
                bindings.TruncateTo(_bindingCount3);
            }

            if (TryAdvanceEnumerator(ref _enum3, pattern, ref bindings))
                return true;

            _enum3.Dispose();
            _graphIndex3++;
            _init3 = false;

            if (_graphIndex3 >= _graphs.Length)
                return false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private TriplePattern GetRequiredPattern(int index)
    {
        // Find the nth required (non-optional) pattern
        int found = 0;
        for (int i = 0; i < _pattern.PatternCount; i++)
        {
            if (!_pattern.IsOptional(i))
            {
                if (found == index)
                    return _pattern.GetPattern(i);
                found++;
            }
        }
        return default;
    }

    private void InitializeEnumerator(TriplePattern pattern, scoped ref BindingTable bindings,
        ReadOnlySpan<char> graph, out TemporalResultEnumerator enumerator)
    {
        ReadOnlySpan<char> subject, predicate, obj;

        // Resolve subject - blank nodes act as wildcards (match any value)
        if (pattern.Subject.IsBlankNode)
            subject = ReadOnlySpan<char>.Empty;
        else if (!pattern.Subject.IsVariable)
            subject = _source.Slice(pattern.Subject.Start, pattern.Subject.Length);
        else
        {
            var varName = _source.Slice(pattern.Subject.Start, pattern.Subject.Length);
            var idx = bindings.FindBinding(varName);
            subject = idx >= 0 ? bindings.GetString(idx) : ReadOnlySpan<char>.Empty;
        }

        // Resolve predicate - blank nodes act as wildcards
        if (pattern.Predicate.IsBlankNode)
            predicate = ReadOnlySpan<char>.Empty;
        else if (!pattern.Predicate.IsVariable)
            predicate = _source.Slice(pattern.Predicate.Start, pattern.Predicate.Length);
        else
        {
            var varName = _source.Slice(pattern.Predicate.Start, pattern.Predicate.Length);
            var idx = bindings.FindBinding(varName);
            predicate = idx >= 0 ? bindings.GetString(idx) : ReadOnlySpan<char>.Empty;
        }

        // Resolve object - blank nodes act as wildcards
        if (pattern.Object.IsBlankNode)
            obj = ReadOnlySpan<char>.Empty;
        else if (!pattern.Object.IsVariable)
            obj = _source.Slice(pattern.Object.Start, pattern.Object.Length);
        else
        {
            var varName = _source.Slice(pattern.Object.Start, pattern.Object.Length);
            var idx = bindings.FindBinding(varName);
            obj = idx >= 0 ? bindings.GetString(idx) : ReadOnlySpan<char>.Empty;
        }

        enumerator = _store.QueryCurrent(subject, predicate, obj, graph);
    }

    private bool TryAdvanceEnumerator(ref TemporalResultEnumerator enumerator,
        TriplePattern pattern, scoped ref BindingTable bindings)
    {
        while (enumerator.MoveNext())
        {
            var triple = enumerator.Current;

            if (TryBindVariable(pattern.Subject, triple.Subject, ref bindings) &&
                TryBindVariable(pattern.Predicate, triple.Predicate, ref bindings) &&
                TryBindVariable(pattern.Object, triple.Object, ref bindings))
            {
                return true;
            }
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool TryBindVariable(Term term, ReadOnlySpan<char> value, scoped ref BindingTable bindings)
    {
        if (!term.IsVariable)
            return true;

        var varName = _source.Slice(term.Start, term.Length);
        var existingIndex = bindings.FindBinding(varName);

        if (existingIndex >= 0)
        {
            var existingValue = bindings.GetString(existingIndex);
            return value.SequenceEqual(existingValue);
        }

        bindings.Bind(varName, value);
        return true;
    }

    public void Dispose()
    {
        if (_init0) _enum0.Dispose();
        if (_init1) _enum1.Dispose();
        if (_init2) _enum2.Dispose();
        if (_init3) _enum3.Dispose();
    }
}

// NOTE: ServiceScan operator was removed and replaced with ServicePatternScan in ServiceMaterializer.cs.
// The new implementation separates fetching (FetchServiceResults) from iteration (ServicePatternScan),
// enabling optimizations like fetching SERVICE results once for join scenarios.
// See QueryExecutor.Service.cs for the integration.

// NOTE: ServiceJoinScan operator was replaced with materialization pattern.
// The QueryResults ref struct (~22KB) combined with large GraphPattern (~4KB) can
// exceed stack limits in complex query paths. The fix is to materialize SERVICE
// results to List<MaterializedRow> early, returning only heap pointers through the
// call chain. See docs/mercury-adr-buffer-pattern.md for the pattern details.
