using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using SkyOmega.Mercury.Sparql;
using SkyOmega.Mercury.Storage;

namespace SkyOmega.Mercury.Sparql.Execution;

/// <summary>
/// Helper for resolving synthetic terms generated by SPARQL-star expansion.
/// Synthetic terms use negative Start offsets to indicate they're not in the source.
/// </summary>
internal static class SyntheticTermHelper
{
    // RDF namespace IRIs for reification patterns
    public const string RdfType = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#type>";
    public const string RdfStatement = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#Statement>";
    public const string RdfSubject = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#subject>";
    public const string RdfPredicate = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate>";
    public const string RdfObject = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#object>";

    // Pre-allocated synthetic variable names for reifier bindings (up to 32 per query)
    private static readonly string[] SyntheticVarNames = new string[32];

    // Pre-allocated synthetic variable names for sequence path intermediates (up to 32 per query)
    private static readonly string[] SyntheticSeqVarNames = new string[32];

    static SyntheticTermHelper()
    {
        for (int i = 0; i < SyntheticVarNames.Length; i++)
            SyntheticVarNames[i] = $"?_qt{i}";
        for (int i = 0; i < SyntheticSeqVarNames.Length; i++)
            SyntheticSeqVarNames[i] = $"?_seq{i}";
    }

    /// <summary>
    /// Check if a term has a synthetic (negative) offset.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsSynthetic(int start) => start < 0;

    /// <summary>
    /// Get the synthetic IRI for a negative offset.
    /// Offsets: -1 = rdf:type, -2 = rdf:Statement, -3 = rdf:subject, -4 = rdf:predicate, -5 = rdf:object
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan<char> GetSyntheticIri(int start)
    {
        return start switch
        {
            -1 => RdfType.AsSpan(),
            -2 => RdfStatement.AsSpan(),
            -3 => RdfSubject.AsSpan(),
            -4 => RdfPredicate.AsSpan(),
            -5 => RdfObject.AsSpan(),
            _ => ReadOnlySpan<char>.Empty
        };
    }

    /// <summary>
    /// Get the synthetic variable name for a negative offset.
    /// Reifier variables: -100 to -131 = ?_qt0 to ?_qt31
    /// Sequence variables: -200 to -231 = ?_seq0 to ?_seq31
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan<char> GetSyntheticVarName(int start)
    {
        // Check for sequence variables first (-200 to -231)
        if (start <= -200 && start > -232)
        {
            var index = -start - 200;
            if (index < SyntheticSeqVarNames.Length)
                return SyntheticSeqVarNames[index].AsSpan();
        }

        // Reifier variables (-100 to -131)
        var qtIndex = -start - 100;
        if (qtIndex >= 0 && qtIndex < SyntheticVarNames.Length)
            return SyntheticVarNames[qtIndex].AsSpan();
        return ReadOnlySpan<char>.Empty;
    }

    /// <summary>
    /// Get the synthetic offset for a sequence intermediate variable.
    /// Index 0 = offset -200, index 1 = offset -201, etc.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int GetSeqVarOffset(int index) => -(200 + index);
}

public ref struct TriplePatternScan
{
    private readonly QuadStore _store;
    private readonly ReadOnlySpan<char> _source;
    private readonly TriplePattern _pattern;
    private TemporalResultEnumerator _enumerator;
    private bool _initialized;
    private readonly BindingTable _initialBindings;
    private readonly int _initialBindingsCount;
    private readonly ReadOnlySpan<char> _graph;

    // Temporal query parameters
    private readonly TemporalQueryMode _temporalMode;
    private readonly DateTimeOffset _asOfTime;
    private readonly DateTimeOffset _rangeStart;
    private readonly DateTimeOffset _rangeEnd;

    // For property path traversal
    private readonly bool _isInverse;
    private readonly bool _isZeroOrMore;
    private readonly bool _isOneOrMore;
    private readonly bool _isZeroOrOne;
    private readonly bool _isAlternative;

    // State for transitive path traversal
    private HashSet<string>? _visited;
    private Queue<string>? _frontier;
    private string? _currentNode;
    private string? _startNode;  // Original start node for binding
    private bool _emittedReflexive;

    // State for alternative path traversal (p1|p2)
    private int _alternativePhase; // 0 = first predicate, 1 = second predicate

    public TriplePatternScan(QuadStore store, ReadOnlySpan<char> source,
        TriplePattern pattern, BindingTable initialBindings, ReadOnlySpan<char> graph = default)
        : this(store, source, pattern, initialBindings, graph,
               TemporalQueryMode.Current, default, default, default)
    {
    }

    public TriplePatternScan(QuadStore store, ReadOnlySpan<char> source,
        TriplePattern pattern, BindingTable initialBindings, ReadOnlySpan<char> graph,
        TemporalQueryMode temporalMode, DateTimeOffset asOfTime,
        DateTimeOffset rangeStart, DateTimeOffset rangeEnd)
    {
        _store = store;
        _source = source;
        _pattern = pattern;
        _initialBindings = initialBindings;
        _initialBindingsCount = initialBindings.Count;
        _graph = graph;
        _initialized = false;
        _enumerator = default;

        // Temporal parameters
        _temporalMode = temporalMode;
        _asOfTime = asOfTime;
        _rangeStart = rangeStart;
        _rangeEnd = rangeEnd;

        // Check property path type
        _isInverse = pattern.Path.Type == PathType.Inverse;
        _isZeroOrMore = pattern.Path.Type == PathType.ZeroOrMore;
        _isOneOrMore = pattern.Path.Type == PathType.OneOrMore;
        _isZeroOrOne = pattern.Path.Type == PathType.ZeroOrOne;
        _isAlternative = pattern.Path.Type == PathType.Alternative;

        _visited = null;
        _frontier = null;
        _currentNode = null;
        _startNode = null;
        _emittedReflexive = false;
        _alternativePhase = 0;
    }

    public bool MoveNext(ref BindingTable bindings)
    {
        if (!_initialized)
        {
            Initialize();
            _initialized = true;
        }

        // Handle transitive paths with BFS
        if (_isZeroOrMore || _isOneOrMore)
        {
            return MoveNextTransitive(ref bindings);
        }

        while (true)
        {
            while (_enumerator.MoveNext())
            {
                var triple = _enumerator.Current;

                // Preserve initial bindings (from subquery join), only clear added bindings
                bindings.TruncateTo(_initialBindingsCount);

                if (_isInverse)
                {
                    // For inverse, swap subject and object bindings
                    if (!TryBindVariable(_pattern.Subject, triple.Object, ref bindings))
                        continue;
                    if (!TryBindVariable(_pattern.Object, triple.Subject, ref bindings))
                        continue;
                }
                else
                {
                    // Normal binding
                    if (!TryBindVariable(_pattern.Subject, triple.Subject, ref bindings))
                        continue;
                    if (!TryBindVariable(_pattern.Predicate, triple.Predicate, ref bindings))
                        continue;
                    if (!TryBindVariable(_pattern.Object, triple.Object, ref bindings))
                        continue;
                }

                return true;
            }

            // Current predicate exhausted - check for alternative path
            if (_isAlternative && _alternativePhase == 0)
            {
                // Switch to second predicate in the alternative
                _alternativePhase = 1;
                _enumerator.Dispose();

                // Re-initialize with second predicate from path's Right offsets
                var subject = ResolveTermForQuery(_pattern.Subject);
                var obj = ResolveTermForQuery(_pattern.Object);
                var predicate2 = _source.Slice(_pattern.Path.RightStart, _pattern.Path.RightLength);

                _enumerator = ExecuteTemporalQuery(subject, predicate2, obj);
                continue; // Try again with second predicate
            }

            break; // No more alternatives
        }

        // For zero-or-one, also emit reflexive case if subject == object and not yet emitted
        if (_isZeroOrOne && !_emittedReflexive)
        {
            _emittedReflexive = true;
            bindings.TruncateTo(_initialBindingsCount);

            // Only emit reflexive if subject variable is bound or is concrete
            var subjectSpan = ResolveTermForQuery(_pattern.Subject);
            if (!subjectSpan.IsEmpty)
            {
                // Bind subject to both subject and object positions
                if (TryBindVariable(_pattern.Subject, subjectSpan, ref bindings) &&
                    TryBindVariable(_pattern.Object, subjectSpan, ref bindings))
                {
                    return true;
                }
            }
        }

        return false;
    }

    private bool MoveNextTransitive(ref BindingTable bindings)
    {
        // For zero-or-more (p*), emit reflexive case first: start node matches itself at 0 hops
        if (_isZeroOrMore && !_emittedReflexive)
        {
            _emittedReflexive = true;
            bindings.TruncateTo(_initialBindingsCount);

            // Bind subject to start node, object to start node (reflexive)
            if (TryBindVariable(_pattern.Subject, _startNode.AsSpan(), ref bindings) &&
                TryBindVariable(_pattern.Object, _startNode.AsSpan(), ref bindings))
            {
                return true;
            }
        }

        // BFS for transitive closure
        while (true)
        {
            // Try to get next result from current frontier node
            while (_enumerator.MoveNext())
            {
                var triple = _enumerator.Current;
                var targetNode = triple.Object.ToString();

                if (!_visited!.Contains(targetNode))
                {
                    _visited.Add(targetNode);
                    _frontier!.Enqueue(targetNode);

                    bindings.TruncateTo(_initialBindingsCount);
                    // Bind subject to original start node, object to the discovered target
                    if (TryBindVariable(_pattern.Subject, _startNode.AsSpan(), ref bindings) &&
                        TryBindVariable(_pattern.Object, triple.Object, ref bindings))
                    {
                        return true;
                    }
                }
            }

            // Move to next frontier node
            _enumerator.Dispose();
            if (_frontier!.Count == 0)
                return false;

            _currentNode = _frontier.Dequeue();
            var predicate = _pattern.HasPropertyPath
                ? ResolveTermForQuery(_pattern.Path.Iri)
                : ResolveTermForQuery(_pattern.Predicate);

            _enumerator = ExecuteTemporalQuery(
                _currentNode.AsSpan(),
                predicate,
                ReadOnlySpan<char>.Empty);
        }
    }

    private void Initialize()
    {
        if (_isZeroOrMore || _isOneOrMore)
        {
            InitializeTransitive();
            return;
        }

        // Resolve terms to spans for querying
        var subject = ResolveTermForQuery(_pattern.Subject);
        var obj = ResolveTermForQuery(_pattern.Object);

        ReadOnlySpan<char> predicate;
        if (_isInverse)
        {
            // For inverse path, query with swapped subject/object
            predicate = ResolveTermForQuery(_pattern.Path.Iri);
            _enumerator = ExecuteTemporalQuery(obj, predicate, subject);
        }
        else if (_isAlternative)
        {
            // For alternative path (p1|p2), start with first predicate from Left offsets
            predicate = _source.Slice(_pattern.Path.LeftStart, _pattern.Path.LeftLength);
            _enumerator = ExecuteTemporalQuery(subject, predicate, obj);
        }
        else
        {
            predicate = ResolveTermForQuery(_pattern.Predicate);
            _enumerator = ExecuteTemporalQuery(subject, predicate, obj);
        }
    }

    private TemporalResultEnumerator ExecuteTemporalQuery(
        ReadOnlySpan<char> subject, ReadOnlySpan<char> predicate, ReadOnlySpan<char> obj)
    {
        return _temporalMode switch
        {
            TemporalQueryMode.AsOf =>
                _store.QueryAsOf(subject, predicate, obj, _asOfTime, _graph),
            TemporalQueryMode.During =>
                _store.QueryChanges(_rangeStart, _rangeEnd, subject, predicate, obj, _graph),
            TemporalQueryMode.AllVersions =>
                _store.QueryEvolution(subject, predicate, obj, _graph),
            _ => _store.QueryCurrent(subject, predicate, obj, _graph)
        };
    }

    private void InitializeTransitive()
    {
        _visited = new HashSet<string>();
        _frontier = new Queue<string>();

        var subject = ResolveTermForQuery(_pattern.Subject);
        _startNode = subject.ToString();

        // For zero-or-more, we'll emit reflexive first in MoveNextTransitive
        // For one-or-more, we skip the reflexive case
        _emittedReflexive = false;

        _visited.Add(_startNode);
        _currentNode = _startNode;

        var predicate = _pattern.HasPropertyPath
            ? ResolveTermForQuery(_pattern.Path.Iri)
            : ResolveTermForQuery(_pattern.Predicate);

        _enumerator = ExecuteTemporalQuery(
            _startNode.AsSpan(),
            predicate,
            ReadOnlySpan<char>.Empty);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ReadOnlySpan<char> ResolveTermForQuery(Term term)
    {
        // Handle synthetic terms (negative offsets from SPARQL-star expansion)
        if (SyntheticTermHelper.IsSynthetic(term.Start))
        {
            if (term.IsVariable)
            {
                // Synthetic variable: check binding with synthetic name
                var varName = SyntheticTermHelper.GetSyntheticVarName(term.Start);
                var idx = _initialBindings.FindBinding(varName);
                if (idx >= 0)
                    return _initialBindings.GetString(idx);
                return ReadOnlySpan<char>.Empty;
            }
            // Synthetic IRI (rdf:type, rdf:subject, etc.)
            return SyntheticTermHelper.GetSyntheticIri(term.Start);
        }

        if (term.IsVariable)
        {
            // Check if variable is already bound in initial bindings
            var varName = _source.Slice(term.Start, term.Length);
            var idx = _initialBindings.FindBinding(varName);
            if (idx >= 0)
                return _initialBindings.GetString(idx);

            // Unbound variable becomes wildcard (empty span)
            return ReadOnlySpan<char>.Empty;
        }

        // IRIs and literals use their source text
        return _source.Slice(term.Start, term.Length);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool TryBindVariable(Term term, ReadOnlySpan<char> value, ref BindingTable bindings)
    {
        if (!term.IsVariable)
        {
            // Constant - verify it matches (should already match from query)
            return true;
        }

        // Handle synthetic variables (from SPARQL-star expansion)
        ReadOnlySpan<char> varName;
        if (SyntheticTermHelper.IsSynthetic(term.Start))
            varName = SyntheticTermHelper.GetSyntheticVarName(term.Start);
        else
            varName = _source.Slice(term.Start, term.Length);

        // Check if already bound (from earlier pattern in join)
        var existingIndex = bindings.FindBinding(varName);
        if (existingIndex >= 0)
        {
            // Must match existing binding
            var existingValue = bindings.GetString(existingIndex);
            return value.SequenceEqual(existingValue);
        }

        // Bind new variable
        bindings.Bind(varName, value);
        return true;
    }

    public void Dispose()
    {
        _enumerator.Dispose();
    }
}

/// <summary>
/// Executes multiple triple patterns using nested loop join.
/// Due to ref struct limitations, we store resolved term strings in fixed buffers
/// to avoid span scoping issues with enumerator initialization.
/// </summary>
public ref struct MultiPatternScan
{
    private readonly QuadStore _store;
    private readonly ReadOnlySpan<char> _source;
    private readonly GraphPattern _pattern;
    private readonly bool _unionMode;
    private readonly ReadOnlySpan<char> _graph;

    // Temporal query parameters
    private readonly TemporalQueryMode _temporalMode;
    private readonly DateTimeOffset _asOfTime;
    private readonly DateTimeOffset _rangeStart;
    private readonly DateTimeOffset _rangeEnd;

    // Current state for each pattern level (support up to 12 patterns for SPARQL-star with multiple annotations)
    private TemporalResultEnumerator _enum0;
    private TemporalResultEnumerator _enum1;
    private TemporalResultEnumerator _enum2;
    private TemporalResultEnumerator _enum3;
    private TemporalResultEnumerator _enum4;
    private TemporalResultEnumerator _enum5;
    private TemporalResultEnumerator _enum6;
    private TemporalResultEnumerator _enum7;
    private TemporalResultEnumerator _enum8;
    private TemporalResultEnumerator _enum9;
    private TemporalResultEnumerator _enum10;
    private TemporalResultEnumerator _enum11;

    private int _currentLevel;
    private bool _init0, _init1, _init2, _init3;
    private bool _init4, _init5, _init6, _init7;
    private bool _init8, _init9, _init10, _init11;
    private bool _exhausted;

    // Track binding count at entry to each level for rollback
    private int _bindingCount0, _bindingCount1, _bindingCount2, _bindingCount3;
    private int _bindingCount4, _bindingCount5, _bindingCount6, _bindingCount7;
    private int _bindingCount8, _bindingCount9, _bindingCount10, _bindingCount11;

    public MultiPatternScan(QuadStore store, ReadOnlySpan<char> source, GraphPattern pattern,
        bool unionMode = false, ReadOnlySpan<char> graph = default)
        : this(store, source, pattern, unionMode, graph,
               TemporalQueryMode.Current, default, default, default)
    {
    }

    public MultiPatternScan(QuadStore store, ReadOnlySpan<char> source, GraphPattern pattern,
        bool unionMode, ReadOnlySpan<char> graph,
        TemporalQueryMode temporalMode, DateTimeOffset asOfTime,
        DateTimeOffset rangeStart, DateTimeOffset rangeEnd)
    {
        _store = store;
        _source = source;
        _pattern = pattern;
        _unionMode = unionMode;
        _graph = graph;
        _temporalMode = temporalMode;
        _asOfTime = asOfTime;
        _rangeStart = rangeStart;
        _rangeEnd = rangeEnd;
        _currentLevel = 0;
        _init0 = _init1 = _init2 = _init3 = false;
        _init4 = _init5 = _init6 = _init7 = false;
        _init8 = _init9 = _init10 = _init11 = false;
        _exhausted = false;
        _enum0 = default;
        _enum1 = default;
        _enum2 = default;
        _enum3 = default;
        _enum4 = default;
        _enum5 = default;
        _enum6 = default;
        _enum7 = default;
        _enum8 = default;
        _enum9 = default;
        _enum10 = default;
        _enum11 = default;
        _bindingCount0 = _bindingCount1 = _bindingCount2 = _bindingCount3 = 0;
        _bindingCount4 = _bindingCount5 = _bindingCount6 = _bindingCount7 = 0;
        _bindingCount8 = _bindingCount9 = _bindingCount10 = _bindingCount11 = 0;
    }

    /// <summary>
    /// Get pattern at index, respecting union mode.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private TriplePattern GetPatternAt(int index)
    {
        return _unionMode ? _pattern.GetUnionPattern(index) : _pattern.GetPattern(index);
    }

    /// <summary>
    /// Get the number of patterns to process.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private int GetPatternCount()
    {
        return _unionMode ? _pattern.UnionBranchPatternCount : _pattern.RequiredPatternCount;
    }

    public bool MoveNext(ref BindingTable bindings)
    {
        if (_exhausted)
            return false;

        // Get pattern count based on mode (support up to 12 patterns for SPARQL-star with multiple annotations)
        var patternCount = Math.Min(GetPatternCount(), 12);
        if (patternCount == 0)
            return false;

        while (true)
        {
            bool advanced;
            switch (_currentLevel)
            {
                case 0: advanced = TryAdvanceLevel0(ref bindings); break;
                case 1: advanced = TryAdvanceLevel1(ref bindings); break;
                case 2: advanced = TryAdvanceLevel2(ref bindings); break;
                case 3: advanced = TryAdvanceLevel3(ref bindings); break;
                case 4: advanced = TryAdvanceLevel4(ref bindings); break;
                case 5: advanced = TryAdvanceLevel5(ref bindings); break;
                case 6: advanced = TryAdvanceLevel6(ref bindings); break;
                case 7: advanced = TryAdvanceLevel7(ref bindings); break;
                case 8: advanced = TryAdvanceLevel8(ref bindings); break;
                case 9: advanced = TryAdvanceLevel9(ref bindings); break;
                case 10: advanced = TryAdvanceLevel10(ref bindings); break;
                case 11: advanced = TryAdvanceLevel11(ref bindings); break;
                default: advanced = false; break;
            }

            if (advanced)
            {
                if (_currentLevel == patternCount - 1)
                {
                    // At deepest level - we have a complete result
                    return true;
                }
                else
                {
                    // Go deeper
                    _currentLevel++;
                    SetInitialized(_currentLevel, false);
                }
            }
            else
            {
                // Current level exhausted, backtrack
                if (_currentLevel == 0)
                {
                    _exhausted = true;
                    return false;
                }

                // Go up
                _currentLevel--;
            }
        }
    }

    private void SetInitialized(int level, bool value)
    {
        switch (level)
        {
            case 0: _init0 = value; break;
            case 1: _init1 = value; break;
            case 2: _init2 = value; break;
            case 3: _init3 = value; break;
            case 4: _init4 = value; break;
            case 5: _init5 = value; break;
            case 6: _init6 = value; break;
            case 7: _init7 = value; break;
            case 8: _init8 = value; break;
            case 9: _init9 = value; break;
            case 10: _init10 = value; break;
            case 11: _init11 = value; break;
        }
    }

    private bool TryAdvanceLevel0(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(0);

        if (!_init0)
        {
            _bindingCount0 = bindings.Count;
            InitializeEnumerator0(pattern, ref bindings);
            _init0 = true;
        }
        else
        {
            // Rolling back bindings from previous attempt at this level
            bindings.TruncateTo(_bindingCount0);
        }

        return TryAdvanceEnumerator(ref _enum0, pattern, ref bindings);
    }

    private bool TryAdvanceLevel1(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(1);

        if (!_init1)
        {
            _bindingCount1 = bindings.Count;
            InitializeEnumerator1(pattern, ref bindings);
            _init1 = true;
        }
        else
        {
            // Rolling back bindings from previous attempt at this level
            bindings.TruncateTo(_bindingCount1);
        }

        return TryAdvanceEnumerator(ref _enum1, pattern, ref bindings);
    }

    private bool TryAdvanceLevel2(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(2);

        if (!_init2)
        {
            _bindingCount2 = bindings.Count;
            InitializeEnumerator2(pattern, ref bindings);
            _init2 = true;
        }
        else
        {
            // Rolling back bindings from previous attempt at this level
            bindings.TruncateTo(_bindingCount2);
        }

        return TryAdvanceEnumerator(ref _enum2, pattern, ref bindings);
    }

    private bool TryAdvanceLevel3(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(3);

        if (!_init3)
        {
            _bindingCount3 = bindings.Count;
            InitializeEnumerator3(pattern, ref bindings);
            _init3 = true;
        }
        else
        {
            // Rolling back bindings from previous attempt at this level
            bindings.TruncateTo(_bindingCount3);
        }

        return TryAdvanceEnumerator(ref _enum3, pattern, ref bindings);
    }

    private bool TryAdvanceLevel4(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(4);

        if (!_init4)
        {
            _bindingCount4 = bindings.Count;
            InitializeEnumerator4(pattern, ref bindings);
            _init4 = true;
        }
        else
        {
            bindings.TruncateTo(_bindingCount4);
        }

        return TryAdvanceEnumerator(ref _enum4, pattern, ref bindings);
    }

    private bool TryAdvanceLevel5(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(5);

        if (!_init5)
        {
            _bindingCount5 = bindings.Count;
            InitializeEnumerator5(pattern, ref bindings);
            _init5 = true;
        }
        else
        {
            bindings.TruncateTo(_bindingCount5);
        }

        return TryAdvanceEnumerator(ref _enum5, pattern, ref bindings);
    }

    private bool TryAdvanceLevel6(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(6);

        if (!_init6)
        {
            _bindingCount6 = bindings.Count;
            InitializeEnumerator6(pattern, ref bindings);
            _init6 = true;
        }
        else
        {
            bindings.TruncateTo(_bindingCount6);
        }

        return TryAdvanceEnumerator(ref _enum6, pattern, ref bindings);
    }

    private bool TryAdvanceLevel7(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(7);

        if (!_init7)
        {
            _bindingCount7 = bindings.Count;
            InitializeEnumerator7(pattern, ref bindings);
            _init7 = true;
        }
        else
        {
            bindings.TruncateTo(_bindingCount7);
        }

        return TryAdvanceEnumerator(ref _enum7, pattern, ref bindings);
    }

    private bool TryAdvanceLevel8(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(8);

        if (!_init8)
        {
            _bindingCount8 = bindings.Count;
            InitializeEnumerator8(pattern, ref bindings);
            _init8 = true;
        }
        else
        {
            bindings.TruncateTo(_bindingCount8);
        }

        return TryAdvanceEnumerator(ref _enum8, pattern, ref bindings);
    }

    private bool TryAdvanceLevel9(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(9);

        if (!_init9)
        {
            _bindingCount9 = bindings.Count;
            InitializeEnumerator9(pattern, ref bindings);
            _init9 = true;
        }
        else
        {
            bindings.TruncateTo(_bindingCount9);
        }

        return TryAdvanceEnumerator(ref _enum9, pattern, ref bindings);
    }

    private bool TryAdvanceLevel10(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(10);

        if (!_init10)
        {
            _bindingCount10 = bindings.Count;
            InitializeEnumerator10(pattern, ref bindings);
            _init10 = true;
        }
        else
        {
            bindings.TruncateTo(_bindingCount10);
        }

        return TryAdvanceEnumerator(ref _enum10, pattern, ref bindings);
    }

    private bool TryAdvanceLevel11(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(11);

        if (!_init11)
        {
            _bindingCount11 = bindings.Count;
            InitializeEnumerator11(pattern, ref bindings);
            _init11 = true;
        }
        else
        {
            bindings.TruncateTo(_bindingCount11);
        }

        return TryAdvanceEnumerator(ref _enum11, pattern, ref bindings);
    }

    // Each init method resolves terms and creates the enumerator.
    // Terms resolve to either a slice of _source (for constants) or empty span (for unbound variables).
    // Bound variables need their value copied to avoid span escaping issues.
    private void InitializeEnumerator0(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum0);
    }

    private void InitializeEnumerator1(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum1);
    }

    private void InitializeEnumerator2(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum2);
    }

    private void InitializeEnumerator3(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum3);
    }

    private void InitializeEnumerator4(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum4);
    }

    private void InitializeEnumerator5(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum5);
    }

    private void InitializeEnumerator6(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum6);
    }

    private void InitializeEnumerator7(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum7);
    }

    private void InitializeEnumerator8(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum8);
    }

    private void InitializeEnumerator9(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum9);
    }

    private void InitializeEnumerator10(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum10);
    }

    private void InitializeEnumerator11(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enum11);
    }

    private void ResolveAndQuery(TriplePattern pattern, scoped ref BindingTable bindings, out TemporalResultEnumerator enumerator)
    {
        // For each term, resolve to a span. Constants come from _source (stable),
        // unbound variables become empty span. Bound variables need special handling.
        // Synthetic terms (negative offsets) come from SPARQL-star expansion.
        ReadOnlySpan<char> subject, predicate, obj;

        // Check if this is an inverse path
        bool isInverse = pattern.Path.Type == PathType.Inverse;

        // Resolve subject
        subject = ResolveTerm(pattern.Subject, ref bindings);

        // Resolve predicate - for inverse paths, use Path.Iri
        predicate = isInverse
            ? ResolveTerm(pattern.Path.Iri, ref bindings)
            : ResolveTerm(pattern.Predicate, ref bindings);

        // Resolve object
        obj = ResolveTerm(pattern.Object, ref bindings);

        // For inverse paths, swap subject and object in the query
        if (isInverse)
        {
            enumerator = ExecuteTemporalQuery(obj, predicate, subject);
        }
        else
        {
            enumerator = ExecuteTemporalQuery(subject, predicate, obj);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ReadOnlySpan<char> ResolveTerm(Term term, scoped ref BindingTable bindings)
    {
        // Handle synthetic terms (negative offsets from SPARQL-star expansion)
        if (SyntheticTermHelper.IsSynthetic(term.Start))
        {
            if (term.IsVariable)
            {
                var varName = SyntheticTermHelper.GetSyntheticVarName(term.Start);
                var idx = bindings.FindBinding(varName);
                return idx >= 0 ? bindings.GetString(idx) : ReadOnlySpan<char>.Empty;
            }
            return SyntheticTermHelper.GetSyntheticIri(term.Start);
        }

        if (!term.IsVariable)
            return _source.Slice(term.Start, term.Length);

        var name = _source.Slice(term.Start, term.Length);
        var index = bindings.FindBinding(name);
        return index >= 0 ? bindings.GetString(index) : ReadOnlySpan<char>.Empty;
    }

    private TemporalResultEnumerator ExecuteTemporalQuery(
        ReadOnlySpan<char> subject, ReadOnlySpan<char> predicate, ReadOnlySpan<char> obj)
    {
        return _temporalMode switch
        {
            TemporalQueryMode.AsOf =>
                _store.QueryAsOf(subject, predicate, obj, _asOfTime, _graph),
            TemporalQueryMode.During =>
                _store.QueryChanges(_rangeStart, _rangeEnd, subject, predicate, obj, _graph),
            TemporalQueryMode.AllVersions =>
                _store.QueryEvolution(subject, predicate, obj, _graph),
            _ => _store.QueryCurrent(subject, predicate, obj, _graph)
        };
    }

    private bool TryAdvanceEnumerator(ref TemporalResultEnumerator enumerator,
        TriplePattern pattern, scoped ref BindingTable bindings)
    {
        bool isInverse = pattern.Path.Type == PathType.Inverse;

        while (enumerator.MoveNext())
        {
            var triple = enumerator.Current;

            // Try to bind variables, checking consistency with existing bindings
            // For inverse paths, swap subject and object bindings
            if (isInverse)
            {
                // Inverse: pattern.Subject binds to triple.Object, pattern.Object binds to triple.Subject
                if (TryBindVariable(pattern.Subject, triple.Object, ref bindings) &&
                    TryBindVariable(pattern.Object, triple.Subject, ref bindings))
                {
                    return true;
                }
            }
            else
            {
                if (TryBindVariable(pattern.Subject, triple.Subject, ref bindings) &&
                    TryBindVariable(pattern.Predicate, triple.Predicate, ref bindings) &&
                    TryBindVariable(pattern.Object, triple.Object, ref bindings))
                {
                    return true;
                }
            }
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool TryBindVariable(Term term, ReadOnlySpan<char> value, scoped ref BindingTable bindings)
    {
        if (!term.IsVariable)
            return true;

        // Handle synthetic variables (from SPARQL-star expansion)
        ReadOnlySpan<char> varName;
        if (SyntheticTermHelper.IsSynthetic(term.Start))
            varName = SyntheticTermHelper.GetSyntheticVarName(term.Start);
        else
            varName = _source.Slice(term.Start, term.Length);

        var existingIndex = bindings.FindBinding(varName);

        if (existingIndex >= 0)
        {
            var existingValue = bindings.GetString(existingIndex);
            return value.SequenceEqual(existingValue);
        }

        bindings.Bind(varName, value);
        return true;
    }

    public void Dispose()
    {
        _enum0.Dispose();
        _enum1.Dispose();
        _enum2.Dispose();
        _enum3.Dispose();
        _enum4.Dispose();
        _enum5.Dispose();
        _enum6.Dispose();
        _enum7.Dispose();
        _enum8.Dispose();
        _enum9.Dispose();
        _enum10.Dispose();
        _enum11.Dispose();
    }
}

/// <summary>
/// Scans triple patterns across all named graphs, binding a graph variable.
/// For queries like: SELECT ?g ?s ?p ?o WHERE { GRAPH ?g { ?s ?p ?o } }
/// Supports FROM NAMED restriction: only iterate specified named graphs.
/// </summary>
public ref struct VariableGraphScan
{
    private readonly QuadStore _store;
    private readonly ReadOnlySpan<char> _source;
    private readonly GraphClause _graphClause;
    private NamedGraphEnumerator _graphEnum;
    private MultiPatternScan _currentScan;
    private GraphPattern _innerPattern;
    private ReadOnlySpan<char> _currentGraph;
    private readonly int _graphVarHash;
    private bool _initialized;
    private bool _exhausted;

    // FROM NAMED restriction: if non-null, only iterate these graphs
    private readonly string[]? _allowedNamedGraphs;
    private int _allowedGraphIndex;  // For iterating _allowedNamedGraphs directly

    public VariableGraphScan(QuadStore store, ReadOnlySpan<char> source, GraphClause graphClause,
        string[]? allowedNamedGraphs = null)
    {
        _store = store;
        _source = source;
        _graphClause = graphClause;
        _graphEnum = allowedNamedGraphs == null ? store.GetNamedGraphs() : default;
        _currentScan = default;
        _innerPattern = default;
        _currentGraph = default;
        _initialized = false;
        _exhausted = false;
        _allowedNamedGraphs = allowedNamedGraphs;
        _allowedGraphIndex = 0;

        // Compute hash for graph variable name for binding
        var graphVarName = source.Slice(graphClause.Graph.Start, graphClause.Graph.Length);
        _graphVarHash = ComputeHash(graphVarName);

        // Build inner pattern from graph clause patterns
        _innerPattern = new GraphPattern();
        for (int i = 0; i < graphClause.PatternCount; i++)
        {
            _innerPattern.AddPattern(graphClause.GetPattern(i));
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeHash(ReadOnlySpan<char> s)
    {
        unchecked
        {
            int hash = (int)2166136261;
            foreach (var c in s)
                hash = (hash ^ c) * 16777619;
            return hash;
        }
    }

    public bool MoveNext(ref BindingTable bindings)
    {
        if (_exhausted)
            return false;

        while (true)
        {
            // Try to get next result from current graph's scan
            if (_initialized && _currentScan.MoveNext(ref bindings))
            {
                // Bind the graph variable
                var graphVarName = _source.Slice(_graphClause.Graph.Start, _graphClause.Graph.Length);
                bindings.Bind(graphVarName, _currentGraph);
                return true;
            }

            // Move to next graph
            if (!MoveToNextGraph())
            {
                _exhausted = true;
                return false;
            }

            // Initialize scan for new graph
            _currentScan = new MultiPatternScan(_store, _source, _innerPattern, false, _currentGraph);
            _initialized = true;
        }
    }

    private bool MoveToNextGraph()
    {
        if (_allowedNamedGraphs != null)
        {
            // Iterate through allowed graphs list
            if (_allowedGraphIndex >= _allowedNamedGraphs.Length)
                return false;
            _currentGraph = _allowedNamedGraphs[_allowedGraphIndex++].AsSpan();
            return true;
        }
        else
        {
            // Iterate all named graphs
            if (!_graphEnum.MoveNext())
                return false;
            _currentGraph = _graphEnum.Current;
            return true;
        }
    }

    public void Dispose()
    {
        _currentScan.Dispose();
    }
}

/// <summary>
/// Executes a subquery and yields only projected variable bindings.
/// Handles variable scoping: only SELECT-ed variables are visible to outer query.
/// </summary>
public ref struct SubQueryScan
{
    private readonly QuadStore _store;
    private readonly ReadOnlySpan<char> _source;
    private readonly SubSelect _subSelect;
    private MultiPatternScan _innerScan;
    private TriplePatternScan _singleScan;
    private bool _isMultiPattern;
    private Binding[] _innerBindingStorage;
    private char[] _innerStringBuffer;
    private BindingTable _innerBindings;
    private GraphPattern _innerPattern;
    private bool _initialized;
    private bool _exhausted;
    private int _skipped;
    private int _returned;
    private HashSet<int>? _seenHashes;

    public SubQueryScan(QuadStore store, ReadOnlySpan<char> source, SubSelect subSelect)
    {
        _store = store;
        _source = source;
        _subSelect = subSelect;
        _innerScan = default;
        _singleScan = default;
        _isMultiPattern = false;
        _innerBindingStorage = new Binding[16];
        _innerStringBuffer = new char[512];
        _innerBindings = new BindingTable(_innerBindingStorage, _innerStringBuffer);
        _innerPattern = default;
        _initialized = false;
        _exhausted = false;
        _skipped = 0;
        _returned = 0;
        _seenHashes = subSelect.Distinct ? new HashSet<int>() : null;
    }

    public bool MoveNext(ref BindingTable outerBindings)
    {
        if (_exhausted)
            return false;

        if (!_initialized)
        {
            Initialize();
            _initialized = true;
        }

        // Check LIMIT
        if (_subSelect.Limit > 0 && _returned >= _subSelect.Limit)
        {
            _exhausted = true;
            return false;
        }

        while (MoveNextInner())
        {
            // Apply filters if any
            if (_subSelect.FilterCount > 0 && !EvaluateFilters())
            {
                _innerBindings.Clear();
                continue;
            }

            // Apply OFFSET
            if (_skipped < _subSelect.Offset)
            {
                _skipped++;
                _innerBindings.Clear();
                continue;
            }

            // Apply DISTINCT
            if (_seenHashes != null)
            {
                var hash = ComputeProjectedBindingsHash();
                if (!_seenHashes.Add(hash))
                {
                    _innerBindings.Clear();
                    continue;
                }
            }

            // Clear outer bindings before projecting new values
            outerBindings.Clear();

            // Project only selected variables to outer bindings
            ProjectVariables(ref outerBindings);
            _innerBindings.Clear();
            _returned++;
            return true;
        }

        _exhausted = true;
        return false;
    }

    private bool MoveNextInner()
    {
        if (_isMultiPattern)
            return _innerScan.MoveNext(ref _innerBindings);
        else
            return _singleScan.MoveNext(ref _innerBindings);
    }

    private bool EvaluateFilters()
    {
        for (int i = 0; i < _subSelect.FilterCount; i++)
        {
            var filter = _subSelect.GetFilter(i);
            var filterExpr = _source.Slice(filter.Start, filter.Length);

            var evaluator = new FilterEvaluator(filterExpr);
            var result = evaluator.Evaluate(
                _innerBindings.GetBindings(),
                _innerBindings.Count,
                _innerBindings.GetStringBuffer());

            if (!result) return false;
        }
        return true;
    }

    private void Initialize()
    {
        // Build a GraphPattern from the SubSelect's patterns
        _innerPattern = new GraphPattern();
        for (int i = 0; i < _subSelect.PatternCount; i++)
        {
            _innerPattern.AddPattern(_subSelect.GetPattern(i));
        }

        // Use single scan for one pattern, multi scan for multiple
        if (_subSelect.PatternCount == 1)
        {
            _isMultiPattern = false;
            var tp = _subSelect.GetPattern(0);
            _singleScan = new TriplePatternScan(_store, _source, tp, _innerBindings);
        }
        else
        {
            _isMultiPattern = true;
            _innerScan = new MultiPatternScan(_store, _source, _innerPattern);
        }
    }

    private void ProjectVariables(ref BindingTable outerBindings)
    {
        if (_subSelect.SelectAll)
        {
            // Project all variables from inner to outer using hash-based binding
            for (int i = 0; i < _innerBindings.Count; i++)
            {
                var varHash = _innerBindings.GetVariableHash(i);
                var value = _innerBindings.GetString(i);
                outerBindings.BindWithHash(varHash, value);
            }
        }
        else
        {
            // Project only explicitly selected variables
            for (int i = 0; i < _subSelect.ProjectedVarCount; i++)
            {
                var (start, len) = _subSelect.GetProjectedVariable(i);
                var varName = _source.Slice(start, len);
                var idx = _innerBindings.FindBinding(varName);
                if (idx >= 0)
                {
                    outerBindings.Bind(varName, _innerBindings.GetString(idx));
                }
            }
        }
    }

    private int ComputeProjectedBindingsHash()
    {
        unchecked
        {
            int hash = (int)2166136261;

            if (_subSelect.SelectAll)
            {
                for (int i = 0; i < _innerBindings.Count; i++)
                {
                    var value = _innerBindings.GetString(i);
                    foreach (var c in value)
                        hash = (hash ^ c) * 16777619;
                }
            }
            else
            {
                for (int i = 0; i < _subSelect.ProjectedVarCount; i++)
                {
                    var (start, len) = _subSelect.GetProjectedVariable(i);
                    var varName = _source.Slice(start, len);
                    var idx = _innerBindings.FindBinding(varName);
                    if (idx >= 0)
                    {
                        var value = _innerBindings.GetString(idx);
                        foreach (var c in value)
                            hash = (hash ^ c) * 16777619;
                    }
                }
            }

            return hash;
        }
    }

    public void Dispose()
    {
        _innerScan.Dispose();
        _singleScan.Dispose();
    }
}

/// <summary>
/// Joins subquery results with outer triple patterns using nested loop join.
/// For queries like: SELECT * WHERE { ?s ?p ?o . { SELECT ?s WHERE { ... } } }
/// Subquery is the driving (outer) relation; outer patterns are filtered using bound variables.
/// </summary>
public ref struct SubQueryJoinScan
{
    private readonly QuadStore _store;
    private readonly ReadOnlySpan<char> _source;
    private readonly GraphPattern _pattern;
    private readonly SubSelect _subSelect;

    // Subquery execution state
    private SubQueryScan _subQueryScan;
    private Binding[] _subBindingStorage;
    private char[] _subStringBuffer;
    private BindingTable _subBindings;

    // Outer pattern execution state
    private MultiPatternScan _outerScan;
    private TriplePatternScan _singleOuterScan;
    private GraphPattern _outerPattern;
    private bool _outerInitialized;
    private bool _useMultiPattern;

    // Current binding checkpoint for rollback
    private int _bindingCheckpoint;

    public SubQueryJoinScan(QuadStore store, ReadOnlySpan<char> source,
        GraphPattern pattern, SubSelect subSelect)
    {
        _store = store;
        _source = source;
        _pattern = pattern;
        _subSelect = subSelect;

        // Initialize subquery state
        _subQueryScan = new SubQueryScan(store, source, subSelect);
        _subBindingStorage = new Binding[16];
        _subStringBuffer = new char[512];
        _subBindings = new BindingTable(_subBindingStorage, _subStringBuffer);

        // Build outer pattern from non-subquery patterns
        _outerPattern = new GraphPattern();
        for (int i = 0; i < pattern.PatternCount; i++)
        {
            _outerPattern.AddPattern(pattern.GetPattern(i));
        }
        _useMultiPattern = _outerPattern.PatternCount > 1;

        _outerScan = default;
        _singleOuterScan = default;
        _outerInitialized = false;
        _bindingCheckpoint = 0;
    }

    public bool MoveNext(ref BindingTable bindings)
    {
        // If no outer patterns, just return subquery results directly
        if (_outerPattern.PatternCount == 0)
        {
            if (!_subQueryScan.MoveNext(ref _subBindings))
                return false;
            CopySubQueryBindings(ref bindings);
            return true;
        }

        while (true)
        {
            // Try to get next result from current outer pattern scan
            if (_outerInitialized)
            {
                bool hasOuter;
                if (_useMultiPattern)
                    hasOuter = _outerScan.MoveNext(ref bindings);
                else
                    hasOuter = _singleOuterScan.MoveNext(ref bindings);

                if (hasOuter)
                {
                    // We have a joined result: subquery bindings + outer pattern bindings
                    return true;
                }

                // Outer patterns exhausted for this subquery row
                // Reset for next subquery row
                _outerInitialized = false;
                if (_useMultiPattern)
                    _outerScan.Dispose();
                else
                    _singleOuterScan.Dispose();
                bindings.TruncateTo(_bindingCheckpoint);
            }

            // Get next subquery result
            if (!_subQueryScan.MoveNext(ref _subBindings))
            {
                return false;
            }

            // Save checkpoint and copy subquery bindings to outer bindings
            _bindingCheckpoint = bindings.Count;
            CopySubQueryBindings(ref bindings);

            // Initialize outer pattern scan with current bindings
            InitializeOuterScan(ref bindings);
            _outerInitialized = true;
        }
    }

    private void CopySubQueryBindings(ref BindingTable bindings)
    {
        // Project subquery variables to outer binding table
        for (int i = 0; i < _subBindings.Count; i++)
        {
            var hash = _subBindings.GetVariableHash(i);
            var value = _subBindings.GetString(i);
            bindings.BindWithHash(hash, value);
        }
        _subBindings.Clear();
    }

    private void InitializeOuterScan(ref BindingTable bindings)
    {
        if (_useMultiPattern)
        {
            // MultiPatternScan with initial bindings
            // MultiPatternScan resolves variables from bindings in ResolveAndQuery
            _outerScan = new MultiPatternScan(_store, _source, _outerPattern);
        }
        else if (_outerPattern.PatternCount == 1)
        {
            var tp = _outerPattern.GetPattern(0);
            _singleOuterScan = new TriplePatternScan(_store, _source, tp, bindings);
        }
    }

    public void Dispose()
    {
        _subQueryScan.Dispose();
        if (_outerInitialized)
        {
            if (_useMultiPattern)
                _outerScan.Dispose();
            else
                _singleOuterScan.Dispose();
        }
    }
}

/// <summary>
/// Scans triple patterns across multiple default graphs (FROM clauses), unioning results.
/// This is a streaming operator that avoids materializing all results upfront.
/// </summary>
public ref struct DefaultGraphUnionScan
{
    private readonly QuadStore _store;
    private readonly ReadOnlySpan<char> _source;
    private readonly GraphPattern _pattern;
    private readonly string[] _defaultGraphs;
    private int _currentGraphIndex;
    private TriplePatternScan _singleScan;
    private MultiPatternScan _multiScan;
    private bool _isMultiPattern;
    private bool _initialized;
    private bool _exhausted;

    public DefaultGraphUnionScan(QuadStore store, ReadOnlySpan<char> source, GraphPattern pattern, string[] defaultGraphs)
    {
        _store = store;
        _source = source;
        _pattern = pattern;
        _defaultGraphs = defaultGraphs;
        _currentGraphIndex = 0;
        _singleScan = default;
        _multiScan = default;
        _isMultiPattern = pattern.RequiredPatternCount > 1;
        _initialized = false;
        _exhausted = false;
    }

    public bool MoveNext(ref BindingTable bindings)
    {
        if (_exhausted)
            return false;

        while (true)
        {
            // Try to get next result from current graph's scan
            if (_initialized)
            {
                bool hasNext = _isMultiPattern
                    ? _multiScan.MoveNext(ref bindings)
                    : _singleScan.MoveNext(ref bindings);

                if (hasNext)
                    return true;

                // Current graph exhausted, dispose and move to next
                if (_isMultiPattern)
                    _multiScan.Dispose();
                else
                    _singleScan.Dispose();
                _initialized = false;
            }

            // Move to next graph
            if (_currentGraphIndex >= _defaultGraphs.Length)
            {
                _exhausted = true;
                return false;
            }

            // Clear bindings before switching to new graph
            // Each graph should start fresh (FROM semantics = union of independent queries)
            bindings.Clear();

            // Initialize scan for new graph
            var graphIri = _defaultGraphs[_currentGraphIndex++].AsSpan();
            InitializeScan(graphIri, ref bindings);
            _initialized = true;
        }
    }

    private void InitializeScan(ReadOnlySpan<char> graphIri, ref BindingTable bindings)
    {
        if (_isMultiPattern)
        {
            _multiScan = new MultiPatternScan(_store, _source, _pattern, false, graphIri);
        }
        else
        {
            // Find the first required pattern
            int requiredIdx = 0;
            for (int i = 0; i < _pattern.PatternCount; i++)
            {
                if (!_pattern.IsOptional(i)) { requiredIdx = i; break; }
            }

            var tp = _pattern.GetPattern(requiredIdx);
            _singleScan = new TriplePatternScan(_store, _source, tp, bindings, graphIri);
        }
    }

    public void Dispose()
    {
        if (_initialized)
        {
            if (_isMultiPattern)
                _multiScan.Dispose();
            else
                _singleScan.Dispose();
        }
    }
}

/// <summary>
/// Scans triple patterns across multiple graphs with cross-graph joins.
/// Unlike DefaultGraphUnionScan which runs each complete pattern against each graph independently,
/// this operator allows joins where one pattern matches in graph1 and another in graph2.
///
/// For example, with FROM graph1 FROM graph2 and pattern { ?s name ?name . ?s age ?age }:
/// - First pattern queries both graph1 and graph2
/// - For each match, second pattern also queries both graph1 and graph2
/// This allows joining ?s=Alice from graph1's name with ?s=Alice from graph2's age.
/// </summary>
public ref struct CrossGraphMultiPatternScan
{
    private readonly QuadStore _store;
    private readonly ReadOnlySpan<char> _source;
    private readonly GraphPattern _pattern;
    private readonly string[] _graphs;

    // Current state for each pattern level
    private TemporalResultEnumerator _enum0;
    private TemporalResultEnumerator _enum1;
    private TemporalResultEnumerator _enum2;
    private TemporalResultEnumerator _enum3;

    // Current graph index at each level
    private int _graphIndex0, _graphIndex1, _graphIndex2, _graphIndex3;

    private int _currentLevel;
    private bool _init0, _init1, _init2, _init3;
    private bool _exhausted;

    // Track binding count at entry to each level for rollback
    private int _bindingCount0, _bindingCount1, _bindingCount2, _bindingCount3;

    public CrossGraphMultiPatternScan(QuadStore store, ReadOnlySpan<char> source, GraphPattern pattern, string[] graphs)
    {
        _store = store;
        _source = source;
        _pattern = pattern;
        _graphs = graphs;
        _currentLevel = 0;
        _init0 = _init1 = _init2 = _init3 = false;
        _exhausted = false;
        _enum0 = default;
        _enum1 = default;
        _enum2 = default;
        _enum3 = default;
        _graphIndex0 = _graphIndex1 = _graphIndex2 = _graphIndex3 = 0;
        _bindingCount0 = _bindingCount1 = _bindingCount2 = _bindingCount3 = 0;
    }

    public bool MoveNext(ref BindingTable bindings)
    {
        if (_exhausted)
            return false;

        var patternCount = Math.Min(_pattern.RequiredPatternCount, 4);
        if (patternCount == 0)
            return false;

        while (true)
        {
            bool advanced;
            switch (_currentLevel)
            {
                case 0: advanced = TryAdvanceLevel0(ref bindings); break;
                case 1: advanced = TryAdvanceLevel1(ref bindings); break;
                case 2: advanced = TryAdvanceLevel2(ref bindings); break;
                case 3: advanced = TryAdvanceLevel3(ref bindings); break;
                default: advanced = false; break;
            }

            if (advanced)
            {
                if (_currentLevel == patternCount - 1)
                {
                    // At deepest level - we have a complete result
                    return true;
                }
                else
                {
                    // Go deeper
                    _currentLevel++;
                    SetInitialized(_currentLevel, false);
                    SetGraphIndex(_currentLevel, 0);
                }
            }
            else
            {
                // Current level exhausted across all graphs, backtrack
                if (_currentLevel == 0)
                {
                    _exhausted = true;
                    return false;
                }

                // Go up
                _currentLevel--;
            }
        }
    }

    private void SetInitialized(int level, bool value)
    {
        switch (level)
        {
            case 0: _init0 = value; break;
            case 1: _init1 = value; break;
            case 2: _init2 = value; break;
            case 3: _init3 = value; break;
        }
    }

    private void SetGraphIndex(int level, int value)
    {
        switch (level)
        {
            case 0: _graphIndex0 = value; break;
            case 1: _graphIndex1 = value; break;
            case 2: _graphIndex2 = value; break;
            case 3: _graphIndex3 = value; break;
        }
    }

    private bool TryAdvanceLevel0(scoped ref BindingTable bindings)
    {
        var pattern = GetRequiredPattern(0);

        while (true)
        {
            if (!_init0)
            {
                _bindingCount0 = bindings.Count;
                if (_graphIndex0 >= _graphs.Length)
                    return false; // All graphs exhausted at this level
                InitializeEnumerator(pattern, ref bindings, _graphs[_graphIndex0].AsSpan(), out _enum0);
                _init0 = true;
            }
            else
            {
                // Rolling back bindings from previous attempt
                bindings.TruncateTo(_bindingCount0);
            }

            if (TryAdvanceEnumerator(ref _enum0, pattern, ref bindings))
                return true;

            // Current graph exhausted, try next graph
            _enum0.Dispose();
            _graphIndex0++;
            _init0 = false;

            if (_graphIndex0 >= _graphs.Length)
                return false;
        }
    }

    private bool TryAdvanceLevel1(scoped ref BindingTable bindings)
    {
        var pattern = GetRequiredPattern(1);

        while (true)
        {
            if (!_init1)
            {
                _bindingCount1 = bindings.Count;
                if (_graphIndex1 >= _graphs.Length)
                    return false;
                InitializeEnumerator(pattern, ref bindings, _graphs[_graphIndex1].AsSpan(), out _enum1);
                _init1 = true;
            }
            else
            {
                bindings.TruncateTo(_bindingCount1);
            }

            if (TryAdvanceEnumerator(ref _enum1, pattern, ref bindings))
                return true;

            _enum1.Dispose();
            _graphIndex1++;
            _init1 = false;

            if (_graphIndex1 >= _graphs.Length)
                return false;
        }
    }

    private bool TryAdvanceLevel2(scoped ref BindingTable bindings)
    {
        var pattern = GetRequiredPattern(2);

        while (true)
        {
            if (!_init2)
            {
                _bindingCount2 = bindings.Count;
                if (_graphIndex2 >= _graphs.Length)
                    return false;
                InitializeEnumerator(pattern, ref bindings, _graphs[_graphIndex2].AsSpan(), out _enum2);
                _init2 = true;
            }
            else
            {
                bindings.TruncateTo(_bindingCount2);
            }

            if (TryAdvanceEnumerator(ref _enum2, pattern, ref bindings))
                return true;

            _enum2.Dispose();
            _graphIndex2++;
            _init2 = false;

            if (_graphIndex2 >= _graphs.Length)
                return false;
        }
    }

    private bool TryAdvanceLevel3(scoped ref BindingTable bindings)
    {
        var pattern = GetRequiredPattern(3);

        while (true)
        {
            if (!_init3)
            {
                _bindingCount3 = bindings.Count;
                if (_graphIndex3 >= _graphs.Length)
                    return false;
                InitializeEnumerator(pattern, ref bindings, _graphs[_graphIndex3].AsSpan(), out _enum3);
                _init3 = true;
            }
            else
            {
                bindings.TruncateTo(_bindingCount3);
            }

            if (TryAdvanceEnumerator(ref _enum3, pattern, ref bindings))
                return true;

            _enum3.Dispose();
            _graphIndex3++;
            _init3 = false;

            if (_graphIndex3 >= _graphs.Length)
                return false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private TriplePattern GetRequiredPattern(int index)
    {
        // Find the nth required (non-optional) pattern
        int found = 0;
        for (int i = 0; i < _pattern.PatternCount; i++)
        {
            if (!_pattern.IsOptional(i))
            {
                if (found == index)
                    return _pattern.GetPattern(i);
                found++;
            }
        }
        return default;
    }

    private void InitializeEnumerator(TriplePattern pattern, scoped ref BindingTable bindings,
        ReadOnlySpan<char> graph, out TemporalResultEnumerator enumerator)
    {
        ReadOnlySpan<char> subject, predicate, obj;

        // Resolve subject
        if (!pattern.Subject.IsVariable)
            subject = _source.Slice(pattern.Subject.Start, pattern.Subject.Length);
        else
        {
            var varName = _source.Slice(pattern.Subject.Start, pattern.Subject.Length);
            var idx = bindings.FindBinding(varName);
            subject = idx >= 0 ? bindings.GetString(idx) : ReadOnlySpan<char>.Empty;
        }

        // Resolve predicate
        if (!pattern.Predicate.IsVariable)
            predicate = _source.Slice(pattern.Predicate.Start, pattern.Predicate.Length);
        else
        {
            var varName = _source.Slice(pattern.Predicate.Start, pattern.Predicate.Length);
            var idx = bindings.FindBinding(varName);
            predicate = idx >= 0 ? bindings.GetString(idx) : ReadOnlySpan<char>.Empty;
        }

        // Resolve object
        if (!pattern.Object.IsVariable)
            obj = _source.Slice(pattern.Object.Start, pattern.Object.Length);
        else
        {
            var varName = _source.Slice(pattern.Object.Start, pattern.Object.Length);
            var idx = bindings.FindBinding(varName);
            obj = idx >= 0 ? bindings.GetString(idx) : ReadOnlySpan<char>.Empty;
        }

        enumerator = _store.QueryCurrent(subject, predicate, obj, graph);
    }

    private bool TryAdvanceEnumerator(ref TemporalResultEnumerator enumerator,
        TriplePattern pattern, scoped ref BindingTable bindings)
    {
        while (enumerator.MoveNext())
        {
            var triple = enumerator.Current;

            if (TryBindVariable(pattern.Subject, triple.Subject, ref bindings) &&
                TryBindVariable(pattern.Predicate, triple.Predicate, ref bindings) &&
                TryBindVariable(pattern.Object, triple.Object, ref bindings))
            {
                return true;
            }
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool TryBindVariable(Term term, ReadOnlySpan<char> value, scoped ref BindingTable bindings)
    {
        if (!term.IsVariable)
            return true;

        var varName = _source.Slice(term.Start, term.Length);
        var existingIndex = bindings.FindBinding(varName);

        if (existingIndex >= 0)
        {
            var existingValue = bindings.GetString(existingIndex);
            return value.SequenceEqual(existingValue);
        }

        bindings.Bind(varName, value);
        return true;
    }

    public void Dispose()
    {
        if (_init0) _enum0.Dispose();
        if (_init1) _enum1.Dispose();
        if (_init2) _enum2.Dispose();
        if (_init3) _enum3.Dispose();
    }
}

/// <summary>
/// Executes a SERVICE clause by sending patterns to a remote SPARQL endpoint.
/// Materializes results and iterates through them.
/// </summary>
public ref struct ServiceScan
{
    private readonly ISparqlServiceExecutor _executor;
    private readonly ReadOnlySpan<char> _source;
    private readonly ServiceClause _serviceClause;
    private readonly BindingTable _incomingBindings;
    private readonly int _incomingBindingsCount;
    private List<ServiceResultRow>? _results;
    private int _resultIndex;
    private bool _initialized;
    private bool _exhausted;
    private bool _failed;

    public ServiceScan(ISparqlServiceExecutor executor, ReadOnlySpan<char> source,
        ServiceClause serviceClause, BindingTable incomingBindings)
    {
        _executor = executor;
        _source = source;
        _serviceClause = serviceClause;
        _incomingBindings = incomingBindings;
        _incomingBindingsCount = incomingBindings.Count;
        _results = null;
        _resultIndex = 0;
        _initialized = false;
        _exhausted = false;
        _failed = false;
    }

    public bool MoveNext(ref BindingTable bindings)
    {
        if (_exhausted)
            return false;

        if (!_initialized)
        {
            Initialize();
            _initialized = true;
        }

        if (_failed)
        {
            _exhausted = true;
            return false;
        }

        if (_results == null || _resultIndex >= _results.Count)
        {
            _exhausted = true;
            return false;
        }

        // Clear bindings added by previous iteration, preserve incoming
        bindings.TruncateTo(_incomingBindingsCount);

        // Bind variables from current result row
        var row = _results[_resultIndex++];
        foreach (var varName in row.Variables)
        {
            var binding = row.GetBinding(varName);
            var rdfTerm = binding.ToRdfTerm();

            // Add ? prefix to match SPARQL variable naming
            var fullVarName = $"?{varName}";
            bindings.Bind(fullVarName.AsSpan(), rdfTerm.AsSpan());
        }

        return true;
    }

    private void Initialize()
    {
        // Build endpoint URI (resolve variable if needed)
        string endpointUri;
        if (_serviceClause.Endpoint.IsVariable)
        {
            var varName = _source.Slice(_serviceClause.Endpoint.Start, _serviceClause.Endpoint.Length);
            var idx = _incomingBindings.FindBinding(varName);
            if (idx < 0)
            {
                // Variable not bound - cannot execute SERVICE
                _failed = true;
                return;
            }
            endpointUri = _incomingBindings.GetString(idx).ToString();
            // Strip angle brackets if present
            if (endpointUri.StartsWith('<') && endpointUri.EndsWith('>'))
                endpointUri = endpointUri[1..^1];
        }
        else
        {
            var iri = _source.Slice(_serviceClause.Endpoint.Start, _serviceClause.Endpoint.Length);
            // Strip angle brackets
            if (iri.Length > 2 && iri[0] == '<' && iri[^1] == '>')
                endpointUri = iri[1..^1].ToString();
            else
                endpointUri = iri.ToString();
        }

        // Build SPARQL query from patterns
        var query = BuildSparqlQuery();

        try
        {
            // Execute query (blocking on async)
            _results = _executor.ExecuteSelectAsync(endpointUri, query)
                .AsTask().GetAwaiter().GetResult();
        }
        catch (SparqlServiceException)
        {
            if (_serviceClause.Silent)
            {
                // SILENT modifier - return empty results on error
                _results = new List<ServiceResultRow>();
            }
            else
            {
                throw;
            }
        }
        catch (Exception ex)
        {
            if (_serviceClause.Silent)
            {
                _results = new List<ServiceResultRow>();
            }
            else
            {
                throw new SparqlServiceException($"SERVICE execution failed: {ex.Message}", ex)
                {
                    EndpointUri = endpointUri,
                    Query = query
                };
            }
        }
    }

    private string BuildSparqlQuery()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("SELECT * WHERE { ");

        for (int i = 0; i < _serviceClause.PatternCount; i++)
        {
            var pattern = _serviceClause.GetPattern(i);

            // Serialize subject
            AppendTerm(sb, pattern.Subject);
            sb.Append(' ');

            // Serialize predicate
            AppendTerm(sb, pattern.Predicate);
            sb.Append(' ');

            // Serialize object
            AppendTerm(sb, pattern.Object);
            sb.Append(" . ");
        }

        sb.Append('}');
        return sb.ToString();
    }

    private void AppendTerm(System.Text.StringBuilder sb, Term term)
    {
        var value = _source.Slice(term.Start, term.Length);

        if (term.IsVariable)
        {
            // Check if variable is bound in incoming bindings - substitute if so
            var idx = _incomingBindings.FindBinding(value);
            if (idx >= 0)
            {
                var boundValue = _incomingBindings.GetString(idx);
                sb.Append(boundValue);
            }
            else
            {
                sb.Append(value);
            }
        }
        else
        {
            sb.Append(value);
        }
    }

    public void Dispose()
    {
        // Nothing to dispose - results are managed by GC
    }
}
