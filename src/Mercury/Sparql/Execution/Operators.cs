using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Threading;
using SkyOmega.Mercury.Runtime.Buffers;
using SkyOmega.Mercury.Sparql;
using SkyOmega.Mercury.Sparql.Patterns;
using SkyOmega.Mercury.Storage;

namespace SkyOmega.Mercury.Sparql.Execution;

/// <summary>
/// Thread-static cancellation token for query execution.
/// Allows operators to check for cancellation without passing token through all constructors.
/// </summary>
internal static class QueryCancellation
{
    [ThreadStatic]
    private static CancellationToken _token;

    /// <summary>
    /// Set the cancellation token for the current thread's query execution.
    /// </summary>
    public static void SetToken(CancellationToken token) => _token = token;

    /// <summary>
    /// Clear the cancellation token after query execution completes.
    /// </summary>
    public static void ClearToken() => _token = default;

    /// <summary>
    /// Throw OperationCanceledException if cancellation has been requested.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void ThrowIfCancellationRequested() => _token.ThrowIfCancellationRequested();
}

/// <summary>
/// Helper for resolving synthetic terms generated by SPARQL-star expansion.
/// Synthetic terms use negative Start offsets to indicate they're not in the source.
/// </summary>
internal static class SyntheticTermHelper
{
    // RDF namespace IRIs for reification patterns
    public const string RdfType = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#type>";
    public const string RdfStatement = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#Statement>";
    public const string RdfSubject = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#subject>";
    public const string RdfPredicate = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate>";
    public const string RdfObject = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#object>";

    // Pre-allocated synthetic variable names for reifier bindings (up to 32 per query)
    private static readonly string[] SyntheticVarNames = new string[32];

    // Pre-allocated synthetic variable names for sequence path intermediates (up to 32 per query)
    private static readonly string[] SyntheticSeqVarNames = new string[32];

    // Pre-allocated synthetic variable names for blank node property lists (up to 32 per query)
    private static readonly string[] SyntheticBnVarNames = new string[32];

    static SyntheticTermHelper()
    {
        for (int i = 0; i < SyntheticVarNames.Length; i++)
            SyntheticVarNames[i] = $"?_qt{i}";
        for (int i = 0; i < SyntheticSeqVarNames.Length; i++)
            SyntheticSeqVarNames[i] = $"?_seq{i}";
        for (int i = 0; i < SyntheticBnVarNames.Length; i++)
            SyntheticBnVarNames[i] = $"?_bn{i}";
    }

    /// <summary>
    /// Check if a term has a synthetic (negative) offset.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsSynthetic(int start) => start < 0;

    /// <summary>
    /// Get the synthetic IRI for a negative offset.
    /// Offsets: -1 = rdf:type, -2 = rdf:Statement, -3 = rdf:subject, -4 = rdf:predicate, -5 = rdf:object
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan<char> GetSyntheticIri(int start)
    {
        return start switch
        {
            -1 => RdfType.AsSpan(),
            -2 => RdfStatement.AsSpan(),
            -3 => RdfSubject.AsSpan(),
            -4 => RdfPredicate.AsSpan(),
            -5 => RdfObject.AsSpan(),
            _ => ReadOnlySpan<char>.Empty
        };
    }

    /// <summary>
    /// Get the synthetic variable name for a negative offset.
    /// Reifier variables: -100 to -131 = ?_qt0 to ?_qt31
    /// Sequence variables: -200 to -231 = ?_seq0 to ?_seq31
    /// Blank node property list variables: -300 to -331 = ?_bn0 to ?_bn31
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan<char> GetSyntheticVarName(int start)
    {
        // Check for blank node property list variables first (-300 to -331)
        if (start <= -300 && start > -332)
        {
            var index = -start - 300;
            if (index < SyntheticBnVarNames.Length)
                return SyntheticBnVarNames[index].AsSpan();
        }

        // Check for sequence variables (-200 to -231)
        if (start <= -200 && start > -232)
        {
            var index = -start - 200;
            if (index < SyntheticSeqVarNames.Length)
                return SyntheticSeqVarNames[index].AsSpan();
        }

        // Reifier variables (-100 to -131)
        var qtIndex = -start - 100;
        if (qtIndex >= 0 && qtIndex < SyntheticVarNames.Length)
            return SyntheticVarNames[qtIndex].AsSpan();
        return ReadOnlySpan<char>.Empty;
    }

    /// <summary>
    /// Get the synthetic offset for a sequence intermediate variable.
    /// Index 0 = offset -200, index 1 = offset -201, etc.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int GetSeqVarOffset(int index) => -(200 + index);

    /// <summary>
    /// Get the synthetic offset for a blank node property list variable.
    /// Index 0 = offset -300, index 1 = offset -301, etc.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int GetBnVarOffset(int index) => -(300 + index);
}

/// <summary>
/// Scans a single triple pattern against the QuadStore.
/// Conforms to <see cref="IScan"/> contract (duck typing).
/// </summary>
internal ref struct TriplePatternScan
{
    private readonly QuadStore _store;
    private readonly ReadOnlySpan<char> _source;
    private readonly TriplePattern _pattern;
    private TemporalResultEnumerator _enumerator;
    private bool _initialized;
    private readonly BindingTable _initialBindings;
    private readonly int _initialBindingsCount;
    private readonly ReadOnlySpan<char> _graph;

    // Temporal query parameters
    private readonly TemporalQueryMode _temporalMode;
    private readonly DateTimeOffset _asOfTime;
    private readonly DateTimeOffset _rangeStart;
    private readonly DateTimeOffset _rangeEnd;

    // For property path traversal
    private readonly bool _isInverse;
    private readonly bool _isZeroOrMore;
    private readonly bool _isOneOrMore;
    private readonly bool _isZeroOrOne;
    private readonly bool _isAlternative;
    private readonly bool _isNegatedSet;
    private readonly bool _isGroupedZeroOrMore;
    private readonly bool _isGroupedOneOrMore;
    private readonly bool _isGroupedZeroOrOne;
    private readonly bool _isInverseGroup;

    // State for transitive path traversal
    private HashSet<string>? _visited;
    private Queue<string>? _frontier;
    private string? _currentNode;
    private string? _startNode;  // Original start node for binding
    private bool _emittedReflexive;

    // State for multi-start transitive path (when both subject and object are unbound)
    private Queue<string>? _startingNodes;  // All potential starting nodes to process
    private HashSet<string>? _allNodes;     // All nodes seen (for reflexive emissions)
    private int _reflexiveIndex;            // Index for iterating through reflexive emissions
    private bool _inReflexivePhase;         // True when emitting reflexive bindings
    private List<string>? _reflexiveList;   // List of all nodes for reflexive iteration

    // State for alternative path traversal (p1|p2|p3|...)
    // Supports n-ary alternatives by tracking remaining span to process
    private int _alternativePhase; // Current phase (0 = first segment, 1+ = subsequent segments)
    private int _alternativeRemainingStart;  // Start of remaining right span
    private int _alternativeRemainingLength; // Length of remaining right span

    // State for sequence within alternative (e.g., p2/:p3 in p1|p2/:p3|p4)
    private bool _inSequencePhase;           // Currently collecting intermediates from first step
    private bool _inSequenceSecondStep;      // Currently executing second step (intermediates → final)
    private bool _sequenceFirstStepIsInverse; // True if first step of sequence is inverse (^pred)
    private Queue<string>? _sequenceIntermediates; // Intermediate nodes from first step of sequence
    // Note: Second predicate stored in _expandedPredicate as string

    // State for negated property set with inverse predicates
    // 0 = direct scan (check direct predicates), 1 = inverse scan (check inverse predicates, swap bindings)
    private int _negatedSetPhase;
    private bool _negatedSetHasInverse;  // True if set contains inverse predicates
    private bool _negatedSetHasDirect;   // True if set contains direct predicates

    // State for grouped sequence path traversal ((p1/p2/p3)*)
    private Queue<string>? _groupedResults; // Results from executing grouped sequence

    // Prefix mappings for expansion
    private readonly PrefixMapping[]? _prefixes;
    // Expanded IRIs stored as strings to ensure span lifetime safety
    // Each position needs its own storage since Initialize() resolves all three
    // before calling ExecuteTemporalQuery
    private string? _expandedSubject;
    private string? _expandedPredicate;
    private string? _expandedObject;

    public TriplePatternScan(QuadStore store, ReadOnlySpan<char> source,
        TriplePattern pattern, BindingTable initialBindings, ReadOnlySpan<char> graph = default)
        : this(store, source, pattern, initialBindings, graph,
               TemporalQueryMode.Current, default, default, default, null)
    {
    }

    public TriplePatternScan(QuadStore store, ReadOnlySpan<char> source,
        TriplePattern pattern, BindingTable initialBindings, ReadOnlySpan<char> graph,
        TemporalQueryMode temporalMode, DateTimeOffset asOfTime,
        DateTimeOffset rangeStart, DateTimeOffset rangeEnd,
        PrefixMapping[]? prefixes = null)
    {
        _store = store;
        _source = source;
        _pattern = pattern;
        _initialBindings = initialBindings;
        _initialBindingsCount = initialBindings.Count;
        _graph = graph;
        _initialized = false;
        _enumerator = default;

        // Temporal parameters
        _temporalMode = temporalMode;
        _asOfTime = asOfTime;
        _rangeStart = rangeStart;
        _rangeEnd = rangeEnd;

        // Check property path type
        _isInverse = pattern.Path.Type == PathType.Inverse;
        _isZeroOrMore = pattern.Path.Type == PathType.ZeroOrMore;
        _isOneOrMore = pattern.Path.Type == PathType.OneOrMore;
        _isZeroOrOne = pattern.Path.Type == PathType.ZeroOrOne;
        _isAlternative = pattern.Path.Type == PathType.Alternative;
        _isNegatedSet = pattern.Path.Type == PathType.NegatedSet;
        _isGroupedZeroOrMore = pattern.Path.Type == PathType.GroupedZeroOrMore;
        _isGroupedOneOrMore = pattern.Path.Type == PathType.GroupedOneOrMore;
        _isGroupedZeroOrOne = pattern.Path.Type == PathType.GroupedZeroOrOne;
        _isInverseGroup = pattern.Path.Type == PathType.InverseGroup;

        _visited = null;
        _frontier = null;
        _currentNode = null;
        _startNode = null;
        _emittedReflexive = false;
        _startingNodes = null;
        _allNodes = null;
        _reflexiveIndex = 0;
        _inReflexivePhase = false;
        _reflexiveList = null;
        _alternativePhase = 0;
        _alternativeRemainingStart = 0;
        _alternativeRemainingLength = 0;
        _inSequencePhase = false;
        _sequenceFirstStepIsInverse = false;
        _sequenceIntermediates = null;
        _negatedSetPhase = 0;
        _negatedSetHasInverse = false;
        _negatedSetHasDirect = false;
        _groupedResults = null;

        _prefixes = prefixes;
        _expandedSubject = null;
        _expandedPredicate = null;
        _expandedObject = null;
    }

    public bool MoveNext(ref BindingTable bindings)
    {
        if (!_initialized)
        {
            Initialize();
            _initialized = true;
        }

        // Handle transitive paths with BFS
        if (_isZeroOrMore || _isOneOrMore || _isGroupedZeroOrMore || _isGroupedOneOrMore)
        {
            return MoveNextTransitive(ref bindings);
        }

        // Handle inverse grouped path ^(p1/p2) - iterate over pre-computed results
        if (_isInverseGroup && _groupedResults != null)
        {
            while (_groupedResults.Count > 0)
            {
                var result = _groupedResults.Dequeue();
                bindings.TruncateTo(_initialBindingsCount);

                // For ^(path), the subject in the pattern is where we started,
                // and the result is what we found - bind appropriately
                var subject = ResolveTermForQuery(_pattern.Subject);
                if (!subject.IsEmpty)
                {
                    // Subject was bound (e.g., in:c ^(p1/p2) ?x) - bind result to object
                    if (TryBindVariable(_pattern.Object, result.AsSpan(), ref bindings))
                        return true;
                }
                else
                {
                    // Object was bound (e.g., ?x ^(p1/p2) in:c) - bind result to subject
                    if (TryBindVariable(_pattern.Subject, result.AsSpan(), ref bindings))
                        return true;
                }
            }
            return false;
        }

        // Handle grouped zero-or-one path (p1/p2)? - iterate over sequence results, then emit reflexive
        if (_isGroupedZeroOrOne)
        {
            // First, iterate over the sequence results (one occurrence of the path)
            while (_groupedResults != null && _groupedResults.Count > 0)
            {
                var result = _groupedResults.Dequeue();
                bindings.TruncateTo(_initialBindingsCount);

                // Bind the result to the object variable
                if (TryBindVariable(_pattern.Subject, _startNode!.AsSpan(), ref bindings) &&
                    TryBindVariable(_pattern.Object, result.AsSpan(), ref bindings))
                {
                    return true;
                }
            }

            // Then emit the reflexive case (zero occurrences: subject = object)
            if (!_emittedReflexive && !string.IsNullOrEmpty(_startNode))
            {
                _emittedReflexive = true;
                bindings.TruncateTo(_initialBindingsCount);

                if (TryBindVariable(_pattern.Subject, _startNode.AsSpan(), ref bindings) &&
                    TryBindVariable(_pattern.Object, _startNode.AsSpan(), ref bindings))
                {
                    return true;
                }
            }

            return false;
        }

        while (true)
        {
            QueryCancellation.ThrowIfCancellationRequested();

            while (_enumerator.MoveNext())
            {
                var triple = _enumerator.Current;

                // Preserve initial bindings (from subquery join), only clear added bindings
                bindings.TruncateTo(_initialBindingsCount);

                if (_isInverse)
                {
                    // For inverse, swap subject and object bindings
                    if (!TryBindVariable(_pattern.Subject, triple.Object, ref bindings))
                        continue;
                    if (!TryBindVariable(_pattern.Object, triple.Subject, ref bindings))
                        continue;
                }
                else if (_isNegatedSet)
                {
                    // Negated property sets support both direct and inverse predicates.
                    // Direct predicates (e.g., !ex:p) filter ?s ?p ?o with normal binding
                    // Inverse predicates (e.g., !^ex:p) filter ?s ?p ?o with inverted binding (?s←o, ?o←s)
                    if (_negatedSetPhase == 0)
                    {
                        // Direct phase: exclude triples where predicate matches direct negated set
                        if (_negatedSetHasDirect && IsPredicateInDirectNegatedSet(triple.Predicate))
                            continue;

                        // Skip direct phase entirely if set has ONLY inverse predicates
                        if (!_negatedSetHasDirect)
                            continue;

                        // Bind normally: subject → subject, object → object
                        if (!TryBindVariable(_pattern.Subject, triple.Subject, ref bindings))
                            continue;
                        if (!TryBindVariable(_pattern.Object, triple.Object, ref bindings))
                            continue;
                    }
                    else
                    {
                        // Inverse phase: exclude triples where predicate matches inverse negated set
                        if (IsPredicateInInverseNegatedSet(triple.Predicate))
                            continue;

                        // Bind inverted: subject → object, object → subject
                        if (!TryBindVariable(_pattern.Subject, triple.Object, ref bindings))
                            continue;
                        if (!TryBindVariable(_pattern.Object, triple.Subject, ref bindings))
                            continue;
                    }
                }
                else if (_isAlternative)
                {
                    // For alternative path, handling depends on whether we're in a sequence phase
                    if (_inSequencePhase && _sequenceIntermediates != null)
                    {
                        // First step of sequence - collect intermediate, don't return yet
                        // For inverse first step (^pred), we found ?x pred :start, so collect Subject
                        // For direct first step, we found :start pred ?x, so collect Object
                        var intermediate = _sequenceFirstStepIsInverse ? triple.Subject : triple.Object;
                        _sequenceIntermediates.Enqueue(intermediate.ToString());
                        continue;
                    }

                    // For second step of sequence, only bind object (subject is intermediate, not pattern subject)
                    if (!_inSequenceSecondStep)
                    {
                        if (!TryBindVariable(_pattern.Subject, triple.Subject, ref bindings))
                        {
                            continue;
                        }
                    }
                    if (!TryBindVariable(_pattern.Object, triple.Object, ref bindings))
                    {
                        continue;
                    }
                }
                else
                {
                    // Normal binding
                    if (!TryBindVariable(_pattern.Subject, triple.Subject, ref bindings))
                        continue;
                    if (!TryBindVariable(_pattern.Predicate, triple.Predicate, ref bindings))
                        continue;
                    if (!TryBindVariable(_pattern.Object, triple.Object, ref bindings))
                        continue;
                }

                return true;
            }

            // Current predicate/phase exhausted - check for alternative path transitions
            if (_isAlternative)
            {
                // If we were collecting sequence intermediates, now query the second step
                if (_inSequencePhase && _sequenceIntermediates != null && _sequenceIntermediates.Count > 0)
                {
                    _enumerator.Dispose();
                    _inSequencePhase = false;
                    _inSequenceSecondStep = true;  // Mark that we're in second step (skip subject binding)

                    // Get the second predicate of the sequence (stored in _expandedPredicate)
                    var secondPred = _expandedPredicate != null ? _expandedPredicate.AsSpan() : ReadOnlySpan<char>.Empty;
                    secondPred = ExpandPathPredicateSpan(secondPred);
                    var obj = ResolveTermForQuery(_pattern.Object);

                    // Query from each intermediate to the final object
                    // We'll process intermediates one at a time
                    var intermediate = _sequenceIntermediates.Dequeue();
                    _enumerator = ExecuteTemporalQuery(intermediate.AsSpan(), secondPred, obj);
                    continue;
                }

                // If we have more intermediates to process (from sequence), do them
                if (!_inSequencePhase && _sequenceIntermediates != null && _sequenceIntermediates.Count > 0)
                {
                    _enumerator.Dispose();
                    var secondPred = _expandedPredicate != null ? _expandedPredicate.AsSpan() : ReadOnlySpan<char>.Empty;
                    secondPred = ExpandPathPredicateSpan(secondPred);
                    var obj = ResolveTermForQuery(_pattern.Object);
                    var intermediate = _sequenceIntermediates.Dequeue();
                    _enumerator = ExecuteTemporalQuery(intermediate.AsSpan(), secondPred, obj);
                    continue;
                }

                // Current segment exhausted - move to next segment in remaining span
                if (_alternativeRemainingLength > 0)
                {
                    _alternativePhase++;
                    _enumerator.Dispose();

                    // Find next segment (up to next | or end)
                    var remainingSpan = _source.Slice(_alternativeRemainingStart, _alternativeRemainingLength);
                    var pipeIdx = FindTopLevelOperator(remainingSpan, '|');

                    ReadOnlySpan<char> currentSegment;
                    if (pipeIdx >= 0)
                    {
                        currentSegment = remainingSpan.Slice(0, pipeIdx);
                        _alternativeRemainingStart += pipeIdx + 1;
                        _alternativeRemainingLength -= pipeIdx + 1;
                    }
                    else
                    {
                        currentSegment = remainingSpan;
                        _alternativeRemainingLength = 0; // No more segments
                    }

                    // Check if this segment is a sequence
                    var slashIdx = FindTopLevelOperator(currentSegment, '/');
                    var subject = ResolveTermForQuery(_pattern.Subject);
                    var obj = ResolveTermForQuery(_pattern.Object);

                    if (slashIdx >= 0)
                    {
                        // Sequence segment - execute first step, collect intermediates
                        var firstPred = currentSegment.Slice(0, slashIdx);
                        var secondPred = currentSegment.Slice(slashIdx + 1);

                        // Check if first predicate is inverse (^pred)
                        bool firstIsInverse = firstPred.Length > 0 && firstPred[0] == '^';
                        if (firstIsInverse)
                            firstPred = firstPred.Slice(1); // Strip ^

                        // IMPORTANT: Expand second predicate FIRST and save as string,
                        // because ExpandPathPredicateSpan overwrites _expandedPredicate
                        var expandedSecondPred = ExpandPathPredicateSpan(secondPred).ToString();

                        // Now expand first predicate (this will overwrite _expandedPredicate internally)
                        var predicate = ExpandPathPredicateSpan(firstPred);

                        // NOW store the second predicate (after first pred expansion is done)
                        _expandedPredicate = expandedSecondPred;

                        _inSequencePhase = true;
                        _inSequenceSecondStep = false;  // Reset - starting new sequence first step
                        _sequenceFirstStepIsInverse = firstIsInverse;
                        _sequenceIntermediates = new Queue<string>();

                        // For inverse first step ^pred from :a, query (*, pred, :a) to find triples where object=:a
                        // For direct first step from :a, query (:a, pred, *) to find triples where subject=:a
                        if (firstIsInverse)
                            _enumerator = ExecuteTemporalQuery(ReadOnlySpan<char>.Empty, predicate, subject);
                        else
                            _enumerator = ExecuteTemporalQuery(subject, predicate, ReadOnlySpan<char>.Empty);
                    }
                    else
                    {
                        // Simple predicate - reset sequence state
                        _inSequenceSecondStep = false;

                        // Check if predicate is inverse (^pred)
                        bool isInverse = currentSegment.Length > 0 && currentSegment[0] == '^';
                        var predSpan = isInverse ? currentSegment.Slice(1) : currentSegment;
                        var predicate = ExpandPathPredicateSpan(predSpan);

                        // For inverse, swap subject and object in query
                        if (isInverse)
                            _enumerator = ExecuteTemporalQuery(obj, predicate, subject);
                        else
                            _enumerator = ExecuteTemporalQuery(subject, predicate, obj);
                    }
                    continue;
                }
            }

            // Current scan exhausted - check for negated set inverse phase
            if (_isNegatedSet && _negatedSetPhase == 0 && _negatedSetHasInverse)
            {
                // Switch to inverse phase
                _negatedSetPhase = 1;
                _enumerator.Dispose();

                // Re-initialize with same query (scan all triples again for inverse bindings)
                var subject = ResolveTermForQuery(_pattern.Subject);
                var obj = ResolveTermForQuery(_pattern.Object);

                _enumerator = ExecuteTemporalQuery(subject, ReadOnlySpan<char>.Empty, obj);
                continue; // Try again with inverse bindings
            }

            break; // No more alternatives or phases
        }

        // For zero-or-one, also emit reflexive case if subject == object and not yet emitted
        if (_isZeroOrOne && !_emittedReflexive)
        {
            _emittedReflexive = true;
            bindings.TruncateTo(_initialBindingsCount);

            // Get subject and object values
            var subjectSpan = ResolveTermForQuery(_pattern.Subject);
            var objectSpan = ResolveTermForQuery(_pattern.Object);

            // For reflexive: if subject is bound, use it; if subject is unbound but object is bound, use object
            // This handles queries like "?s :p? :o" where the reflexive case should bind ?s = :o
            ReadOnlySpan<char> reflexiveValue;
            if (!subjectSpan.IsEmpty)
            {
                reflexiveValue = subjectSpan;
            }
            else if (!objectSpan.IsEmpty)
            {
                reflexiveValue = objectSpan;
            }
            else
            {
                reflexiveValue = ReadOnlySpan<char>.Empty;
            }

            if (!reflexiveValue.IsEmpty)
            {
                // Bind both subject and object to the same value (reflexive)
                if (TryBindVariable(_pattern.Subject, reflexiveValue, ref bindings) &&
                    TryBindVariable(_pattern.Object, reflexiveValue, ref bindings))
                {
                    return true;
                }
            }
        }

        return false;
    }

    private bool MoveNextTransitive(ref BindingTable bindings)
    {
        var isGrouped = _isGroupedZeroOrMore || _isGroupedOneOrMore;

        // For multi-start mode (both subject and object unbound), emit all reflexive bindings first
        if (_inReflexivePhase && _reflexiveList != null)
        {
            while (_reflexiveIndex < _reflexiveList.Count)
            {
                var node = _reflexiveList[_reflexiveIndex++];
                bindings.TruncateTo(_initialBindingsCount);

                // Bind subject and object to same node (reflexive)
                if (TryBindVariable(_pattern.Subject, node.AsSpan(), ref bindings) &&
                    TryBindVariable(_pattern.Object, node.AsSpan(), ref bindings))
                {
                    return true;
                }
            }
            _inReflexivePhase = false;
        }

        // For single-start zero-or-more, emit reflexive for just the start node
        if ((_isZeroOrMore || _isGroupedZeroOrMore) && !_emittedReflexive && _reflexiveList == null)
        {
            _emittedReflexive = true;
            bindings.TruncateTo(_initialBindingsCount);

            // Bind subject to start node, object to start node (reflexive)
            if (!string.IsNullOrEmpty(_startNode) &&
                TryBindVariable(_pattern.Subject, _startNode.AsSpan(), ref bindings) &&
                TryBindVariable(_pattern.Object, _startNode.AsSpan(), ref bindings))
            {
                return true;
            }
        }

        // BFS for transitive closure
        while (true)
        {
            QueryCancellation.ThrowIfCancellationRequested();

            if (isGrouped)
            {
                // For grouped paths, iterate over pre-computed sequence results
                while (_groupedResults != null && _groupedResults.Count > 0)
                {
                    var targetNode = _groupedResults.Dequeue();

                    if (!_visited!.Contains(targetNode))
                    {
                        _visited.Add(targetNode);
                        _frontier!.Enqueue(targetNode);

                        bindings.TruncateTo(_initialBindingsCount);
                        // Bind subject to original start node, object to the discovered target
                        if (TryBindVariable(_pattern.Subject, _startNode.AsSpan(), ref bindings) &&
                            TryBindVariable(_pattern.Object, targetNode.AsSpan(), ref bindings))
                        {
                            return true;
                        }
                    }
                }
            }
            else
            {
                // For simple paths, use the enumerator
                while (_enumerator.MoveNext())
                {
                    var triple = _enumerator.Current;
                    var targetNode = triple.Object.ToString();

                    if (!_visited!.Contains(targetNode))
                    {
                        _visited.Add(targetNode);
                        _frontier!.Enqueue(targetNode);

                        bindings.TruncateTo(_initialBindingsCount);
                        // Bind subject to original start node, object to the discovered target
                        if (TryBindVariable(_pattern.Subject, _startNode.AsSpan(), ref bindings) &&
                            TryBindVariable(_pattern.Object, triple.Object, ref bindings))
                        {
                            return true;
                        }
                    }
                }
                _enumerator.Dispose();
            }

            // Move to next frontier node
            if (_frontier!.Count > 0)
            {
                _currentNode = _frontier.Dequeue();

                if (isGrouped)
                {
                    _groupedResults = new Queue<string>(ExecuteGroupedSequence(_currentNode));
                }
                else
                {
                    var predicate = _pattern.HasPropertyPath
                        ? ResolveTermForQuery(_pattern.Path.Iri)
                        : ResolveTermForQuery(_pattern.Predicate);

                    _enumerator = ExecuteTemporalQuery(
                        _currentNode.AsSpan(),
                        predicate,
                        ReadOnlySpan<char>.Empty);
                }
                continue;
            }

            // Frontier exhausted - check for more starting nodes (multi-start mode)
            if (_startingNodes != null && _startingNodes.Count > 0)
            {
                _startNode = _startingNodes.Dequeue();
                _visited!.Clear();
                _visited.Add(_startNode);
                _frontier!.Clear();
                _currentNode = _startNode;

                if (isGrouped)
                {
                    _groupedResults = new Queue<string>(ExecuteGroupedSequence(_startNode));
                }
                else
                {
                    var predicate = _pattern.HasPropertyPath
                        ? ResolveTermForQuery(_pattern.Path.Iri)
                        : ResolveTermForQuery(_pattern.Predicate);

                    _enumerator = ExecuteTemporalQuery(
                        _startNode.AsSpan(),
                        predicate,
                        ReadOnlySpan<char>.Empty);
                }
                continue;
            }

            return false;
        }
    }

    private void Initialize()
    {
        if (_isZeroOrMore || _isOneOrMore || _isGroupedZeroOrMore || _isGroupedOneOrMore)
        {
            InitializeTransitive();
            return;
        }

        // Resolve terms to spans for querying
        // ResolveTermWithStorage stores expanded IRIs as strings, returning spans over them
        // This ensures spans remain valid until ExecuteTemporalQuery completes
        var subject = ResolveTermWithStorage(_pattern.Subject, TermPosition.Subject);
        var obj = ResolveTermWithStorage(_pattern.Object, TermPosition.Object);

        ReadOnlySpan<char> predicate;
        if (_isInverse)
        {
            // For inverse path, query with swapped subject/object
            predicate = ResolveTermWithStorage(_pattern.Path.Iri, TermPosition.Predicate);
            _enumerator = ExecuteTemporalQuery(obj, predicate, subject);
        }
        else if (_isAlternative)
        {
            // For alternative path (p1|p2|...), start with first segment from Left offsets
            // Store remaining right span for subsequent phases (supports n-ary alternatives)
            _alternativeRemainingStart = _pattern.Path.RightStart;
            _alternativeRemainingLength = _pattern.Path.RightLength;

            // Check if the left segment is a sequence (contains / at top level)
            var leftSpan = _source.Slice(_pattern.Path.LeftStart, _pattern.Path.LeftLength);
            var slashIdx = FindTopLevelOperator(leftSpan, '/');

            if (slashIdx >= 0)
            {
                // Left segment is a sequence - execute first step, collect intermediates
                var firstPred = leftSpan.Slice(0, slashIdx);
                var secondPred = leftSpan.Slice(slashIdx + 1);

                // Store second predicate for later use in MoveNext
                _expandedPredicate = secondPred.ToString();
                _sequenceIntermediates = new Queue<string>();

                // Check if first step is a grouped alternative like (:p0|^:p1)
                if (firstPred.Length > 2 && firstPred[0] == '(' && firstPred[^1] == ')')
                {
                    // Grouped alternative - execute each branch and collect all intermediates
                    var groupInner = firstPred.Slice(1, firstPred.Length - 2);
                    ExecuteGroupedAlternativeFirstStep(groupInner, subject);
                    // We've collected all intermediates, skip straight to second step
                    _inSequencePhase = false;
                    _inSequenceSecondStep = true;
                    // Start processing intermediates
                    if (_sequenceIntermediates.Count > 0)
                    {
                        var expandedSecondPred = ExpandPathPredicateSpan(secondPred);
                        var intermediate = _sequenceIntermediates.Dequeue();
                        _enumerator = ExecuteTemporalQuery(intermediate.AsSpan(), expandedSecondPred, obj);
                    }
                    else
                    {
                        // No intermediates - set up empty enumerator
                        _enumerator = ExecuteTemporalQuery("__no_match__".AsSpan(), "__no_match__".AsSpan(), "__no_match__".AsSpan());
                    }
                }
                else
                {
                    // Simple predicate - check if first predicate is inverse (^pred)
                    bool firstIsInverse = firstPred.Length > 0 && firstPred[0] == '^';
                    if (firstIsInverse)
                        firstPred = firstPred.Slice(1); // Strip ^

                    predicate = ExpandPathPredicateSpan(firstPred);
                    _inSequencePhase = true;
                    _sequenceFirstStepIsInverse = firstIsInverse;

                    // Query first step - results will be collected as intermediates
                    // For inverse first step ^pred from :a, query (*, pred, :a) to find triples where object=:a
                    // For direct first step from :a, query (:a, pred, *) to find triples where subject=:a
                    if (firstIsInverse)
                        _enumerator = ExecuteTemporalQuery(ReadOnlySpan<char>.Empty, predicate, subject);
                    else
                        _enumerator = ExecuteTemporalQuery(subject, predicate, ReadOnlySpan<char>.Empty);
                }
            }
            else
            {
                // Simple predicate - check for inverse
                bool isInverse = leftSpan.Length > 0 && leftSpan[0] == '^';
                var predSpan = isInverse ? leftSpan.Slice(1) : leftSpan;
                predicate = ExpandPathPredicateSpan(predSpan);

                // For inverse, swap subject and object in query
                if (isInverse)
                    _enumerator = ExecuteTemporalQuery(obj, predicate, subject);
                else
                    _enumerator = ExecuteTemporalQuery(subject, predicate, obj);
            }
        }
        else if (_isNegatedSet)
        {
            // For negated property set !(p1|^p2|...), query all predicates (wildcard)
            // and filter in MoveNext. Analyze set for direct vs inverse predicates.
            _negatedSetHasDirect = NegatedSetHasDirectPredicates();
            _negatedSetHasInverse = NegatedSetHasInversePredicates();
            _negatedSetPhase = 0;  // Start with direct scan phase
            _enumerator = ExecuteTemporalQuery(subject, ReadOnlySpan<char>.Empty, obj);
        }
        else if (_isGroupedZeroOrOne)
        {
            // For grouped zero-or-one path (p1/p2)?, execute the sequence once
            // and store results in _groupedResults. Also need to emit reflexive case (subject=object).
            // Property paths use set semantics, so deduplicate the results.
            var startNodeSpan = subject.IsEmpty ? obj : subject;
            var expandedStart = ExpandPrefixedName(startNodeSpan);
            _startNode = expandedStart.ToString();
            var sequenceResults = ExecuteGroupedSequence(_startNode);
            // Deduplicate and exclude reflexive (we'll emit it separately)
            // Note: Copy _startNode to local to avoid capturing 'this' in lambda
            var startNode = _startNode;
            _groupedResults = new Queue<string>(sequenceResults.Where(r => r != startNode).Distinct());
        }
        else if (_isInverseGroup)
        {
            // For inverse grouped path ^(p1/p2), execute the sequence in reverse
            // The subject is the start node, results go to _groupedResults for iteration in MoveNext
            // Expand prefixed names to full IRIs for store queries
            var startNodeSpan = subject.IsEmpty ? obj : subject;
            var expandedStart = ExpandPrefixedName(startNodeSpan);
            var startNode = expandedStart.ToString();
            _groupedResults = new Queue<string>(ExecuteInverseGroupedSequence(startNode));
        }
        else
        {
            predicate = ResolveTermWithStorage(_pattern.Predicate, TermPosition.Predicate);
            _enumerator = ExecuteTemporalQuery(subject, predicate, obj);
        }
    }

    private enum TermPosition { Subject, Predicate, Object }

    private TemporalResultEnumerator ExecuteTemporalQuery(
        ReadOnlySpan<char> subject, ReadOnlySpan<char> predicate, ReadOnlySpan<char> obj)
    {
        return _temporalMode switch
        {
            TemporalQueryMode.AsOf =>
                _store.QueryAsOf(subject, predicate, obj, _asOfTime, _graph),
            TemporalQueryMode.During =>
                _store.QueryChanges(_rangeStart, _rangeEnd, subject, predicate, obj, _graph),
            TemporalQueryMode.AllVersions =>
                _store.QueryEvolution(subject, predicate, obj, _graph),
            _ => _store.QueryCurrent(subject, predicate, obj, _graph)
        };
    }

    /// <summary>
    /// Executes a grouped sequence path from a given start node.
    /// For example, for (p1/p2/p3)*, this executes the full sequence p1→p2→p3
    /// and returns all nodes reachable at the end of the sequence.
    /// </summary>
    private List<string> ExecuteGroupedSequence(string startNode)
    {
        var results = new List<string>();

        // Get the inner content of the grouped path
        var innerContent = _source.Slice(_pattern.Path.LeftStart, _pattern.Path.LeftLength);

        // Parse the sequence into individual predicates
        var predicates = new List<ReadOnlyMemory<char>>();
        var contentStr = innerContent.ToString();
        var start = 0;
        var depth = 0;

        for (int i = 0; i < contentStr.Length; i++)
        {
            var ch = contentStr[i];
            if (ch == '<') depth++;
            else if (ch == '>') depth--;
            else if (ch == '/' && depth == 0)
            {
                if (i > start)
                {
                    predicates.Add(contentStr.AsMemory(start, i - start));
                }
                start = i + 1;
            }
        }
        // Add the last predicate
        if (start < contentStr.Length)
        {
            predicates.Add(contentStr.AsMemory(start, contentStr.Length - start));
        }

        if (predicates.Count == 0)
            return results;

        // Execute the sequence: start with the start node, execute each predicate in turn
        var currentNodes = new List<string> { startNode };

        foreach (var predicateMem in predicates)
        {
            var nextNodes = new List<string>();
            var predicate = ExpandPrefixedName(predicateMem.Span);

            foreach (var node in currentNodes)
            {
                var enumerator = ExecuteTemporalQuery(
                    node.AsSpan(),
                    predicate,
                    ReadOnlySpan<char>.Empty);

                while (enumerator.MoveNext())
                {
                    var triple = enumerator.Current;
                    nextNodes.Add(triple.Object.ToString());
                }
                enumerator.Dispose();
            }

            currentNodes = nextNodes;
            if (currentNodes.Count == 0)
                break;
        }

        results.AddRange(currentNodes);
        return results;
    }

    /// <summary>
    /// Executes an inverse grouped sequence path from a given start node.
    /// For example, for ^(p1/p2), this executes the sequence in reverse with inverse predicates: ^p2→^p1.
    /// This finds nodes that lead TO the start node via the original sequence.
    /// </summary>
    private List<string> ExecuteInverseGroupedSequence(string startNode)
    {
        var results = new List<string>();

        // Get the inner content of the grouped path
        var innerContent = _source.Slice(_pattern.Path.LeftStart, _pattern.Path.LeftLength);

        // Parse the sequence into individual predicates
        var predicates = new List<ReadOnlyMemory<char>>();
        var contentStr = innerContent.ToString();
        var start = 0;
        var depth = 0;

        for (int i = 0; i < contentStr.Length; i++)
        {
            var ch = contentStr[i];
            if (ch == '<') depth++;
            else if (ch == '>') depth--;
            else if (ch == '/' && depth == 0)
            {
                if (i > start)
                {
                    predicates.Add(contentStr.AsMemory(start, i - start));
                }
                start = i + 1;
            }
        }
        // Add the last predicate
        if (start < contentStr.Length)
        {
            predicates.Add(contentStr.AsMemory(start, contentStr.Length - start));
        }

        if (predicates.Count == 0)
            return results;

        // REVERSE the predicate order for inverse execution
        predicates.Reverse();

        // Execute the sequence: start with the start node, execute each predicate in INVERSE direction
        var currentNodes = new List<string> { startNode };

        foreach (var predicateMem in predicates)
        {
            var nextNodes = new List<string>();
            var predicate = ExpandPrefixedName(predicateMem.Span);

            foreach (var node in currentNodes)
            {
                // INVERSE: query with node as OBJECT to find subjects
                var enumerator = ExecuteTemporalQuery(
                    ReadOnlySpan<char>.Empty,
                    predicate,
                    node.AsSpan());

                while (enumerator.MoveNext())
                {
                    var triple = enumerator.Current;
                    nextNodes.Add(triple.Subject.ToString());
                }
                enumerator.Dispose();
            }

            currentNodes = nextNodes;
            if (currentNodes.Count == 0)
                break;
        }

        results.AddRange(currentNodes);
        return results;
    }

    /// <summary>
    /// Discovers all starting nodes that have the first predicate of a grouped sequence.
    /// Returns (subjects, allNodes) where subjects can start the sequence and allNodes
    /// includes all nodes seen (for reflexive bindings in zero-or-more).
    /// </summary>
    private (HashSet<string> subjects, HashSet<string> allNodes) DiscoverGroupedSequenceStartNodes()
    {
        var subjects = new HashSet<string>();
        var allNodes = new HashSet<string>();

        // Get the inner content and find the first predicate
        var innerContent = _source.Slice(_pattern.Path.LeftStart, _pattern.Path.LeftLength);
        var contentStr = innerContent.ToString();

        // Find the first predicate (up to the first / at depth 0)
        var depth = 0;
        var firstPredicateEnd = contentStr.Length;
        for (int i = 0; i < contentStr.Length; i++)
        {
            var ch = contentStr[i];
            if (ch == '<') depth++;
            else if (ch == '>') depth--;
            else if (ch == '/' && depth == 0)
            {
                firstPredicateEnd = i;
                break;
            }
        }

        var firstPredicate = ExpandPrefixedName(contentStr.AsSpan(0, firstPredicateEnd));

        // Query all triples with the first predicate
        var enumerator = ExecuteTemporalQuery(
            ReadOnlySpan<char>.Empty,
            firstPredicate,
            ReadOnlySpan<char>.Empty);

        while (enumerator.MoveNext())
        {
            var triple = enumerator.Current;
            var subjectStr = triple.Subject.ToString();
            var objectStr = triple.Object.ToString();

            allNodes.Add(subjectStr);
            allNodes.Add(objectStr);
            subjects.Add(subjectStr);
        }
        enumerator.Dispose();

        return (subjects, allNodes);
    }

    private void InitializeTransitive()
    {
        _visited = new HashSet<string>();
        _frontier = new Queue<string>();

        var subject = ResolveTermForQuery(_pattern.Subject);
        var obj = ResolveTermForQuery(_pattern.Object);

        // For grouped paths, we use ExecuteGroupedSequence instead of a single predicate query
        var isGrouped = _isGroupedZeroOrMore || _isGroupedOneOrMore;

        var predicate = ReadOnlySpan<char>.Empty;
        if (!isGrouped)
        {
            predicate = _pattern.HasPropertyPath
                ? ResolveTermForQuery(_pattern.Path.Iri)
                : ResolveTermForQuery(_pattern.Predicate);
        }

        // Case 1: Both subject and object are unbound - need to discover all starting nodes
        if (subject.IsEmpty && obj.IsEmpty)
        {
            _startingNodes = new Queue<string>();
            _allNodes = new HashSet<string>();
            HashSet<string> subjects;

            if (isGrouped)
            {
                // For grouped paths, use the helper to discover starting nodes
                (subjects, _allNodes) = DiscoverGroupedSequenceStartNodes();
            }
            else
            {
                subjects = new HashSet<string>();
                // Query all triples with the predicate to discover all subjects and objects
                var discoveryEnumerator = ExecuteTemporalQuery(
                    ReadOnlySpan<char>.Empty,
                    predicate,
                    ReadOnlySpan<char>.Empty);

                while (discoveryEnumerator.MoveNext())
                {
                    var triple = discoveryEnumerator.Current;
                    var subjectStr = triple.Subject.ToString();
                    var objectStr = triple.Object.ToString();

                    // Track all nodes (for reflexive)
                    _allNodes.Add(subjectStr);
                    _allNodes.Add(objectStr);

                    // Track subjects separately for starting nodes
                    subjects.Add(subjectStr);
                }
                discoveryEnumerator.Dispose();

                // For zero-or-more (*) paths, SPARQL spec requires reflexive pairs for ALL nodes
                // in the graph, not just those connected by the predicate. Query all triples
                // to discover all nodes in the graph.
                if (_isZeroOrMore)
                {
                    var allTriplesEnumerator = ExecuteTemporalQuery(
                        ReadOnlySpan<char>.Empty,
                        ReadOnlySpan<char>.Empty,
                        ReadOnlySpan<char>.Empty);

                    while (allTriplesEnumerator.MoveNext())
                    {
                        var triple = allTriplesEnumerator.Current;
                        _allNodes.Add(triple.Subject.ToString());
                        _allNodes.Add(triple.Object.ToString());
                    }
                    allTriplesEnumerator.Dispose();
                }
            }

            // Add all subjects as starting nodes
            foreach (var s in subjects)
            {
                _startingNodes.Enqueue(s);
            }

            // For zero-or-more, we'll emit reflexive for ALL nodes first
            _emittedReflexive = false;
            _inReflexivePhase = _isZeroOrMore || _isGroupedZeroOrMore;
            if (_isZeroOrMore || _isGroupedZeroOrMore)
            {
                _reflexiveList = new List<string>(_allNodes);
                _reflexiveIndex = 0;
            }

            // Start processing first starting node (if any)
            if (_startingNodes.Count > 0)
            {
                _startNode = _startingNodes.Dequeue();
                _visited.Clear();
                _visited.Add(_startNode);
                _currentNode = _startNode;

                if (isGrouped)
                {
                    // For grouped paths, execute the sequence and queue results
                    _groupedResults = new Queue<string>(ExecuteGroupedSequence(_startNode));
                }
                else
                {
                    _enumerator = ExecuteTemporalQuery(
                        _startNode.AsSpan(),
                        predicate,
                        ReadOnlySpan<char>.Empty);
                }
            }
            else
            {
                // No triples found - just emit reflexive if zero-or-more
                _startNode = "";
                _enumerator = default;
                _groupedResults = new Queue<string>();
            }
        }
        // Case 2: Subject is unbound but object is bound - use object as start
        else if (subject.IsEmpty && !obj.IsEmpty)
        {
            _startNode = obj.ToString();
            _emittedReflexive = false;

            _visited.Add(_startNode);
            _currentNode = _startNode;

            if (isGrouped)
            {
                _groupedResults = new Queue<string>(ExecuteGroupedSequence(_startNode));
            }
            else
            {
                _enumerator = ExecuteTemporalQuery(
                    _startNode.AsSpan(),
                    predicate,
                    ReadOnlySpan<char>.Empty);
            }
        }
        // Case 3: Subject is bound (normal case)
        else
        {
            _startNode = subject.ToString();
            _emittedReflexive = false;

            _visited.Add(_startNode);
            _currentNode = _startNode;

            if (isGrouped)
            {
                _groupedResults = new Queue<string>(ExecuteGroupedSequence(_startNode));
            }
            else
            {
                _enumerator = ExecuteTemporalQuery(
                    _startNode.AsSpan(),
                    predicate,
                    ReadOnlySpan<char>.Empty);
            }
        }
    }

    /// <summary>
    /// Resolve term for query with position-based string storage.
    /// Expanded IRIs are stored as strings in position-specific fields to ensure
    /// span lifetime safety when multiple terms are resolved simultaneously.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ReadOnlySpan<char> ResolveTermWithStorage(Term term, TermPosition position)
    {
        // Handle synthetic terms (negative offsets from SPARQL-star expansion)
        if (SyntheticTermHelper.IsSynthetic(term.Start))
        {
            if (term.IsVariable)
            {
                var varName = SyntheticTermHelper.GetSyntheticVarName(term.Start);
                var idx = _initialBindings.FindBinding(varName);
                if (idx >= 0)
                    return _initialBindings.GetString(idx);
                return ReadOnlySpan<char>.Empty;
            }
            return SyntheticTermHelper.GetSyntheticIri(term.Start);
        }

        if (term.IsVariable)
        {
            var varName = _source.Slice(term.Start, term.Length);
            var idx = _initialBindings.FindBinding(varName);
            if (idx >= 0)
                return _initialBindings.GetString(idx);
            return ReadOnlySpan<char>.Empty;
        }

        if (term.IsBlankNode)
        {
            // Named blank nodes (_:name) should match the literal value
            // Anonymous blank nodes ([]) act as wildcards
            var bnSpan = _source.Slice(term.Start, term.Length);
            if (bnSpan.Length >= 2 && bnSpan[0] == '_' && bnSpan[1] == ':')
                return bnSpan; // Return the actual blank node label
            return ReadOnlySpan<char>.Empty; // Anonymous blank node - wildcard
        }

        var termSpan = _source.Slice(term.Start, term.Length);

        // Handle 'a' shorthand for rdf:type (SPARQL keyword)
        if (termSpan.Length == 1 && termSpan[0] == 'a')
        {
            return SyntheticTermHelper.RdfType.AsSpan();
        }

        // Check if this is a prefixed name that needs expansion
        if (_prefixes != null && termSpan.Length > 0 && termSpan[0] != '<' && termSpan[0] != '"')
        {
            var colonIdx = termSpan.IndexOf(':');
            if (colonIdx >= 0)
            {
                var prefix = termSpan.Slice(0, colonIdx + 1);
                var localName = termSpan.Slice(colonIdx + 1);

                for (int i = 0; i < _prefixes.Length; i++)
                {
                    var mapping = _prefixes[i];
                    var mappedPrefix = _source.Slice(mapping.PrefixStart, mapping.PrefixLength);

                    if (prefix.SequenceEqual(mappedPrefix))
                    {
                        var iriNs = _source.Slice(mapping.IriStart, mapping.IriLength);
                        var nsWithoutClose = iriNs.Slice(0, iriNs.Length - 1);

                        // Build expanded IRI and store as string
                        var expanded = string.Concat(nsWithoutClose, localName, ">");

                        // Store in position-specific field and return span over it
                        switch (position)
                        {
                            case TermPosition.Subject:
                                _expandedSubject = expanded;
                                return _expandedSubject.AsSpan();
                            case TermPosition.Predicate:
                                _expandedPredicate = expanded;
                                return _expandedPredicate.AsSpan();
                            default:
                                _expandedObject = expanded;
                                return _expandedObject.AsSpan();
                        }
                    }
                }
            }
        }

        return termSpan;
    }

    /// <summary>
    /// Simple term resolution for single-term use cases (transitive paths).
    /// Uses shared buffer since only one term is resolved at a time.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ReadOnlySpan<char> ResolveTermForQuery(Term term)
    {
        if (SyntheticTermHelper.IsSynthetic(term.Start))
        {
            if (term.IsVariable)
            {
                var varName = SyntheticTermHelper.GetSyntheticVarName(term.Start);
                var idx = _initialBindings.FindBinding(varName);
                if (idx >= 0)
                    return _initialBindings.GetString(idx);
                return ReadOnlySpan<char>.Empty;
            }
            return SyntheticTermHelper.GetSyntheticIri(term.Start);
        }

        if (term.IsVariable)
        {
            var varName = _source.Slice(term.Start, term.Length);
            var idx = _initialBindings.FindBinding(varName);
            if (idx >= 0)
                return _initialBindings.GetString(idx);
            return ReadOnlySpan<char>.Empty;
        }

        if (term.IsBlankNode)
        {
            // Named blank nodes (_:name) should match the literal value
            // Anonymous blank nodes ([]) act as wildcards
            var bnSpan = _source.Slice(term.Start, term.Length);
            if (bnSpan.Length >= 2 && bnSpan[0] == '_' && bnSpan[1] == ':')
                return bnSpan; // Return the actual blank node label
            return ReadOnlySpan<char>.Empty; // Anonymous blank node - wildcard
        }

        var termSpan = _source.Slice(term.Start, term.Length);

        // Handle 'a' shorthand for rdf:type (SPARQL keyword)
        if (termSpan.Length == 1 && termSpan[0] == 'a')
        {
            return SyntheticTermHelper.RdfType.AsSpan();
        }

        // Check for prefix expansion
        if (_prefixes != null && termSpan.Length > 0 && termSpan[0] != '<' && termSpan[0] != '"')
        {
            var colonIdx = termSpan.IndexOf(':');
            if (colonIdx >= 0)
            {
                var prefix = termSpan.Slice(0, colonIdx + 1);
                var localName = termSpan.Slice(colonIdx + 1);

                for (int i = 0; i < _prefixes.Length; i++)
                {
                    var mapping = _prefixes[i];
                    var mappedPrefix = _source.Slice(mapping.PrefixStart, mapping.PrefixLength);

                    if (prefix.SequenceEqual(mappedPrefix))
                    {
                        var iriNs = _source.Slice(mapping.IriStart, mapping.IriLength);
                        var nsWithoutClose = iriNs.Slice(0, iriNs.Length - 1);

                        // For single-term resolution, store in subject field (reusable)
                        _expandedSubject = string.Concat(nsWithoutClose, localName, ">");
                        return _expandedSubject.AsSpan();
                    }
                }
            }
        }

        return termSpan;
    }

    /// <summary>
    /// Expand a path predicate (from raw start/length offsets) with prefix expansion.
    /// Used for Alternative path predicates which are stored as offsets rather than Term structs.
    /// </summary>
    private ReadOnlySpan<char> ExpandPathPredicate(int start, int length)
    {
        var predSpan = _source.Slice(start, length);

        // Handle 'a' shorthand for rdf:type
        if (predSpan.Length == 1 && predSpan[0] == 'a')
        {
            return SyntheticTermHelper.RdfType.AsSpan();
        }

        // Check if this is a prefixed name that needs expansion
        if (_prefixes != null && predSpan.Length > 0 && predSpan[0] != '<' && predSpan[0] != '"')
        {
            var colonIdx = predSpan.IndexOf(':');
            if (colonIdx >= 0)
            {
                var prefix = predSpan.Slice(0, colonIdx + 1);
                var localName = predSpan.Slice(colonIdx + 1);

                for (int i = 0; i < _prefixes.Length; i++)
                {
                    var mapping = _prefixes[i];
                    var mappedPrefix = _source.Slice(mapping.PrefixStart, mapping.PrefixLength);

                    if (prefix.SequenceEqual(mappedPrefix))
                    {
                        var iriNs = _source.Slice(mapping.IriStart, mapping.IriLength);
                        var nsWithoutClose = iriNs.Slice(0, iriNs.Length - 1);

                        // Store expanded IRI in _expandedPredicate field
                        _expandedPredicate = string.Concat(nsWithoutClose, localName, ">");
                        return _expandedPredicate.AsSpan();
                    }
                }
            }
        }

        return predSpan;
    }

    /// <summary>
    /// Expand a path predicate from a span with prefix expansion.
    /// Used for path segments extracted during n-ary alternative processing.
    /// </summary>
    private ReadOnlySpan<char> ExpandPathPredicateSpan(ReadOnlySpan<char> predSpan)
    {
        // Handle 'a' shorthand for rdf:type
        if (predSpan.Length == 1 && predSpan[0] == 'a')
        {
            return SyntheticTermHelper.RdfType.AsSpan();
        }

        // Check if this is a prefixed name that needs expansion
        if (_prefixes != null && predSpan.Length > 0 && predSpan[0] != '<' && predSpan[0] != '"')
        {
            var colonIdx = predSpan.IndexOf(':');
            if (colonIdx >= 0)
            {
                var prefix = predSpan.Slice(0, colonIdx + 1);
                var localName = predSpan.Slice(colonIdx + 1);

                for (int i = 0; i < _prefixes.Length; i++)
                {
                    var mapping = _prefixes[i];
                    var mappedPrefix = _source.Slice(mapping.PrefixStart, mapping.PrefixLength);

                    if (prefix.SequenceEqual(mappedPrefix))
                    {
                        var iriNs = _source.Slice(mapping.IriStart, mapping.IriLength);
                        var nsWithoutClose = iriNs.Slice(0, iriNs.Length - 1);

                        // Store expanded IRI in _expandedPredicate field
                        _expandedPredicate = string.Concat(nsWithoutClose, localName, ">");
                        return _expandedPredicate.AsSpan();
                    }
                }
            }
        }

        return predSpan;
    }

    /// <summary>
    /// Execute a grouped alternative as the first step of a sequence.
    /// Parses alternatives from the group (e.g., ":p0|^:p1") and executes each,
    /// collecting intermediates from all branches into _sequenceIntermediates.
    /// </summary>
    private void ExecuteGroupedAlternativeFirstStep(ReadOnlySpan<char> groupInner, ReadOnlySpan<char> subject)
    {
        // Split by | at top level
        var remaining = groupInner;
        while (!remaining.IsEmpty)
        {
            var pipeIdx = FindTopLevelOperator(remaining, '|');
            ReadOnlySpan<char> current;

            if (pipeIdx < 0)
            {
                current = remaining.Trim();
                remaining = ReadOnlySpan<char>.Empty;
            }
            else
            {
                current = remaining[..pipeIdx].Trim();
                remaining = remaining[(pipeIdx + 1)..];
            }

            if (current.IsEmpty)
                continue;

            // Check if this branch is inverse (^pred)
            bool isInverse = current[0] == '^';
            var predSpan = isInverse ? current.Slice(1) : current;
            var predicate = ExpandPathPredicateSpan(predSpan);

            // Execute query for this branch
            TemporalResultEnumerator enumerator;
            if (isInverse)
            {
                // ^pred from :a: find triples where object=:a, collect subject as intermediate
                enumerator = ExecuteTemporalQuery(ReadOnlySpan<char>.Empty, predicate, subject);
            }
            else
            {
                // pred from :a: find triples where subject=:a, collect object as intermediate
                enumerator = ExecuteTemporalQuery(subject, predicate, ReadOnlySpan<char>.Empty);
            }

            // Collect all results as intermediates
            while (enumerator.MoveNext())
            {
                var triple = enumerator.Current;
                // For inverse, collect Subject; for direct, collect Object
                var intermediate = isInverse ? triple.Subject : triple.Object;
                _sequenceIntermediates!.Enqueue(intermediate.ToString());
            }
            enumerator.Dispose();
        }
    }

    /// <summary>
    /// Find the first top-level occurrence of an operator in a path span.
    /// Returns -1 if not found. Skips operators inside parentheses and IRIs.
    /// </summary>
    private static int FindTopLevelOperator(ReadOnlySpan<char> span, char op)
    {
        int depth = 0;
        bool inIri = false;
        for (int i = 0; i < span.Length; i++)
        {
            var ch = span[i];
            if (ch == '<' && !inIri) inIri = true;
            else if (ch == '>' && inIri) inIri = false;
            else if (!inIri)
            {
                if (ch == '(') depth++;
                else if (ch == ')') depth--;
                else if (ch == op && depth == 0) return i;
            }
        }
        return -1;
    }

    /// <summary>
    /// Check if a predicate is in the DIRECT elements of the negated property set.
    /// Direct elements are those NOT starting with '^'.
    /// </summary>
    private bool IsPredicateInDirectNegatedSet(ReadOnlySpan<char> predicate)
    {
        var content = _source.Slice(_pattern.Path.LeftStart, _pattern.Path.LeftLength);

        var remaining = content;
        while (!remaining.IsEmpty)
        {
            var sepIndex = remaining.IndexOf('|');
            ReadOnlySpan<char> current;

            if (sepIndex < 0)
            {
                current = remaining.Trim();
                remaining = ReadOnlySpan<char>.Empty;
            }
            else
            {
                current = remaining[..sepIndex].Trim();
                remaining = remaining[(sepIndex + 1)..];
            }

            // Skip inverse predicates (those starting with ^)
            if (current.Length > 0 && current[0] == '^')
                continue;

            // Expand and compare
            var expandedCurrent = ExpandPrefixedName(current);

            // Handle 'a' shorthand for rdf:type
            if (current.Length == 1 && current[0] == 'a')
                expandedCurrent = SyntheticTermHelper.RdfType.AsSpan();

            if (expandedCurrent.SequenceEqual(predicate))
                return true;
        }

        return false;
    }

    /// <summary>
    /// Check if a predicate is in the INVERSE elements of the negated property set.
    /// Inverse elements are those starting with '^'.
    /// </summary>
    private bool IsPredicateInInverseNegatedSet(ReadOnlySpan<char> predicate)
    {
        var content = _source.Slice(_pattern.Path.LeftStart, _pattern.Path.LeftLength);

        var remaining = content;
        while (!remaining.IsEmpty)
        {
            var sepIndex = remaining.IndexOf('|');
            ReadOnlySpan<char> current;

            if (sepIndex < 0)
            {
                current = remaining.Trim();
                remaining = ReadOnlySpan<char>.Empty;
            }
            else
            {
                current = remaining[..sepIndex].Trim();
                remaining = remaining[(sepIndex + 1)..];
            }

            // Only process inverse predicates (those starting with ^)
            if (current.Length == 0 || current[0] != '^')
                continue;

            // Get the predicate after ^
            var innerPred = current.Slice(1).Trim();

            // Handle ^a shorthand for inverse rdf:type
            ReadOnlySpan<char> expandedInner;
            if (innerPred.Length == 1 && innerPred[0] == 'a')
                expandedInner = SyntheticTermHelper.RdfType.AsSpan();
            else
                expandedInner = ExpandPrefixedName(innerPred);

            if (expandedInner.SequenceEqual(predicate))
                return true;
        }

        return false;
    }

    /// <summary>
    /// Check if the negated set has any direct (non-inverse) predicates.
    /// </summary>
    private bool NegatedSetHasDirectPredicates()
    {
        var content = _source.Slice(_pattern.Path.LeftStart, _pattern.Path.LeftLength);

        var remaining = content;
        while (!remaining.IsEmpty)
        {
            var sepIndex = remaining.IndexOf('|');
            ReadOnlySpan<char> current;

            if (sepIndex < 0)
            {
                current = remaining.Trim();
                remaining = ReadOnlySpan<char>.Empty;
            }
            else
            {
                current = remaining[..sepIndex].Trim();
                remaining = remaining[(sepIndex + 1)..];
            }

            if (current.Length > 0 && current[0] != '^')
                return true;
        }

        return false;
    }

    /// <summary>
    /// Check if the negated set has any inverse predicates.
    /// </summary>
    private bool NegatedSetHasInversePredicates()
    {
        var content = _source.Slice(_pattern.Path.LeftStart, _pattern.Path.LeftLength);

        var remaining = content;
        while (!remaining.IsEmpty)
        {
            var sepIndex = remaining.IndexOf('|');
            ReadOnlySpan<char> current;

            if (sepIndex < 0)
            {
                current = remaining.Trim();
                remaining = ReadOnlySpan<char>.Empty;
            }
            else
            {
                current = remaining[..sepIndex].Trim();
                remaining = remaining[(sepIndex + 1)..];
            }

            if (current.Length > 0 && current[0] == '^')
                return true;
        }

        return false;
    }

    /// <summary>
    /// Expands a prefixed name (e.g., "ex:p1") to a full IRI (e.g., "&lt;http://example.org/p1&gt;").
    /// Returns the original span if not a prefixed name or no matching prefix found.
    /// </summary>
    private ReadOnlySpan<char> ExpandPrefixedName(ReadOnlySpan<char> term)
    {
        // If already a full IRI (starts with <), return as-is
        if (term.Length > 0 && term[0] == '<')
            return term;

        // If no prefixes available, return as-is
        if (_prefixes == null)
            return term;

        // Look for colon to identify prefixed name
        var colonIdx = term.IndexOf(':');
        if (colonIdx < 0)
            return term;

        var prefix = term.Slice(0, colonIdx + 1);
        var localName = term.Slice(colonIdx + 1);

        // Find matching prefix
        for (int i = 0; i < _prefixes.Length; i++)
        {
            var mapping = _prefixes[i];
            var mappedPrefix = _source.Slice(mapping.PrefixStart, mapping.PrefixLength);

            if (prefix.SequenceEqual(mappedPrefix))
            {
                var iriNs = _source.Slice(mapping.IriStart, mapping.IriLength);
                var nsWithoutClose = iriNs.Slice(0, iriNs.Length - 1);

                // Build expanded IRI and store for span lifetime
                _expandedPredicate = string.Concat(nsWithoutClose, localName, ">");
                return _expandedPredicate.AsSpan();
            }
        }

        return term;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool TryBindVariable(Term term, ReadOnlySpan<char> value, ref BindingTable bindings)
    {
        if (!term.IsVariable)
        {
            // Constant - verify it matches the expected value
            var expected = ResolveTermForQuery(term);
            return value.SequenceEqual(expected);
        }

        // Handle synthetic variables (from SPARQL-star expansion)
        ReadOnlySpan<char> varName;
        if (SyntheticTermHelper.IsSynthetic(term.Start))
            varName = SyntheticTermHelper.GetSyntheticVarName(term.Start);
        else
            varName = _source.Slice(term.Start, term.Length);

        // Check if already bound (from earlier pattern in join)
        var existingIndex = bindings.FindBinding(varName);
        if (existingIndex >= 0)
        {
            // Must match existing binding
            var existingValue = bindings.GetString(existingIndex);
            return value.SequenceEqual(existingValue);
        }

        // Bind new variable
        bindings.Bind(varName, value);
        return true;
    }

    public void Dispose()
    {
        _enumerator.Dispose();
    }
}

/// <summary>
/// Executes multiple triple patterns using nested loop join.
/// Conforms to <see cref="IScan"/> contract (duck typing).
/// Due to ref struct limitations, we store resolved term strings in fixed buffers
/// to avoid span scoping issues with enumerator initialization.
/// </summary>
internal ref struct MultiPatternScan
{
    /// <summary>
    /// Wrapper class to box GraphPattern on the heap for subquery execution.
    /// This prevents stack overflow from nested subqueries since each MultiPatternScan
    /// would otherwise embed a ~4KB GraphPattern on the stack.
    /// </summary>
    internal sealed class BoxedPattern
    {
        public GraphPattern Pattern;
    }

    private readonly QuadStore _store;
    private readonly ReadOnlySpan<char> _source;
    // Pattern can be stored inline (for main queries) or via reference (for subqueries)
    private readonly GraphPattern _pattern;
    private readonly BoxedPattern? _boxedPattern;
    private readonly bool _useBoxedPattern;
    private readonly bool _unionMode;
    private readonly ReadOnlySpan<char> _graph;
    private readonly int[]? _patternOrder;  // Optimized pattern execution order

    // Temporal query parameters
    private readonly TemporalQueryMode _temporalMode;
    private readonly DateTimeOffset _asOfTime;
    private readonly DateTimeOffset _rangeStart;
    private readonly DateTimeOffset _rangeEnd;

    // Prefix expansion support
    private readonly PrefixMapping[]? _prefixes;
    // Expanded IRIs stored as strings to ensure span lifetime safety
    // Each position needs its own storage since ResolveAndQuery() resolves all three
    // before calling ExecuteTemporalQuery
    private string? _expandedSubject;
    private string? _expandedPredicate;
    private string? _expandedObject;

    // Current state for each pattern level (support up to 12 patterns for SPARQL-star with multiple annotations)
    // ADR-011: Changed from 12 inline fields to pooled array to reduce stack size from ~18KB to ~15KB
    // Note: Nullable because default-constructed struct (as field in another struct) will have null
    private TemporalResultEnumerator[]? _enumerators;
    private const int MaxPatternLevels = 12;

    private int _currentLevel;
    private bool _init0, _init1, _init2, _init3;
    private bool _init4, _init5, _init6, _init7;
    private bool _init8, _init9, _init10, _init11;
    private bool _exhausted;

    // Track binding count at entry to each level for rollback
    private int _bindingCount0, _bindingCount1, _bindingCount2, _bindingCount3;
    private int _bindingCount4, _bindingCount5, _bindingCount6, _bindingCount7;
    private int _bindingCount8, _bindingCount9, _bindingCount10, _bindingCount11;

    // Pushed filter assignments: for each level (0-11), which filter indices to evaluate
    // Using fixed arrays to avoid heap allocations in ref struct
    // Supports up to 8 levels of filter pushing (levels 0-7)
    private int _levelFilterCount0, _levelFilterCount1, _levelFilterCount2, _levelFilterCount3;
    private int _levelFilterCount4, _levelFilterCount5, _levelFilterCount6, _levelFilterCount7;

    // Filter indices per level (max 4 filters per level)
    private int _f0_0, _f0_1, _f0_2, _f0_3;  // Level 0 filters
    private int _f1_0, _f1_1, _f1_2, _f1_3;  // Level 1 filters
    private int _f2_0, _f2_1, _f2_2, _f2_3;  // Level 2 filters
    private int _f3_0, _f3_1, _f3_2, _f3_3;  // Level 3 filters
    private int _f4_0, _f4_1, _f4_2, _f4_3;  // Level 4 filters
    private int _f5_0, _f5_1, _f5_2, _f5_3;  // Level 5 filters
    private int _f6_0, _f6_1, _f6_2, _f6_3;  // Level 6 filters
    private int _f7_0, _f7_1, _f7_2, _f7_3;  // Level 7 filters

    private bool _hasPushedFilters;

    // Term position enum for prefix expansion storage
    private enum TermPosition { Subject, Predicate, Object }

    /// <summary>
    /// Get the current pattern (from boxed or inline storage).
    /// Note: This copies the ~4KB struct - call sparingly and cache locally.
    /// </summary>
    private readonly GraphPattern CurrentPattern =>
        _useBoxedPattern ? _boxedPattern!.Pattern : _pattern;

    // Cached pattern count to avoid repeated CurrentPattern access
    private int _cachedPatternCount;

    public MultiPatternScan(QuadStore store, ReadOnlySpan<char> source, GraphPattern pattern,
        bool unionMode = false, ReadOnlySpan<char> graph = default, PrefixMapping[]? prefixes = null)
        : this(store, source, pattern, unionMode, graph,
               TemporalQueryMode.Current, default, default, default, null, null, prefixes)
    {
    }

    /// <summary>
    /// Constructor for subqueries that takes a boxed pattern to avoid stack overflow.
    /// The pattern is stored by reference on the heap instead of being copied inline.
    /// </summary>
    public MultiPatternScan(QuadStore store, ReadOnlySpan<char> source, BoxedPattern boxedPattern,
        PrefixMapping[]? prefixes = null)
    {
        _store = store;
        _source = source;
        _pattern = default;  // Not used when boxed
        _boxedPattern = boxedPattern;
        _useBoxedPattern = true;
        _unionMode = false;
        _graph = default;
        _patternOrder = null;
        _temporalMode = TemporalQueryMode.Current;
        _asOfTime = default;
        _rangeStart = default;
        _rangeEnd = default;
        _prefixes = prefixes;
        _expandedSubject = null;
        _expandedPredicate = null;
        _expandedObject = null;
        _currentLevel = 0;
        _init0 = _init1 = _init2 = _init3 = false;
        _init4 = _init5 = _init6 = _init7 = false;
        _init8 = _init9 = _init10 = _init11 = false;
        _exhausted = false;
        // ADR-011: Rent enumerator array from pool instead of inline storage
        _enumerators = System.Buffers.ArrayPool<TemporalResultEnumerator>.Shared.Rent(MaxPatternLevels);
        _bindingCount0 = _bindingCount1 = _bindingCount2 = _bindingCount3 = 0;
        _bindingCount4 = _bindingCount5 = _bindingCount6 = _bindingCount7 = 0;
        _bindingCount8 = _bindingCount9 = _bindingCount10 = _bindingCount11 = 0;
        _levelFilterCount0 = _levelFilterCount1 = _levelFilterCount2 = _levelFilterCount3 = 0;
        _levelFilterCount4 = _levelFilterCount5 = _levelFilterCount6 = _levelFilterCount7 = 0;
        _f0_0 = _f0_1 = _f0_2 = _f0_3 = 0;
        _f1_0 = _f1_1 = _f1_2 = _f1_3 = 0;
        _f2_0 = _f2_1 = _f2_2 = _f2_3 = 0;
        _f3_0 = _f3_1 = _f3_2 = _f3_3 = 0;
        _f4_0 = _f4_1 = _f4_2 = _f4_3 = 0;
        _f5_0 = _f5_1 = _f5_2 = _f5_3 = 0;
        _f6_0 = _f6_1 = _f6_2 = _f6_3 = 0;
        _f7_0 = _f7_1 = _f7_2 = _f7_3 = 0;
        _hasPushedFilters = false;

        // Cache pattern count for boxed pattern
        _cachedPatternCount = boxedPattern.Pattern.RequiredPatternCount;
    }

    public MultiPatternScan(QuadStore store, ReadOnlySpan<char> source, GraphPattern pattern,
        bool unionMode, ReadOnlySpan<char> graph,
        TemporalQueryMode temporalMode, DateTimeOffset asOfTime,
        DateTimeOffset rangeStart, DateTimeOffset rangeEnd,
        int[]? patternOrder = null, List<int>[]? levelFilters = null,
        PrefixMapping[]? prefixes = null)
    {
        _store = store;
        _source = source;
        _pattern = pattern;
        _boxedPattern = null;
        _useBoxedPattern = false;
        _unionMode = unionMode;
        _graph = graph;
        _patternOrder = patternOrder;
        _temporalMode = temporalMode;
        _asOfTime = asOfTime;
        _rangeStart = rangeStart;
        _rangeEnd = rangeEnd;
        _prefixes = prefixes;
        _expandedSubject = null;
        _expandedPredicate = null;
        _expandedObject = null;
        _currentLevel = 0;
        _init0 = _init1 = _init2 = _init3 = false;
        _init4 = _init5 = _init6 = _init7 = false;
        _init8 = _init9 = _init10 = _init11 = false;
        _exhausted = false;
        // ADR-011: Rent enumerator array from pool instead of inline storage
        _enumerators = System.Buffers.ArrayPool<TemporalResultEnumerator>.Shared.Rent(MaxPatternLevels);
        _bindingCount0 = _bindingCount1 = _bindingCount2 = _bindingCount3 = 0;
        _bindingCount4 = _bindingCount5 = _bindingCount6 = _bindingCount7 = 0;
        _bindingCount8 = _bindingCount9 = _bindingCount10 = _bindingCount11 = 0;

        // Initialize pushed filter fields (levels 0-7)
        _levelFilterCount0 = _levelFilterCount1 = _levelFilterCount2 = _levelFilterCount3 = 0;
        _levelFilterCount4 = _levelFilterCount5 = _levelFilterCount6 = _levelFilterCount7 = 0;
        _f0_0 = _f0_1 = _f0_2 = _f0_3 = 0;
        _f1_0 = _f1_1 = _f1_2 = _f1_3 = 0;
        _f2_0 = _f2_1 = _f2_2 = _f2_3 = 0;
        _f3_0 = _f3_1 = _f3_2 = _f3_3 = 0;
        _f4_0 = _f4_1 = _f4_2 = _f4_3 = 0;
        _f5_0 = _f5_1 = _f5_2 = _f5_3 = 0;
        _f6_0 = _f6_1 = _f6_2 = _f6_3 = 0;
        _f7_0 = _f7_1 = _f7_2 = _f7_3 = 0;
        _hasPushedFilters = false;

        // Copy pushed filter assignments
        if (levelFilters != null)
        {
            _hasPushedFilters = true;
            for (int level = 0; level < Math.Min(levelFilters.Length, 8); level++)
            {
                var filters = levelFilters[level];
                if (filters == null || filters.Count == 0)
                    continue;

                var count = Math.Min(filters.Count, 4);
                SetLevelFilterCount(level, count);

                for (int i = 0; i < count; i++)
                    SetLevelFilter(level, i, filters[i]);
            }
        }

        // Cache pattern count to avoid repeated struct copying in hot path
        _cachedPatternCount = unionMode ? pattern.UnionBranchPatternCount : pattern.RequiredPatternCount;
    }

    /// <summary>
    /// Get pattern at level, respecting union mode and pattern ordering.
    /// When _patternOrder is set, maps level to pattern index for optimized execution.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private TriplePattern GetPatternAt(int level)
    {
        // Apply pattern order mapping if set
        var patternIndex = _patternOrder != null && level < _patternOrder.Length
            ? _patternOrder[level]
            : level;

        var pattern = CurrentPattern;
        return _unionMode ? pattern.GetUnionPattern(patternIndex) : pattern.GetPattern(patternIndex);
    }

    /// <summary>
    /// Get the number of patterns to process (uses cached value).
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private int GetPatternCount() => _cachedPatternCount;

    #region Pushed Filter Helpers

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void SetLevelFilterCount(int level, int count)
    {
        switch (level)
        {
            case 0: _levelFilterCount0 = count; break;
            case 1: _levelFilterCount1 = count; break;
            case 2: _levelFilterCount2 = count; break;
            case 3: _levelFilterCount3 = count; break;
            case 4: _levelFilterCount4 = count; break;
            case 5: _levelFilterCount5 = count; break;
            case 6: _levelFilterCount6 = count; break;
            case 7: _levelFilterCount7 = count; break;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private readonly int GetLevelFilterCount(int level)
    {
        return level switch
        {
            0 => _levelFilterCount0,
            1 => _levelFilterCount1,
            2 => _levelFilterCount2,
            3 => _levelFilterCount3,
            4 => _levelFilterCount4,
            5 => _levelFilterCount5,
            6 => _levelFilterCount6,
            7 => _levelFilterCount7,
            _ => 0
        };
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void SetLevelFilter(int level, int index, int filterIndex)
    {
        switch (level)
        {
            case 0:
                switch (index) { case 0: _f0_0 = filterIndex; break; case 1: _f0_1 = filterIndex; break; case 2: _f0_2 = filterIndex; break; case 3: _f0_3 = filterIndex; break; }
                break;
            case 1:
                switch (index) { case 0: _f1_0 = filterIndex; break; case 1: _f1_1 = filterIndex; break; case 2: _f1_2 = filterIndex; break; case 3: _f1_3 = filterIndex; break; }
                break;
            case 2:
                switch (index) { case 0: _f2_0 = filterIndex; break; case 1: _f2_1 = filterIndex; break; case 2: _f2_2 = filterIndex; break; case 3: _f2_3 = filterIndex; break; }
                break;
            case 3:
                switch (index) { case 0: _f3_0 = filterIndex; break; case 1: _f3_1 = filterIndex; break; case 2: _f3_2 = filterIndex; break; case 3: _f3_3 = filterIndex; break; }
                break;
            case 4:
                switch (index) { case 0: _f4_0 = filterIndex; break; case 1: _f4_1 = filterIndex; break; case 2: _f4_2 = filterIndex; break; case 3: _f4_3 = filterIndex; break; }
                break;
            case 5:
                switch (index) { case 0: _f5_0 = filterIndex; break; case 1: _f5_1 = filterIndex; break; case 2: _f5_2 = filterIndex; break; case 3: _f5_3 = filterIndex; break; }
                break;
            case 6:
                switch (index) { case 0: _f6_0 = filterIndex; break; case 1: _f6_1 = filterIndex; break; case 2: _f6_2 = filterIndex; break; case 3: _f6_3 = filterIndex; break; }
                break;
            case 7:
                switch (index) { case 0: _f7_0 = filterIndex; break; case 1: _f7_1 = filterIndex; break; case 2: _f7_2 = filterIndex; break; case 3: _f7_3 = filterIndex; break; }
                break;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private readonly int GetLevelFilter(int level, int index)
    {
        return level switch
        {
            0 => index switch { 0 => _f0_0, 1 => _f0_1, 2 => _f0_2, 3 => _f0_3, _ => 0 },
            1 => index switch { 0 => _f1_0, 1 => _f1_1, 2 => _f1_2, 3 => _f1_3, _ => 0 },
            2 => index switch { 0 => _f2_0, 1 => _f2_1, 2 => _f2_2, 3 => _f2_3, _ => 0 },
            3 => index switch { 0 => _f3_0, 1 => _f3_1, 2 => _f3_2, 3 => _f3_3, _ => 0 },
            4 => index switch { 0 => _f4_0, 1 => _f4_1, 2 => _f4_2, 3 => _f4_3, _ => 0 },
            5 => index switch { 0 => _f5_0, 1 => _f5_1, 2 => _f5_2, 3 => _f5_3, _ => 0 },
            6 => index switch { 0 => _f6_0, 1 => _f6_1, 2 => _f6_2, 3 => _f6_3, _ => 0 },
            7 => index switch { 0 => _f7_0, 1 => _f7_1, 2 => _f7_2, 3 => _f7_3, _ => 0 },
            _ => 0
        };
    }

    /// <summary>
    /// Evaluate pushed filters at the given level.
    /// Returns true if all filters pass, false if any filter fails.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool PassesLevelFilters(int level, ref BindingTable bindings)
    {
        if (!_hasPushedFilters)
            return true;

        var count = GetLevelFilterCount(level);
        if (count == 0)
            return true;

        var pattern = CurrentPattern;
        for (int i = 0; i < count; i++)
        {
            var filterIndex = GetLevelFilter(level, i);
            var filter = pattern.GetFilter(filterIndex);
            var filterExpr = _source.Slice(filter.Start, filter.Length);
            var evaluator = new FilterEvaluator(filterExpr);
            // Pass prefixes for prefix expansion in filter expressions (e.g., ?a = :s1)
            if (!evaluator.Evaluate(bindings.GetBindings(), bindings.Count, bindings.GetStringBuffer(),
                _prefixes, _source))
            {
                return false;
            }
        }
        return true;
    }

    #endregion

    public bool MoveNext(ref BindingTable bindings)
    {
        if (_exhausted)
            return false;

        // Get pattern count based on mode (support up to 12 patterns for SPARQL-star with multiple annotations)
        var patternCount = Math.Min(GetPatternCount(), 12);
        if (patternCount == 0)
            return false;

        while (true)
        {
            QueryCancellation.ThrowIfCancellationRequested();

            bool advanced;
            switch (_currentLevel)
            {
                case 0: advanced = TryAdvanceLevel0(ref bindings); break;
                case 1: advanced = TryAdvanceLevel1(ref bindings); break;
                case 2: advanced = TryAdvanceLevel2(ref bindings); break;
                case 3: advanced = TryAdvanceLevel3(ref bindings); break;
                case 4: advanced = TryAdvanceLevel4(ref bindings); break;
                case 5: advanced = TryAdvanceLevel5(ref bindings); break;
                case 6: advanced = TryAdvanceLevel6(ref bindings); break;
                case 7: advanced = TryAdvanceLevel7(ref bindings); break;
                case 8: advanced = TryAdvanceLevel8(ref bindings); break;
                case 9: advanced = TryAdvanceLevel9(ref bindings); break;
                case 10: advanced = TryAdvanceLevel10(ref bindings); break;
                case 11: advanced = TryAdvanceLevel11(ref bindings); break;
                default: advanced = false; break;
            }

            if (advanced)
            {
                // Check pushed filters at this level before proceeding
                if (!PassesLevelFilters(_currentLevel, ref bindings))
                {
                    // Filters failed - continue trying next match at this level
                    continue;
                }

                // Evaluate any BIND expressions that should run after this pattern level.
                // This enables proper BIND semantics where:
                //   ?s ?p ?o .           # pattern 0
                //   BIND(?o+1 AS ?z)     # evaluated here, after pattern 0
                //   ?s1 ?p1 ?z           # pattern 1 - now ?z is bound from BIND
                EvaluateBindsForLevel(_currentLevel, ref bindings);

                if (_currentLevel == patternCount - 1)
                {
                    // At deepest level - we have a complete result
                    return true;
                }
                else
                {
                    // Go deeper
                    _currentLevel++;
                    SetInitialized(_currentLevel, false);
                }
            }
            else
            {
                // Current level exhausted, backtrack
                if (_currentLevel == 0)
                {
                    _exhausted = true;
                    return false;
                }

                // Go up
                _currentLevel--;
            }
        }
    }

    private void SetInitialized(int level, bool value)
    {
        switch (level)
        {
            case 0: _init0 = value; break;
            case 1: _init1 = value; break;
            case 2: _init2 = value; break;
            case 3: _init3 = value; break;
            case 4: _init4 = value; break;
            case 5: _init5 = value; break;
            case 6: _init6 = value; break;
            case 7: _init7 = value; break;
            case 8: _init8 = value; break;
            case 9: _init9 = value; break;
            case 10: _init10 = value; break;
            case 11: _init11 = value; break;
        }
    }

    /// <summary>
    /// Evaluate BIND expressions that should run after the pattern at the given level.
    /// This enables proper BIND semantics where computed variables can be used as constraints
    /// in subsequent patterns.
    /// </summary>
    private void EvaluateBindsForLevel(int level, scoped ref BindingTable bindings)
    {
        var pattern = CurrentPattern;
        if (pattern.BindCount == 0) return;

        // Determine the pattern index at this level (accounting for pattern reordering)
        var patternIndex = _patternOrder != null && level < _patternOrder.Length
            ? _patternOrder[level]
            : level;

        // Evaluate all BINDs whose AfterPatternIndex matches this pattern
        for (int i = 0; i < pattern.BindCount; i++)
        {
            var bind = pattern.GetBind(i);
            if (bind.AfterPatternIndex != patternIndex) continue;

            // Get expression and variable name from source
            var expr = _source.Slice(bind.ExprStart, bind.ExprLength);
            var varName = _source.Slice(bind.VarStart, bind.VarLength);

            // Evaluate the expression
            var evaluator = new BindExpressionEvaluator(expr,
                bindings.GetBindings(),
                bindings.Count,
                bindings.GetStringBuffer());
            var value = evaluator.Evaluate();

            // Bind the result to the target variable using typed overloads
            switch (value.Type)
            {
                case ValueType.Integer:
                    bindings.Bind(varName, value.IntegerValue);
                    break;
                case ValueType.Double:
                    bindings.Bind(varName, value.DoubleValue);
                    break;
                case ValueType.Boolean:
                    bindings.Bind(varName, value.BooleanValue);
                    break;
                case ValueType.String:
                case ValueType.Uri:
                    bindings.Bind(varName, value.StringValue);
                    break;
            }
        }
    }

    private bool TryAdvanceLevel0(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(0);

        if (!_init0)
        {
            _bindingCount0 = bindings.Count;
            InitializeEnumerator0(pattern, ref bindings);
            _init0 = true;
        }
        else
        {
            // Rolling back bindings from previous attempt at this level
            bindings.TruncateTo(_bindingCount0);
        }

        return TryAdvanceEnumerator(ref _enumerators![0], pattern, ref bindings);
    }

    private bool TryAdvanceLevel1(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(1);

        if (!_init1)
        {
            _bindingCount1 = bindings.Count;
            InitializeEnumerator1(pattern, ref bindings);
            _init1 = true;
        }
        else
        {
            // Check if binding table was externally cleared (e.g., by VALUES filtering)
            // If bindings from previous level are missing, backtrack to repopulate
            if (bindings.Count < _bindingCount1)
                return false;
            // Rolling back bindings from previous attempt at this level
            bindings.TruncateTo(_bindingCount1);
        }

        return TryAdvanceEnumerator(ref _enumerators![1], pattern, ref bindings);
    }

    private bool TryAdvanceLevel2(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(2);

        if (!_init2)
        {
            _bindingCount2 = bindings.Count;
            InitializeEnumerator2(pattern, ref bindings);
            _init2 = true;
        }
        else
        {
            // Check if binding table was externally cleared (e.g., by VALUES filtering)
            if (bindings.Count < _bindingCount2)
                return false;
            // Rolling back bindings from previous attempt at this level
            bindings.TruncateTo(_bindingCount2);
        }

        return TryAdvanceEnumerator(ref _enumerators![2], pattern, ref bindings);
    }

    private bool TryAdvanceLevel3(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(3);

        if (!_init3)
        {
            _bindingCount3 = bindings.Count;
            InitializeEnumerator3(pattern, ref bindings);
            _init3 = true;
        }
        else
        {
            // Check if binding table was externally cleared (e.g., by VALUES filtering)
            if (bindings.Count < _bindingCount3)
                return false;
            // Rolling back bindings from previous attempt at this level
            bindings.TruncateTo(_bindingCount3);
        }

        return TryAdvanceEnumerator(ref _enumerators![3], pattern, ref bindings);
    }

    private bool TryAdvanceLevel4(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(4);

        if (!_init4)
        {
            _bindingCount4 = bindings.Count;
            InitializeEnumerator4(pattern, ref bindings);
            _init4 = true;
        }
        else
        {
            // Check if binding table was externally cleared (e.g., by VALUES filtering)
            if (bindings.Count < _bindingCount4)
                return false;
            bindings.TruncateTo(_bindingCount4);
        }

        return TryAdvanceEnumerator(ref _enumerators![4], pattern, ref bindings);
    }

    private bool TryAdvanceLevel5(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(5);

        if (!_init5)
        {
            _bindingCount5 = bindings.Count;
            InitializeEnumerator5(pattern, ref bindings);
            _init5 = true;
        }
        else
        {
            // Check if binding table was externally cleared (e.g., by VALUES filtering)
            if (bindings.Count < _bindingCount5)
                return false;
            bindings.TruncateTo(_bindingCount5);
        }

        return TryAdvanceEnumerator(ref _enumerators![5], pattern, ref bindings);
    }

    private bool TryAdvanceLevel6(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(6);

        if (!_init6)
        {
            _bindingCount6 = bindings.Count;
            InitializeEnumerator6(pattern, ref bindings);
            _init6 = true;
        }
        else
        {
            // Check if binding table was externally cleared (e.g., by VALUES filtering)
            if (bindings.Count < _bindingCount6)
                return false;
            bindings.TruncateTo(_bindingCount6);
        }

        return TryAdvanceEnumerator(ref _enumerators![6], pattern, ref bindings);
    }

    private bool TryAdvanceLevel7(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(7);

        if (!_init7)
        {
            _bindingCount7 = bindings.Count;
            InitializeEnumerator7(pattern, ref bindings);
            _init7 = true;
        }
        else
        {
            // Check if binding table was externally cleared (e.g., by VALUES filtering)
            if (bindings.Count < _bindingCount7)
                return false;
            bindings.TruncateTo(_bindingCount7);
        }

        return TryAdvanceEnumerator(ref _enumerators![7], pattern, ref bindings);
    }

    private bool TryAdvanceLevel8(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(8);

        if (!_init8)
        {
            _bindingCount8 = bindings.Count;
            InitializeEnumerator8(pattern, ref bindings);
            _init8 = true;
        }
        else
        {
            // Check if binding table was externally cleared (e.g., by VALUES filtering)
            if (bindings.Count < _bindingCount8)
                return false;
            bindings.TruncateTo(_bindingCount8);
        }

        return TryAdvanceEnumerator(ref _enumerators![8], pattern, ref bindings);
    }

    private bool TryAdvanceLevel9(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(9);

        if (!_init9)
        {
            _bindingCount9 = bindings.Count;
            InitializeEnumerator9(pattern, ref bindings);
            _init9 = true;
        }
        else
        {
            // Check if binding table was externally cleared (e.g., by VALUES filtering)
            if (bindings.Count < _bindingCount9)
                return false;
            bindings.TruncateTo(_bindingCount9);
        }

        return TryAdvanceEnumerator(ref _enumerators![9], pattern, ref bindings);
    }

    private bool TryAdvanceLevel10(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(10);

        if (!_init10)
        {
            _bindingCount10 = bindings.Count;
            InitializeEnumerator10(pattern, ref bindings);
            _init10 = true;
        }
        else
        {
            // Check if binding table was externally cleared (e.g., by VALUES filtering)
            if (bindings.Count < _bindingCount10)
                return false;
            bindings.TruncateTo(_bindingCount10);
        }

        return TryAdvanceEnumerator(ref _enumerators![10], pattern, ref bindings);
    }

    private bool TryAdvanceLevel11(scoped ref BindingTable bindings)
    {
        var pattern = GetPatternAt(11);

        if (!_init11)
        {
            _bindingCount11 = bindings.Count;
            InitializeEnumerator11(pattern, ref bindings);
            _init11 = true;
        }
        else
        {
            // Check if binding table was externally cleared (e.g., by VALUES filtering)
            if (bindings.Count < _bindingCount11)
                return false;
            bindings.TruncateTo(_bindingCount11);
        }

        return TryAdvanceEnumerator(ref _enumerators![11], pattern, ref bindings);
    }

    // Each init method resolves terms and creates the enumerator.
    // Terms resolve to either a slice of _source (for constants) or empty span (for unbound variables).
    // Bound variables need their value copied to avoid span escaping issues.
    private void InitializeEnumerator0(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enumerators![0]);
    }

    private void InitializeEnumerator1(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enumerators![1]);
    }

    private void InitializeEnumerator2(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enumerators![2]);
    }

    private void InitializeEnumerator3(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enumerators![3]);
    }

    private void InitializeEnumerator4(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enumerators![4]);
    }

    private void InitializeEnumerator5(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enumerators![5]);
    }

    private void InitializeEnumerator6(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enumerators![6]);
    }

    private void InitializeEnumerator7(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enumerators![7]);
    }

    private void InitializeEnumerator8(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enumerators![8]);
    }

    private void InitializeEnumerator9(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enumerators![9]);
    }

    private void InitializeEnumerator10(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enumerators![10]);
    }

    private void InitializeEnumerator11(TriplePattern pattern, scoped ref BindingTable bindings)
    {
        ResolveAndQuery(pattern, ref bindings, out _enumerators![11]);
    }

    private void ResolveAndQuery(TriplePattern pattern, scoped ref BindingTable bindings, out TemporalResultEnumerator enumerator)
    {
        // For each term, resolve to a span. Constants come from _source (stable),
        // unbound variables become empty span. Bound variables need special handling.
        // Synthetic terms (negative offsets) come from SPARQL-star expansion.
        // IMPORTANT: Each term uses its own storage field to prevent buffer overwrite issues.
        ReadOnlySpan<char> subject, predicate, obj;

        // Check if this is an inverse path
        bool isInverse = pattern.Path.Type == PathType.Inverse;

        // Resolve subject - store in _expandedSubject if expansion needed
        subject = ResolveTerm(pattern.Subject, ref bindings, TermPosition.Subject);

        // Resolve predicate - for inverse paths, use Path.Iri
        // Store in _expandedPredicate if expansion needed
        predicate = isInverse
            ? ResolveTerm(pattern.Path.Iri, ref bindings, TermPosition.Predicate)
            : ResolveTerm(pattern.Predicate, ref bindings, TermPosition.Predicate);

        // Resolve object - store in _expandedObject if expansion needed
        obj = ResolveTerm(pattern.Object, ref bindings, TermPosition.Object);

        // For inverse paths, swap subject and object in the query
        if (isInverse)
        {
            enumerator = ExecuteTemporalQuery(obj, predicate, subject);
        }
        else
        {
            enumerator = ExecuteTemporalQuery(subject, predicate, obj);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ReadOnlySpan<char> ResolveTerm(Term term, scoped ref BindingTable bindings, TermPosition position)
    {
        // Handle synthetic terms (negative offsets from SPARQL-star expansion)
        if (SyntheticTermHelper.IsSynthetic(term.Start))
        {
            if (term.IsVariable)
            {
                var varName = SyntheticTermHelper.GetSyntheticVarName(term.Start);
                var idx = bindings.FindBinding(varName);
                return idx >= 0 ? bindings.GetString(idx) : ReadOnlySpan<char>.Empty;
            }
            return SyntheticTermHelper.GetSyntheticIri(term.Start);
        }

        // Blank nodes in patterns: named (_:b) match literal, anonymous ([]) are wildcards
        if (term.IsBlankNode)
        {
            var bnSpan = _source.Slice(term.Start, term.Length);
            if (bnSpan.Length >= 2 && bnSpan[0] == '_' && bnSpan[1] == ':')
                return bnSpan; // Named blank node - match literal value
            return ReadOnlySpan<char>.Empty; // Anonymous blank node - wildcard
        }

        if (!term.IsVariable)
        {
            var termSpan = _source.Slice(term.Start, term.Length);

            // Handle 'a' shorthand for rdf:type (SPARQL keyword)
            if (termSpan.Length == 1 && termSpan[0] == 'a')
            {
                return SyntheticTermHelper.RdfType.AsSpan();
            }

            // Check if this is a prefixed name that needs expansion
            if (_prefixes != null && termSpan.Length > 0 && termSpan[0] != '<' && termSpan[0] != '"')
            {
                var colonIdx = termSpan.IndexOf(':');
                if (colonIdx >= 0)
                {
                    var prefix = termSpan.Slice(0, colonIdx + 1);
                    var localName = termSpan.Slice(colonIdx + 1);

                    for (int i = 0; i < _prefixes.Length; i++)
                    {
                        var mapping = _prefixes[i];
                        var mappedPrefix = _source.Slice(mapping.PrefixStart, mapping.PrefixLength);

                        if (prefix.SequenceEqual(mappedPrefix))
                        {
                            // Found matching prefix - expand to full IRI
                            var iriNs = _source.Slice(mapping.IriStart, mapping.IriLength);

                            // IRI namespace is like <http://example.org/> - we need to strip angle brackets and append local name
                            var nsWithoutClose = iriNs.Slice(0, iriNs.Length - 1); // Remove trailing >

                            // Store expanded IRI in position-specific field to prevent buffer overwrite
                            var expanded = string.Concat(nsWithoutClose, localName, ">");
                            switch (position)
                            {
                                case TermPosition.Subject:
                                    _expandedSubject = expanded;
                                    return _expandedSubject.AsSpan();
                                case TermPosition.Predicate:
                                    _expandedPredicate = expanded;
                                    return _expandedPredicate.AsSpan();
                                default:
                                    _expandedObject = expanded;
                                    return _expandedObject.AsSpan();
                            }
                        }
                    }
                }
            }

            return termSpan;
        }

        var name = _source.Slice(term.Start, term.Length);
        var index = bindings.FindBinding(name);
        if (index < 0)
            return ReadOnlySpan<char>.Empty;

        // For typed values from BIND, format as proper RDF literal for store matching
        var bindingType = bindings.GetType(index);
        if (bindingType == BindingValueType.Integer)
        {
            // Format as: "2"^^<http://www.w3.org/2001/XMLSchema#integer>
            var intVal = bindings.GetInteger(index);
            var formatted = $"\"{intVal}\"^^<http://www.w3.org/2001/XMLSchema#integer>";
            switch (position)
            {
                case TermPosition.Subject:
                    _expandedSubject = formatted;
                    return _expandedSubject.AsSpan();
                case TermPosition.Predicate:
                    _expandedPredicate = formatted;
                    return _expandedPredicate.AsSpan();
                default:
                    _expandedObject = formatted;
                    return _expandedObject.AsSpan();
            }
        }
        else if (bindingType == BindingValueType.Double)
        {
            // Format as: "3.14"^^<http://www.w3.org/2001/XMLSchema#double>
            var doubleVal = bindings.GetDouble(index);
            var formatted = $"\"{doubleVal}\"^^<http://www.w3.org/2001/XMLSchema#double>";
            switch (position)
            {
                case TermPosition.Subject:
                    _expandedSubject = formatted;
                    return _expandedSubject.AsSpan();
                case TermPosition.Predicate:
                    _expandedPredicate = formatted;
                    return _expandedPredicate.AsSpan();
                default:
                    _expandedObject = formatted;
                    return _expandedObject.AsSpan();
            }
        }
        else if (bindingType == BindingValueType.Boolean)
        {
            // Format as: "true"^^<http://www.w3.org/2001/XMLSchema#boolean>
            var boolVal = bindings.GetBoolean(index);
            var formatted = $"\"{(boolVal ? "true" : "false")}\"^^<http://www.w3.org/2001/XMLSchema#boolean>";
            switch (position)
            {
                case TermPosition.Subject:
                    _expandedSubject = formatted;
                    return _expandedSubject.AsSpan();
                case TermPosition.Predicate:
                    _expandedPredicate = formatted;
                    return _expandedPredicate.AsSpan();
                default:
                    _expandedObject = formatted;
                    return _expandedObject.AsSpan();
            }
        }

        // For String and Uri types, return the raw value
        return bindings.GetString(index);
    }

    private TemporalResultEnumerator ExecuteTemporalQuery(
        ReadOnlySpan<char> subject, ReadOnlySpan<char> predicate, ReadOnlySpan<char> obj)
    {
        return _temporalMode switch
        {
            TemporalQueryMode.AsOf =>
                _store.QueryAsOf(subject, predicate, obj, _asOfTime, _graph),
            TemporalQueryMode.During =>
                _store.QueryChanges(_rangeStart, _rangeEnd, subject, predicate, obj, _graph),
            TemporalQueryMode.AllVersions =>
                _store.QueryEvolution(subject, predicate, obj, _graph),
            _ => _store.QueryCurrent(subject, predicate, obj, _graph)
        };
    }

    private bool TryAdvanceEnumerator(ref TemporalResultEnumerator enumerator,
        TriplePattern pattern, scoped ref BindingTable bindings)
    {
        bool isInverse = pattern.Path.Type == PathType.Inverse;

        while (enumerator.MoveNext())
        {
            var triple = enumerator.Current;

            // Try to bind variables, checking consistency with existing bindings
            // For inverse paths, swap subject and object bindings
            if (isInverse)
            {
                // Inverse: pattern.Subject binds to triple.Object, pattern.Object binds to triple.Subject
                if (TryBindVariable(pattern.Subject, triple.Object, ref bindings) &&
                    TryBindVariable(pattern.Object, triple.Subject, ref bindings))
                {
                    return true;
                }
            }
            else
            {
                if (TryBindVariable(pattern.Subject, triple.Subject, ref bindings) &&
                    TryBindVariable(pattern.Predicate, triple.Predicate, ref bindings) &&
                    TryBindVariable(pattern.Object, triple.Object, ref bindings))
                {
                    return true;
                }
            }
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool TryBindVariable(Term term, ReadOnlySpan<char> value, scoped ref BindingTable bindings)
    {
        if (!term.IsVariable)
            return true;

        // Handle synthetic variables (from SPARQL-star expansion)
        ReadOnlySpan<char> varName;
        if (SyntheticTermHelper.IsSynthetic(term.Start))
            varName = SyntheticTermHelper.GetSyntheticVarName(term.Start);
        else
            varName = _source.Slice(term.Start, term.Length);

        var existingIndex = bindings.FindBinding(varName);

        if (existingIndex >= 0)
        {
            // Check if existing binding is a typed value (Integer, Double, Boolean)
            // These need semantic comparison with store values (which include type suffixes)
            var bindingType = bindings.GetType(existingIndex);

            if (bindingType == BindingValueType.Integer)
            {
                // Compare integer: existing is numeric, store value is "N"^^<xsd:integer>
                var existingInt = bindings.GetInteger(existingIndex);
                // Try to parse incoming value as typed integer literal
                if (TryParseIntegerLiteral(value, out var parsedInt))
                {
                    return existingInt == parsedInt;
                }
                return false;
            }
            else if (bindingType == BindingValueType.Double)
            {
                // Compare double: existing is numeric, store value is "N.N"^^<xsd:double/decimal>
                var existingDouble = bindings.GetDouble(existingIndex);
                if (TryParseDoubleLiteral(value, out var parsedDouble))
                {
                    return Math.Abs(existingDouble - parsedDouble) < 1e-10;
                }
                return false;
            }
            else if (bindingType == BindingValueType.Boolean)
            {
                // Compare boolean
                var existingBool = bindings.GetBoolean(existingIndex);
                if (TryParseBooleanLiteral(value, out var parsedBool))
                {
                    return existingBool == parsedBool;
                }
                return false;
            }

            // String comparison for String/Uri types
            var existingValue = bindings.GetString(existingIndex);
            return value.SequenceEqual(existingValue);
        }

        bindings.Bind(varName, value);
        return true;
    }

    // Parse typed integer literal: "N"^^<http://www.w3.org/2001/XMLSchema#integer>
    private static bool TryParseIntegerLiteral(ReadOnlySpan<char> literal, out long value)
    {
        value = 0;
        if (literal.Length < 3 || literal[0] != '"')
            return false;

        // Find closing quote
        var closeQuote = literal.Slice(1).IndexOf('"');
        if (closeQuote < 0)
            return false;

        var numberPart = literal.Slice(1, closeQuote);
        return long.TryParse(numberPart, out value);
    }

    // Parse typed double literal: "N.N"^^<http://www.w3.org/2001/XMLSchema#double/decimal>
    private static bool TryParseDoubleLiteral(ReadOnlySpan<char> literal, out double value)
    {
        value = 0;
        if (literal.Length < 3 || literal[0] != '"')
            return false;

        var closeQuote = literal.Slice(1).IndexOf('"');
        if (closeQuote < 0)
            return false;

        var numberPart = literal.Slice(1, closeQuote);
        return double.TryParse(numberPart, System.Globalization.NumberStyles.Float,
            System.Globalization.CultureInfo.InvariantCulture, out value);
    }

    // Parse typed boolean literal: "true"^^<xsd:boolean> or "false"^^<xsd:boolean>
    private static bool TryParseBooleanLiteral(ReadOnlySpan<char> literal, out bool value)
    {
        value = false;
        if (literal.Length < 5 || literal[0] != '"')
            return false;

        var closeQuote = literal.Slice(1).IndexOf('"');
        if (closeQuote < 0)
            return false;

        var boolPart = literal.Slice(1, closeQuote);
        if (boolPart.SequenceEqual("true".AsSpan()))
        {
            value = true;
            return true;
        }
        if (boolPart.SequenceEqual("false".AsSpan()))
        {
            value = false;
            return true;
        }
        return false;
    }

    public void Dispose()
    {
        // ADR-011: Dispose enumerators in pooled array and return array to pool
        // Note: _enumerators can be null if this is a default-constructed struct (e.g., field in another struct)
        if (_enumerators != null && _enumerators.Length > 0)
        {
            for (int i = 0; i < MaxPatternLevels; i++)
            {
                _enumerators![i].Dispose();
            }
            System.Buffers.ArrayPool<TemporalResultEnumerator>.Shared.Return(_enumerators);
            _enumerators = Array.Empty<TemporalResultEnumerator>();
        }
    }
}

/// <summary>
/// Scans triple patterns across all named graphs, binding a graph variable.
/// Conforms to <see cref="IScan"/> contract (duck typing).
/// For queries like: SELECT ?g ?s ?p ?o WHERE { GRAPH ?g { ?s ?p ?o } }
/// Supports FROM NAMED restriction: only iterate specified named graphs.
/// </summary>
internal ref struct VariableGraphScan
{
    private readonly QuadStore _store;
    private readonly ReadOnlySpan<char> _source;
    private readonly GraphClause _graphClause;
    private NamedGraphEnumerator _graphEnum;
    private MultiPatternScan _currentScan;
    private GraphPattern _innerPattern;
    private ReadOnlySpan<char> _currentGraph;
    private readonly int _graphVarHash;
    private bool _initialized;
    private bool _exhausted;

    // FROM NAMED restriction: if non-null, only iterate these graphs
    private readonly string[]? _allowedNamedGraphs;
    private int _allowedGraphIndex;  // For iterating _allowedNamedGraphs directly

    public VariableGraphScan(QuadStore store, ReadOnlySpan<char> source, GraphClause graphClause,
        string[]? allowedNamedGraphs = null)
    {
        _store = store;
        _source = source;
        _graphClause = graphClause;
        _graphEnum = allowedNamedGraphs == null ? store.GetNamedGraphs() : default;
        _currentScan = default;
        _innerPattern = default;
        _currentGraph = default;
        _initialized = false;
        _exhausted = false;
        _allowedNamedGraphs = allowedNamedGraphs;
        _allowedGraphIndex = 0;

        // Compute hash for graph variable name for binding
        var graphVarName = source.Slice(graphClause.Graph.Start, graphClause.Graph.Length);
        _graphVarHash = ComputeHash(graphVarName);

        // Build inner pattern from graph clause patterns
        _innerPattern = new GraphPattern();
        for (int i = 0; i < graphClause.PatternCount; i++)
        {
            _innerPattern.AddPattern(graphClause.GetPattern(i));
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int ComputeHash(ReadOnlySpan<char> s)
    {
        unchecked
        {
            int hash = (int)2166136261;
            foreach (var c in s)
                hash = (hash ^ c) * 16777619;
            return hash;
        }
    }

    public bool MoveNext(ref BindingTable bindings)
    {
        if (_exhausted)
            return false;

        while (true)
        {
            QueryCancellation.ThrowIfCancellationRequested();

            // Try to get next result from current graph's scan
            if (_initialized && _currentScan.MoveNext(ref bindings))
            {
                // Bind the graph variable
                var graphVarName = _source.Slice(_graphClause.Graph.Start, _graphClause.Graph.Length);
                bindings.Bind(graphVarName, _currentGraph);
                return true;
            }

            // Move to next graph
            if (!MoveToNextGraph())
            {
                _exhausted = true;
                return false;
            }

            // Initialize scan for new graph
            _currentScan = new MultiPatternScan(_store, _source, _innerPattern, false, _currentGraph);
            _initialized = true;
        }
    }

    private bool MoveToNextGraph()
    {
        if (_allowedNamedGraphs != null)
        {
            // Iterate through allowed graphs list
            if (_allowedGraphIndex >= _allowedNamedGraphs.Length)
                return false;
            _currentGraph = _allowedNamedGraphs[_allowedGraphIndex++].AsSpan();
            return true;
        }
        else
        {
            // Iterate all named graphs
            if (!_graphEnum.MoveNext())
                return false;
            _currentGraph = _graphEnum.Current;
            return true;
        }
    }

    public void Dispose()
    {
        _currentScan.Dispose();
    }
}

/// <summary>
/// Boxed executor for subqueries that isolates large scan operator stack usage.
/// This class exists to break the ref struct stack chain: when SubQueryScan (ref struct)
/// calls this class's methods, the scan operators are created in a fresh stack frame
/// that doesn't inherit the accumulated ref struct field sizes from the call chain.
/// </summary>
internal sealed class BoxedSubQueryExecutor
{
    private readonly QuadStore _store;
    private readonly string _source;
    private readonly SubSelect _subSelect;
    private readonly bool _distinct;
    private readonly PrefixMapping[]? _prefixes;
    private readonly string? _graphContext;  // Graph context for subqueries inside GRAPH clauses

    public BoxedSubQueryExecutor(QuadStore store, string source, SubSelect subSelect, PrefixMapping[]? prefixes = null)
    {
        _store = store;
        _source = source;
        _subSelect = subSelect;
        _distinct = subSelect.Distinct;
        _prefixes = prefixes;

        // Extract graph context if the subquery is inside a GRAPH clause
        if (subSelect.HasGraphContext)
        {
            var graphTerm = subSelect.GraphContext;
            _graphContext = source.AsSpan(graphTerm.Start, graphTerm.Length).ToString();
        }
    }

    /// <summary>
    /// Execute the subquery and return materialized results.
    /// This method creates scan operators locally - their stack usage is isolated.
    /// </summary>
    [MethodImpl(MethodImplOptions.NoInlining)]
    public List<MaterializedRow> Execute()
    {
        // Handle variable graph context (GRAPH ?g { subquery })
        // When graph context is a variable, we need to iterate over all named graphs
        if (_subSelect.HasGraphContext && _subSelect.GraphContext.IsVariable)
        {
            return ExecuteWithVariableGraphContext();
        }

        var results = new List<MaterializedRow>();
        var innerBindings = new Binding[16];
        var innerStringBuffer = PooledBufferManager.Shared.Rent<char>(512).Array!;
        var bindingTable = new BindingTable(innerBindings, innerStringBuffer);
        HashSet<int>? seenHashes = _distinct ? new HashSet<int>() : null;

        try
        {
            // If subquery has REAL aggregates (COUNT, SUM, etc.), use aggregation path
            // Non-aggregate computed expressions (CONCAT, STR, etc.) are handled in ProcessAndAddResult
            if (_subSelect.HasRealAggregates)
            {
                return ExecuteWithAggregation(ref bindingTable);
            }

            // Handle nested subqueries (subquery within subquery)
            if (_subSelect.HasSubQueries && _subSelect.PatternCount == 0)
            {
                return ExecuteNestedSubQueries(ref bindingTable);
            }

            int skipped = 0;
            int returned = 0;

            if (_subSelect.PatternCount == 1)
            {
                MaterializeSinglePattern(ref bindingTable, results, seenHashes, ref skipped, ref returned);
            }
            else
            {
                MaterializeMultiPattern(ref bindingTable, results, seenHashes, ref skipped, ref returned);
            }
        }
        finally
        {
            PooledBufferManager.Shared.Return(innerStringBuffer);
        }

        return results;
    }

    /// <summary>
    /// Execute subquery with variable graph context (GRAPH ?g { subquery }).
    /// Iterates over all named graphs and executes the subquery against each.
    /// </summary>
    [MethodImpl(MethodImplOptions.NoInlining)]
    private List<MaterializedRow> ExecuteWithVariableGraphContext()
    {
        var results = new List<MaterializedRow>();
        var innerBindings = new Binding[16];
        var innerStringBuffer = PooledBufferManager.Shared.Rent<char>(512).Array!;
        var bindingTable = new BindingTable(innerBindings, innerStringBuffer);
        HashSet<int>? seenHashes = _distinct ? new HashSet<int>() : null;

        // Get the graph variable name from source
        var graphTerm = _subSelect.GraphContext;
        var graphVarName = _source.AsSpan(graphTerm.Start, graphTerm.Length);
        var graphVarNameStr = graphVarName.ToString();

        try
        {
            int skipped = 0;
            int returned = 0;

            // Iterate over all named graphs
            var graphEnum = _store.GetNamedGraphs();
            while (graphEnum.MoveNext())
            {
                var graphIri = graphEnum.Current;
                var graphIriStr = graphIri.ToString();

                // Execute patterns against this graph
                if (_subSelect.PatternCount == 1)
                {
                    MaterializeSinglePatternWithGraph(ref bindingTable, results, seenHashes,
                        ref skipped, ref returned, graphIriStr, graphVarNameStr);
                }
                else
                {
                    MaterializeMultiPatternWithGraph(ref bindingTable, results, seenHashes,
                        ref skipped, ref returned, graphIriStr, graphVarNameStr);
                }

                // Check limit
                if (_subSelect.Limit > 0 && returned >= _subSelect.Limit)
                    break;
            }
        }
        finally
        {
            PooledBufferManager.Shared.Return(innerStringBuffer);
        }

        return results;
    }

    /// <summary>
    /// Check if a variable is projected by the subquery (either SELECT * or explicitly listed).
    /// </summary>
    private bool IsVariableProjected(string varName)
    {
        // SELECT * projects all variables
        if (_subSelect.SelectAll)
            return true;

        // Check explicitly projected variables
        var source = _source.AsSpan();
        for (int i = 0; i < _subSelect.ProjectedVarCount; i++)
        {
            var (start, len) = _subSelect.GetProjectedVariable(i);
            var projectedVar = source.Slice(start, len);
            if (projectedVar.SequenceEqual(varName.AsSpan()))
                return true;
        }

        return false;
    }

    /// <summary>
    /// Materialize single pattern results for a specific graph, binding the graph variable.
    /// </summary>
    [MethodImpl(MethodImplOptions.NoInlining)]
    private void MaterializeSinglePatternWithGraph(ref BindingTable bindingTable, List<MaterializedRow> results,
        HashSet<int>? seenHashes, ref int skipped, ref int returned, string graphIri, string graphVarName)
    {
        var tp = _subSelect.GetPattern(0);
        var source = _source.AsSpan();

        // Only pre-bind the graph variable if the subquery projects it (SELECT * or explicit).
        // This enables proper join semantics:
        // - If projected: filter pattern results where ?g doesn't match graphIri (sq02)
        // - If not projected: no filtering, all results pass through (sq03)
        bool preBindGraph = IsVariableProjected(graphVarName);
        int preBindCount = 0;

        if (preBindGraph)
        {
            bindingTable.Bind(graphVarName.AsSpan(), graphIri.AsSpan());
            preBindCount = bindingTable.Count;
        }

        var scan = new TriplePatternScan(_store, source, tp, bindingTable, graphIri.AsSpan(),
            TemporalQueryMode.Current, default, default, default, _prefixes);
        try
        {
            while (scan.MoveNext(ref bindingTable))
            {
                // Bind graph variable for output (needed for both cases)
                if (!preBindGraph)
                    bindingTable.Bind(graphVarName.AsSpan(), graphIri.AsSpan());

                if (ProcessAndAddResult(ref bindingTable, results, seenHashes, ref skipped, ref returned))
                {
                    if (_subSelect.Limit > 0 && returned >= _subSelect.Limit)
                        break;
                }

                if (preBindGraph)
                    bindingTable.TruncateTo(preBindCount);  // Keep graph binding, clear pattern bindings
                else
                    bindingTable.Clear();
            }
        }
        finally
        {
            scan.Dispose();
            bindingTable.Clear();  // Clear for next graph iteration
        }
    }

    /// <summary>
    /// Materialize multi-pattern results for a specific graph, binding the graph variable.
    /// </summary>
    [MethodImpl(MethodImplOptions.NoInlining)]
    private void MaterializeMultiPatternWithGraph(ref BindingTable bindingTable, List<MaterializedRow> results,
        HashSet<int>? seenHashes, ref int skipped, ref int returned, string graphIri, string graphVarName)
    {
        if (_subSelect.HasUnion)
        {
            // Execute UNION branches with graph context
            MaterializeUnionBranchesWithGraph(ref bindingTable, results, seenHashes,
                ref skipped, ref returned, graphIri, graphVarName);
        }
        else
        {
            // Build pattern on heap
            var boxedPattern = new MultiPatternScan.BoxedPattern();
            for (int i = 0; i < _subSelect.PatternCount; i++)
            {
                boxedPattern.Pattern.AddPattern(_subSelect.GetPattern(i));
            }

            var source = _source.AsSpan();

            // Only pre-bind the graph variable if the subquery projects it
            bool preBindGraph = IsVariableProjected(graphVarName);
            int preBindCount = 0;

            if (preBindGraph)
            {
                bindingTable.Bind(graphVarName.AsSpan(), graphIri.AsSpan());
                preBindCount = bindingTable.Count;
            }

            var scan = new MultiPatternScan(_store, source, boxedPattern.Pattern, false, graphIri.AsSpan());
            try
            {
                while (scan.MoveNext(ref bindingTable))
                {
                    // Bind graph variable for output (needed for both cases)
                    if (!preBindGraph)
                        bindingTable.Bind(graphVarName.AsSpan(), graphIri.AsSpan());

                    if (ProcessAndAddResult(ref bindingTable, results, seenHashes, ref skipped, ref returned))
                    {
                        if (_subSelect.Limit > 0 && returned >= _subSelect.Limit)
                            break;
                    }

                    if (preBindGraph)
                        bindingTable.TruncateTo(preBindCount);
                    else
                        bindingTable.Clear();
                }
            }
            finally
            {
                scan.Dispose();
                bindingTable.Clear();  // Clear for next graph iteration
            }
        }
    }

    /// <summary>
    /// Materialize UNION branch results for a specific graph, binding the graph variable.
    /// </summary>
    [MethodImpl(MethodImplOptions.NoInlining)]
    private void MaterializeUnionBranchesWithGraph(ref BindingTable bindingTable, List<MaterializedRow> results,
        HashSet<int>? seenHashes, ref int skipped, ref int returned, string graphIri, string graphVarName)
    {
        var source = _source.AsSpan();
        var graphSpan = graphIri.AsSpan();

        // Only pre-bind the graph variable if the subquery projects it
        bool preBindGraph = IsVariableProjected(graphVarName);
        int preBindCount = 0;

        if (preBindGraph)
        {
            bindingTable.Bind(graphVarName.AsSpan(), graphSpan);
            preBindCount = bindingTable.Count;
        }

        // Execute first branch
        if (_subSelect.FirstBranchPatternCount > 0)
        {
            if (_subSelect.FirstBranchPatternCount > 1)
            {
                var firstBranch = new MultiPatternScan.BoxedPattern();
                for (int i = 0; i < _subSelect.FirstBranchPatternCount; i++)
                {
                    firstBranch.Pattern.AddPattern(_subSelect.GetPattern(i));
                }

                var firstScan = new MultiPatternScan(_store, source, firstBranch.Pattern, false, graphSpan);
                try
                {
                    while (firstScan.MoveNext(ref bindingTable))
                    {
                        if (!preBindGraph)
                            bindingTable.Bind(graphVarName.AsSpan(), graphSpan);

                        if (ProcessAndAddResult(ref bindingTable, results, seenHashes, ref skipped, ref returned))
                        {
                            if (_subSelect.Limit > 0 && returned >= _subSelect.Limit)
                            {
                                bindingTable.Clear();
                                return;
                            }
                        }

                        if (preBindGraph)
                            bindingTable.TruncateTo(preBindCount);
                        else
                            bindingTable.Clear();
                    }
                }
                finally
                {
                    firstScan.Dispose();
                }
            }
            else
            {
                var firstTp = _subSelect.GetPattern(0);
                var firstScan = new TriplePatternScan(_store, source, firstTp, bindingTable, graphSpan,
                    TemporalQueryMode.Current, default, default, default, _prefixes);
                try
                {
                    while (firstScan.MoveNext(ref bindingTable))
                    {
                        if (!preBindGraph)
                            bindingTable.Bind(graphVarName.AsSpan(), graphSpan);

                        if (ProcessAndAddResult(ref bindingTable, results, seenHashes, ref skipped, ref returned))
                        {
                            if (_subSelect.Limit > 0 && returned >= _subSelect.Limit)
                            {
                                bindingTable.Clear();
                                return;
                            }
                        }

                        if (preBindGraph)
                            bindingTable.TruncateTo(preBindCount);
                        else
                            bindingTable.Clear();
                    }
                }
                finally
                {
                    firstScan.Dispose();
                }
            }
        }

        // Execute union branch
        if (_subSelect.UnionBranchPatternCount > 0)
        {
            if (_subSelect.UnionBranchPatternCount > 1)
            {
                var unionBranch = new MultiPatternScan.BoxedPattern();
                for (int i = 0; i < _subSelect.UnionBranchPatternCount; i++)
                {
                    unionBranch.Pattern.AddPattern(_subSelect.GetPattern(_subSelect.UnionStartIndex + i));
                }

                var unionScan = new MultiPatternScan(_store, source, unionBranch.Pattern, false, graphSpan);
                try
                {
                    while (unionScan.MoveNext(ref bindingTable))
                    {
                        if (!preBindGraph)
                            bindingTable.Bind(graphVarName.AsSpan(), graphSpan);

                        if (ProcessAndAddResult(ref bindingTable, results, seenHashes, ref skipped, ref returned))
                        {
                            if (_subSelect.Limit > 0 && returned >= _subSelect.Limit)
                            {
                                bindingTable.Clear();
                                return;
                            }
                        }

                        if (preBindGraph)
                            bindingTable.TruncateTo(preBindCount);
                        else
                            bindingTable.Clear();
                    }
                }
                finally
                {
                    unionScan.Dispose();
                }
            }
            else
            {
                var unionTp = _subSelect.GetPattern(_subSelect.UnionStartIndex);
                var unionScan = new TriplePatternScan(_store, source, unionTp, bindingTable, graphSpan,
                    TemporalQueryMode.Current, default, default, default, _prefixes);
                try
                {
                    while (unionScan.MoveNext(ref bindingTable))
                    {
                        if (!preBindGraph)
                            bindingTable.Bind(graphVarName.AsSpan(), graphSpan);

                        if (ProcessAndAddResult(ref bindingTable, results, seenHashes, ref skipped, ref returned))
                        {
                            if (_subSelect.Limit > 0 && returned >= _subSelect.Limit)
                            {
                                bindingTable.Clear();
                                return;
                            }
                        }

                        if (preBindGraph)
                            bindingTable.TruncateTo(preBindCount);
                        else
                            bindingTable.Clear();
                    }
                }
                finally
                {
                    unionScan.Dispose();
                }
            }
        }

        bindingTable.Clear();  // Clear for next graph iteration
    }

    /// <summary>
    /// Execute nested subqueries (subquery containing another subquery but no triple patterns).
    /// Recursively executes nested subqueries and passes results through.
    /// For queries like: SELECT * WHERE { { SELECT ?x WHERE { ... } } }
    /// </summary>
    [MethodImpl(MethodImplOptions.NoInlining)]
    private List<MaterializedRow> ExecuteNestedSubQueries(ref BindingTable bindingTable)
    {
        var results = new List<MaterializedRow>();
        var source = _source;

        // Execute all nested subqueries
        for (int i = 0; i < _subSelect.SubQueryCount; i++)
        {
            var nestedSubSelect = _subSelect.GetSubQuery(i);
            // Pass prefix mappings to nested executor for prefix expansion
            var nestedExecutor = new BoxedSubQueryExecutor(_store, source, nestedSubSelect, _prefixes);
            var nestedResults = nestedExecutor.Execute();

            // Pass through all results from nested subquery
            // Projection is already handled by the nested subquery's SELECT clause
            results.AddRange(nestedResults);
        }

        // Apply DISTINCT if specified
        if (_distinct && results.Count > 1)
        {
            var seen = new HashSet<string>();
            var distinctResults = new List<MaterializedRow>();
            foreach (var row in results)
            {
                // Build a key from all values to identify unique rows
                var key = BuildRowKey(row);
                if (seen.Add(key))
                    distinctResults.Add(row);
            }
            return distinctResults;
        }

        // Apply LIMIT/OFFSET if specified
        if (_subSelect.Offset > 0 || _subSelect.Limit > 0)
        {
            int skip = _subSelect.Offset;
            int take = _subSelect.Limit > 0 ? _subSelect.Limit : results.Count;
            if (skip >= results.Count)
            {
                results.Clear();
            }
            else
            {
                int available = results.Count - skip;
                int actualTake = Math.Min(take, available);
                results = results.GetRange(skip, actualTake);
            }
        }

        return results;
    }

    /// <summary>
    /// Build a string key from all binding values in a row for DISTINCT comparison.
    /// </summary>
    private static string BuildRowKey(MaterializedRow row)
    {
        var sb = new System.Text.StringBuilder();
        for (int i = 0; i < row.BindingCount; i++)
        {
            if (i > 0) sb.Append('\x1F'); // Unit separator
            sb.Append(row.GetValue(i));
        }
        return sb.ToString();
    }

    /// <summary>
    /// Execute subquery with aggregation support.
    /// Collects raw rows, groups them, computes aggregates, and returns aggregated results.
    /// </summary>
    [MethodImpl(MethodImplOptions.NoInlining)]
    private List<MaterializedRow> ExecuteWithAggregation(ref BindingTable bindingTable)
    {
        var groups = new Dictionary<string, SubQueryGroupedRow>();
        var source = _source;

        // Collect all raw rows
        if (_subSelect.PatternCount == 1)
        {
            CollectRawResultsSingle(ref bindingTable, groups, source);
        }
        else
        {
            CollectRawResultsMulti(ref bindingTable, groups, source);
        }

        // Handle implicit aggregation with empty result set:
        // When there are aggregates but no GROUP BY and no matching rows,
        // SPARQL requires returning one row with default aggregate values
        if (groups.Count == 0 && _subSelect.HasAggregates && !_subSelect.HasGroupBy)
        {
            bindingTable.Clear();
            var emptyGroup = new SubQueryGroupedRow(_subSelect, bindingTable, source);
            groups[""] = emptyGroup;
        }

        // Finalize aggregates and convert to MaterializedRow
        var results = new List<MaterializedRow>(groups.Count);
        foreach (var group in groups.Values)
        {
            group.FinalizeAggregates();
            results.Add(group.ToMaterializedRow());
        }

        // Apply LIMIT/OFFSET if specified
        if (_subSelect.Offset > 0 || _subSelect.Limit > 0)
        {
            int skip = _subSelect.Offset;
            int take = _subSelect.Limit > 0 ? _subSelect.Limit : results.Count;
            if (skip >= results.Count)
            {
                results.Clear();
            }
            else
            {
                int available = results.Count - skip;
                int actualTake = Math.Min(take, available);
                results = results.GetRange(skip, actualTake);
            }
        }

        return results;
    }

    /// <summary>
    /// Collect raw results from single pattern for aggregation.
    /// </summary>
    [MethodImpl(MethodImplOptions.NoInlining)]
    private void CollectRawResultsSingle(ref BindingTable bindingTable,
        Dictionary<string, SubQueryGroupedRow> groups, string source)
    {
        var tp = _subSelect.GetPattern(0);
        var sourceSpan = source.AsSpan();
        var scan = new TriplePatternScan(_store, sourceSpan, tp, bindingTable, default,
            TemporalQueryMode.Current, default, default, default, _prefixes);
        try
        {
            while (scan.MoveNext(ref bindingTable))
            {
                // Apply filters if any
                if (_subSelect.FilterCount > 0)
                {
                    bool passedFilters = true;
                    for (int i = 0; i < _subSelect.FilterCount; i++)
                    {
                        var filter = _subSelect.GetFilter(i);
                        var filterExpr = sourceSpan.Slice(filter.Start, filter.Length);
                        var evaluator = new FilterEvaluator(filterExpr);
                        if (!evaluator.Evaluate(bindingTable.GetBindings(), bindingTable.Count, bindingTable.GetStringBuffer()))
                        {
                            passedFilters = false;
                            break;
                        }
                    }
                    if (!passedFilters)
                    {
                        bindingTable.Clear();
                        continue;
                    }
                }

                // Build group key from GROUP BY variables
                var groupKey = BuildGroupKey(ref bindingTable, source);

                // Get or create group
                if (!groups.TryGetValue(groupKey, out var group))
                {
                    group = new SubQueryGroupedRow(_subSelect, bindingTable, source);
                    groups[groupKey] = group;
                }

                // Update aggregates for this group
                group.UpdateAggregates(bindingTable, source);
                bindingTable.Clear();
            }
        }
        finally
        {
            scan.Dispose();
        }
    }

    /// <summary>
    /// Collect raw results from multi-pattern for aggregation.
    /// </summary>
    [MethodImpl(MethodImplOptions.NoInlining)]
    private void CollectRawResultsMulti(ref BindingTable bindingTable,
        Dictionary<string, SubQueryGroupedRow> groups, string source)
    {
        if (_subSelect.HasUnion)
        {
            CollectRawResultsUnion(ref bindingTable, groups, source);
        }
        else
        {
            var boxedPattern = new MultiPatternScan.BoxedPattern();
            for (int i = 0; i < _subSelect.PatternCount; i++)
            {
                boxedPattern.Pattern.AddPattern(_subSelect.GetPattern(i));
            }

            var sourceSpan = source.AsSpan();
            var scan = new MultiPatternScan(_store, sourceSpan, boxedPattern, _prefixes);
            try
            {
                while (scan.MoveNext(ref bindingTable))
                {
                    // Apply filters if any
                    if (_subSelect.FilterCount > 0)
                    {
                        bool passedFilters = true;
                        for (int i = 0; i < _subSelect.FilterCount; i++)
                        {
                            var filter = _subSelect.GetFilter(i);
                            var filterExpr = sourceSpan.Slice(filter.Start, filter.Length);
                            var evaluator = new FilterEvaluator(filterExpr);
                            if (!evaluator.Evaluate(bindingTable.GetBindings(), bindingTable.Count, bindingTable.GetStringBuffer()))
                            {
                                passedFilters = false;
                                break;
                            }
                        }
                        if (!passedFilters)
                        {
                            bindingTable.Clear();
                            continue;
                        }
                    }

                    var groupKey = BuildGroupKey(ref bindingTable, source);

                    if (!groups.TryGetValue(groupKey, out var group))
                    {
                        group = new SubQueryGroupedRow(_subSelect, bindingTable, source);
                        groups[groupKey] = group;
                    }

                    group.UpdateAggregates(bindingTable, source);
                    bindingTable.Clear();
                }
            }
            finally
            {
                scan.Dispose();
            }
        }
    }

    /// <summary>
    /// Collect raw results from UNION branches for aggregation.
    /// </summary>
    [MethodImpl(MethodImplOptions.NoInlining)]
    private void CollectRawResultsUnion(ref BindingTable bindingTable,
        Dictionary<string, SubQueryGroupedRow> groups, string source)
    {
        var sourceSpan = source.AsSpan();

        // Execute first branch
        if (_subSelect.FirstBranchPatternCount > 0)
        {
            if (_subSelect.FirstBranchPatternCount > 1)
            {
                var firstBranch = new MultiPatternScan.BoxedPattern();
                for (int i = 0; i < _subSelect.FirstBranchPatternCount; i++)
                {
                    firstBranch.Pattern.AddPattern(_subSelect.GetPattern(i));
                }

                var firstScan = new MultiPatternScan(_store, sourceSpan, firstBranch, _prefixes);
                try
                {
                    while (firstScan.MoveNext(ref bindingTable))
                    {
                        ProcessRowForAggregation(ref bindingTable, groups, source, sourceSpan);
                        bindingTable.Clear();
                    }
                }
                finally
                {
                    firstScan.Dispose();
                }
            }
            else
            {
                var tp = _subSelect.GetPattern(0);
                var scan = new TriplePatternScan(_store, sourceSpan, tp, bindingTable, default,
                    TemporalQueryMode.Current, default, default, default, _prefixes);
                try
                {
                    while (scan.MoveNext(ref bindingTable))
                    {
                        ProcessRowForAggregation(ref bindingTable, groups, source, sourceSpan);
                        bindingTable.Clear();
                    }
                }
                finally
                {
                    scan.Dispose();
                }
            }
        }

        // Execute union branch patterns
        for (int i = _subSelect.UnionStartIndex; i < _subSelect.PatternCount; i++)
        {
            var tp = _subSelect.GetPattern(i);
            var scan = new TriplePatternScan(_store, sourceSpan, tp, bindingTable, default,
                TemporalQueryMode.Current, default, default, default, _prefixes);
            try
            {
                while (scan.MoveNext(ref bindingTable))
                {
                    ProcessRowForAggregation(ref bindingTable, groups, source, sourceSpan);
                    bindingTable.Clear();
                }
            }
            finally
            {
                scan.Dispose();
            }
        }
    }

    /// <summary>
    /// Process a single row for aggregation: apply filters, build group key, update aggregates.
    /// </summary>
    private void ProcessRowForAggregation(ref BindingTable bindingTable,
        Dictionary<string, SubQueryGroupedRow> groups, string source, ReadOnlySpan<char> sourceSpan)
    {
        // Apply filters if any
        if (_subSelect.FilterCount > 0)
        {
            for (int i = 0; i < _subSelect.FilterCount; i++)
            {
                var filter = _subSelect.GetFilter(i);
                var filterExpr = sourceSpan.Slice(filter.Start, filter.Length);
                var evaluator = new FilterEvaluator(filterExpr);
                if (!evaluator.Evaluate(bindingTable.GetBindings(), bindingTable.Count, bindingTable.GetStringBuffer()))
                    return;
            }
        }

        var groupKey = BuildGroupKey(ref bindingTable, source);

        if (!groups.TryGetValue(groupKey, out var group))
        {
            group = new SubQueryGroupedRow(_subSelect, bindingTable, source);
            groups[groupKey] = group;
        }

        group.UpdateAggregates(bindingTable, source);
    }

    /// <summary>
    /// Build a group key from GROUP BY variables.
    /// </summary>
    private string BuildGroupKey(ref BindingTable bindings, string source)
    {
        if (!_subSelect.HasGroupBy || _subSelect.GroupBy.Count == 0)
            return "";

        var keyBuilder = new System.Text.StringBuilder();
        for (int i = 0; i < _subSelect.GroupBy.Count; i++)
        {
            var (start, len) = _subSelect.GroupBy.GetVariable(i);
            var varName = source.AsSpan(start, len);
            var bindingIdx = bindings.FindBinding(varName);
            if (bindingIdx >= 0)
            {
                if (i > 0) keyBuilder.Append('\0');
                keyBuilder.Append(bindings.GetString(bindingIdx));
            }
        }
        return keyBuilder.ToString();
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private void MaterializeSinglePattern(ref BindingTable bindingTable, List<MaterializedRow> results,
        HashSet<int>? seenHashes, ref int skipped, ref int returned)
    {
        var tp = _subSelect.GetPattern(0);
        var source = _source.AsSpan();
        // Pass prefixes for prefix expansion in nested subqueries (e.g., ex:q -> <http://...#q>)
        var scan = new TriplePatternScan(_store, source, tp, bindingTable, default,
            TemporalQueryMode.Current, default, default, default, _prefixes);
        try
        {
            while (scan.MoveNext(ref bindingTable))
            {
                if (ProcessAndAddResult(ref bindingTable, results, seenHashes, ref skipped, ref returned))
                {
                    if (_subSelect.Limit > 0 && returned >= _subSelect.Limit)
                        break;
                }
                bindingTable.Clear();
            }
        }
        finally
        {
            scan.Dispose();
        }
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private void MaterializeMultiPattern(ref BindingTable bindingTable, List<MaterializedRow> results,
        HashSet<int>? seenHashes, ref int skipped, ref int returned)
    {
        if (_subSelect.HasUnion)
        {
            // Execute UNION: first branch then union branch
            MaterializeUnionBranches(ref bindingTable, results, seenHashes, ref skipped, ref returned);
        }
        else
        {
            // Build pattern on heap
            var boxedPattern = new MultiPatternScan.BoxedPattern();
            for (int i = 0; i < _subSelect.PatternCount; i++)
            {
                boxedPattern.Pattern.AddPattern(_subSelect.GetPattern(i));
            }

            var source = _source.AsSpan();
            // Pass prefixes for prefix expansion in nested subqueries (e.g., ex:q -> <http://...#q>)
            var scan = new MultiPatternScan(_store, source, boxedPattern, _prefixes);
            try
            {
                while (scan.MoveNext(ref bindingTable))
                {
                    if (ProcessAndAddResult(ref bindingTable, results, seenHashes, ref skipped, ref returned))
                    {
                        if (_subSelect.Limit > 0 && returned >= _subSelect.Limit)
                            break;
                    }
                    bindingTable.Clear();
                }
            }
            finally
            {
                scan.Dispose();
            }
        }
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private void MaterializeUnionBranches(ref BindingTable bindingTable, List<MaterializedRow> results,
        HashSet<int>? seenHashes, ref int skipped, ref int returned)
    {
        var source = _source.AsSpan();

        // Execute first branch (patterns before UNION)
        if (_subSelect.FirstBranchPatternCount > 0)
        {
            // If first branch has multiple patterns, execute as multi-pattern scan
            if (_subSelect.FirstBranchPatternCount > 1)
            {
                var firstBranch = new MultiPatternScan.BoxedPattern();
                for (int i = 0; i < _subSelect.FirstBranchPatternCount; i++)
                {
                    firstBranch.Pattern.AddPattern(_subSelect.GetPattern(i));
                }

                var firstScan = new MultiPatternScan(_store, source, firstBranch, _prefixes);
                try
                {
                    while (firstScan.MoveNext(ref bindingTable))
                    {
                        if (ProcessAndAddResult(ref bindingTable, results, seenHashes, ref skipped, ref returned))
                        {
                            if (_subSelect.Limit > 0 && returned >= _subSelect.Limit)
                                return;
                        }
                        bindingTable.Clear();
                    }
                }
                finally
                {
                    firstScan.Dispose();
                }
            }
            else
            {
                // Single pattern - use TriplePatternScan
                var tp = _subSelect.GetPattern(0);
                var scan = new TriplePatternScan(_store, source, tp, bindingTable, default,
                    TemporalQueryMode.Current, default, default, default, _prefixes);
                try
                {
                    while (scan.MoveNext(ref bindingTable))
                    {
                        if (ProcessAndAddResult(ref bindingTable, results, seenHashes, ref skipped, ref returned))
                        {
                            if (_subSelect.Limit > 0 && returned >= _subSelect.Limit)
                                return;
                        }
                        bindingTable.Clear();
                    }
                }
                finally
                {
                    scan.Dispose();
                }
            }
        }

        // Execute union branch - each pattern separately as an alternative
        for (int i = _subSelect.UnionStartIndex; i < _subSelect.PatternCount; i++)
        {
            var tp = _subSelect.GetPattern(i);
            var scan = new TriplePatternScan(_store, source, tp, bindingTable, default,
                TemporalQueryMode.Current, default, default, default, _prefixes);
            try
            {
                while (scan.MoveNext(ref bindingTable))
                {
                    if (ProcessAndAddResult(ref bindingTable, results, seenHashes, ref skipped, ref returned))
                    {
                        if (_subSelect.Limit > 0 && returned >= _subSelect.Limit)
                            return;
                    }
                    bindingTable.Clear();
                }
            }
            finally
            {
                scan.Dispose();
            }
        }
    }

    private bool ProcessAndAddResult(ref BindingTable innerBindings, List<MaterializedRow> results,
        HashSet<int>? seenHashes, ref int skipped, ref int returned)
    {
        var source = _source.AsSpan();

        // Apply filters if any
        if (_subSelect.FilterCount > 0)
        {
            for (int i = 0; i < _subSelect.FilterCount; i++)
            {
                var filter = _subSelect.GetFilter(i);
                var filterExpr = source.Slice(filter.Start, filter.Length);
                var evaluator = new FilterEvaluator(filterExpr);
                if (!evaluator.Evaluate(innerBindings.GetBindings(), innerBindings.Count, innerBindings.GetStringBuffer()))
                    return false;
            }
        }

        // Apply VALUES constraint if present
        if (_subSelect.Values.HasValues)
        {
            if (!MatchesValuesConstraint(ref innerBindings, source))
                return false;
        }

        // Evaluate non-aggregate computed expressions (e.g., CONCAT(?F, " ", ?L) AS ?FullName)
        // These are stored with AggregateFunction.None and need to be evaluated per-row
        if (_subSelect.HasAggregates && !_subSelect.HasRealAggregates)
        {
            EvaluateComputedExpressions(ref innerBindings, source);
        }

        // Apply OFFSET
        if (skipped < _subSelect.Offset)
        {
            skipped++;
            return false;
        }

        // Apply DISTINCT on projected variables
        if (seenHashes != null)
        {
            var hash = ComputeProjectedBindingsHash(ref innerBindings, source);
            if (!seenHashes.Add(hash))
                return false;
        }

        // Project and materialize the result
        var projectedRow = ProjectToMaterializedRow(ref innerBindings, source);
        results.Add(projectedRow);
        returned++;
        return true;
    }

    /// <summary>
    /// Evaluates non-aggregate computed expressions (e.g., CONCAT, STR) per-row
    /// and binds the results to their alias variables.
    /// </summary>
    [MethodImpl(MethodImplOptions.NoInlining)]
    private void EvaluateComputedExpressions(ref BindingTable bindings, ReadOnlySpan<char> source)
    {
        var stringBuffer = bindings.GetStringBuffer();

        for (int i = 0; i < _subSelect.AggregateCount; i++)
        {
            var agg = _subSelect.GetAggregate(i);

            // Only evaluate non-aggregate expressions (Function == None)
            if (agg.Function != AggregateFunction.None) continue;

            // Skip if no expression to evaluate
            if (agg.VariableLength == 0) continue;

            // Get expression and alias
            var expr = source.Slice(agg.VariableStart, agg.VariableLength);
            var aliasName = source.Slice(agg.AliasStart, agg.AliasLength);

            // Evaluate the expression using BindExpressionEvaluator
            var evaluator = new BindExpressionEvaluator(expr,
                bindings.GetBindings(),
                bindings.Count,
                stringBuffer,
                ReadOnlySpan<char>.Empty);  // No base IRI in subquery context
            var value = evaluator.Evaluate();

            // Bind the result to the alias variable
            switch (value.Type)
            {
                case ValueType.Integer:
                    bindings.Bind(aliasName, value.IntegerValue);
                    break;
                case ValueType.Double:
                    bindings.Bind(aliasName, value.DoubleValue);
                    break;
                case ValueType.Boolean:
                    bindings.Bind(aliasName, value.BooleanValue);
                    break;
                case ValueType.String:
                case ValueType.Uri:
                    bindings.Bind(aliasName, value.StringValue);
                    break;
            }
        }
    }

    private int ComputeProjectedBindingsHash(ref BindingTable innerBindings, ReadOnlySpan<char> source)
    {
        int hash = 17;
        if (_subSelect.SelectAll)
        {
            for (int i = 0; i < innerBindings.Count; i++)
            {
                hash = hash * 31 + innerBindings.GetVariableHash(i);
                hash = hash * 31 + string.GetHashCode(innerBindings.GetString(i));
            }
        }
        else
        {
            for (int i = 0; i < _subSelect.ProjectedVarCount; i++)
            {
                var (start, len) = _subSelect.GetProjectedVariable(i);
                var varName = source.Slice(start, len);
                var idx = innerBindings.FindBinding(varName);
                if (idx >= 0)
                {
                    hash = hash * 31 + innerBindings.GetVariableHash(idx);
                    hash = hash * 31 + string.GetHashCode(innerBindings.GetString(idx));
                }
            }
        }
        return hash;
    }

    private MaterializedRow ProjectToMaterializedRow(ref BindingTable innerBindings, ReadOnlySpan<char> source)
    {
        var projectedBindings = new Binding[16];
        var projectedBuffer = new char[512];
        var projectedTable = new BindingTable(projectedBindings, projectedBuffer);

        if (_subSelect.SelectAll)
        {
            for (int i = 0; i < innerBindings.Count; i++)
            {
                var varHash = innerBindings.GetVariableHash(i);
                var value = innerBindings.GetString(i);
                projectedTable.BindWithHash(varHash, value);
            }
        }
        else
        {
            for (int i = 0; i < _subSelect.ProjectedVarCount; i++)
            {
                var (start, len) = _subSelect.GetProjectedVariable(i);
                var varName = source.Slice(start, len);
                var idx = innerBindings.FindBinding(varName);
                if (idx >= 0)
                {
                    projectedTable.Bind(varName, innerBindings.GetString(idx));
                }
            }
        }

        return new MaterializedRow(projectedTable);
    }

    /// <summary>
    /// Check if current bindings match the VALUES constraint.
    /// Returns true if bindings match at least one row in the VALUES clause.
    /// </summary>
    private bool MatchesValuesConstraint(ref BindingTable bindings, ReadOnlySpan<char> source)
    {
        var values = _subSelect.Values;
        int rowCount = values.RowCount;
        int varCount = values.VariableCount;

        // For each row in VALUES, check if ALL values in that row match
        for (int row = 0; row < rowCount; row++)
        {
            bool rowMatches = true;

            for (int varIdx = 0; varIdx < varCount; varIdx++)
            {
                var (valStart, valLen) = values.GetValueAt(row, varIdx);

                // UNDEF matches anything
                if (valLen == -1)
                    continue;

                // Get variable name
                var (varStart, varLength) = values.GetVariable(varIdx);
                var varName = source.Slice(varStart, varLength);

                // Find binding for this variable
                var bindingIdx = bindings.FindBinding(varName);
                if (bindingIdx < 0)
                {
                    // Variable not bound - doesn't match this row
                    rowMatches = false;
                    break;
                }

                var boundValue = bindings.GetString(bindingIdx);
                var valuesEntry = source.Slice(valStart, valLen);

                // Compare with prefix expansion
                if (!CompareValuesMatchWithPrefixExpansion(boundValue, valuesEntry))
                {
                    rowMatches = false;
                    break;
                }
            }

            if (rowMatches)
                return true;
        }

        return false;
    }

    /// <summary>
    /// Compare a bound value with a VALUES entry for equality, expanding prefixed names if needed.
    /// </summary>
    private bool CompareValuesMatchWithPrefixExpansion(ReadOnlySpan<char> boundValue, ReadOnlySpan<char> valuesEntry)
    {
        // Direct comparison first
        if (boundValue.SequenceEqual(valuesEntry))
            return true;

        // If VALUES entry is already a full IRI
        if (valuesEntry.Length > 0 && valuesEntry[0] == '<')
        {
            return boundValue.SequenceEqual(valuesEntry);
        }

        // Check for prefixed name that needs expansion
        var colonIdx = valuesEntry.IndexOf(':');
        if (colonIdx >= 0 && _prefixes != null)
        {
            var prefix = valuesEntry.Slice(0, colonIdx + 1); // Include the colon
            var localName = valuesEntry.Slice(colonIdx + 1);

            foreach (var mapping in _prefixes)
            {
                var mappedPrefix = _source.AsSpan(mapping.PrefixStart, mapping.PrefixLength);
                if (prefix.SequenceEqual(mappedPrefix))
                {
                    // Found matching prefix - expand and compare
                    var iriNs = _source.AsSpan(mapping.IriStart, mapping.IriLength);
                    // IRI namespace is like <http://example.org/> - remove trailing > and append local name
                    var nsWithoutClose = iriNs.Slice(0, iriNs.Length - 1);
                    var expanded = string.Concat(nsWithoutClose, localName, ">");
                    return boundValue.SequenceEqual(expanded.AsSpan());
                }
            }
        }

        // Handle literal comparison
        if (valuesEntry.Length > 0 && valuesEntry[0] == '"' &&
            boundValue.Length > 0 && boundValue[0] == '"')
        {
            return boundValue.SequenceEqual(valuesEntry);
        }

        return false;
    }
}

/// <summary>
/// Groups results and computes aggregates for subqueries with GROUP BY and/or aggregates.
/// Similar to GroupedRow but works with SubSelect instead of SelectClause.
/// </summary>
internal sealed class SubQueryGroupedRow
{
    // Group key storage
    private readonly int[] _keyHashes;
    private readonly string[] _keyValues;
    private readonly int _keyCount;

    // Aggregate storage
    private readonly int[] _aggHashes;        // Hash of alias variable name
    private readonly string[] _aggValues;      // Final computed values
    private readonly AggregateFunction[] _aggFunctions;
    private readonly int[] _aggVarHashes;      // Hash of source variable name
    private readonly int _aggCount;
    private readonly bool[] _aggDistinct;      // DISTINCT flag per aggregate

    // Aggregate accumulators
    private readonly long[] _counts;
    private readonly double[] _sums;
    private readonly double[] _mins;
    private readonly double[] _maxes;
    private readonly decimal[] _decimalSums;    // For precise decimal arithmetic
    private readonly decimal[] _decimalMins;
    private readonly decimal[] _decimalMaxes;
    private readonly bool[] _useDecimal;        // True if all values are decimal (not double/float)
    private readonly string?[] _minLiterals;    // Original literal for MIN (preserve datatype)
    private readonly string?[] _maxLiterals;    // Original literal for MAX (preserve datatype)
    private readonly HashSet<string>?[] _distinctSets;
    private readonly List<string>?[] _concatValues;  // For GROUP_CONCAT
    private readonly string[] _separators;           // For GROUP_CONCAT
    private readonly string?[] _sampleValues;        // For SAMPLE

    public int KeyCount => _keyCount;
    public int AggregateCount => _aggCount;

    public SubQueryGroupedRow(SubSelect subSelect, BindingTable bindings, string source)
    {
        // Store group key values from GROUP BY clause
        _keyCount = subSelect.HasGroupBy ? subSelect.GroupBy.Count : 0;
        _keyHashes = new int[_keyCount];
        _keyValues = new string[_keyCount];

        for (int i = 0; i < _keyCount; i++)
        {
            var (start, len) = subSelect.GroupBy.GetVariable(i);
            var varName = source.AsSpan(start, len);
            _keyHashes[i] = ComputeHash(varName);
            var idx = bindings.FindBinding(varName);
            _keyValues[i] = idx >= 0 ? bindings.GetString(idx).ToString() : "";
        }

        // Initialize aggregate accumulators from SubSelect
        _aggCount = subSelect.AggregateCount;
        _aggHashes = new int[_aggCount];
        _aggValues = new string[_aggCount];
        _aggFunctions = new AggregateFunction[_aggCount];
        _aggVarHashes = new int[_aggCount];
        _aggDistinct = new bool[_aggCount];
        _counts = new long[_aggCount];
        _sums = new double[_aggCount];
        _mins = new double[_aggCount];
        _maxes = new double[_aggCount];
        _decimalSums = new decimal[_aggCount];
        _decimalMins = new decimal[_aggCount];
        _decimalMaxes = new decimal[_aggCount];
        _useDecimal = new bool[_aggCount];
        _minLiterals = new string?[_aggCount];
        _maxLiterals = new string?[_aggCount];
        _distinctSets = new HashSet<string>?[_aggCount];
        _concatValues = new List<string>?[_aggCount];
        _separators = new string[_aggCount];
        _sampleValues = new string?[_aggCount];

        for (int i = 0; i < _aggCount; i++)
        {
            var agg = subSelect.GetAggregate(i);
            _aggFunctions[i] = agg.Function;
            _aggDistinct[i] = agg.Distinct;

            // Hash of alias (result variable name)
            var aliasName = source.AsSpan(agg.AliasStart, agg.AliasLength);
            _aggHashes[i] = ComputeHash(aliasName);

            // Hash of source variable
            if (agg.VariableLength > 0)
            {
                var varName = source.AsSpan(agg.VariableStart, agg.VariableLength);
                _aggVarHashes[i] = ComputeHash(varName);
            }
            else
            {
                // COUNT(*) case
                _aggVarHashes[i] = ComputeHash("*".AsSpan());
            }

            // Initialize accumulators
            _mins[i] = double.MaxValue;
            _maxes[i] = double.MinValue;
            _decimalMins[i] = decimal.MaxValue;
            _decimalMaxes[i] = decimal.MinValue;
            _useDecimal[i] = true; // Assume decimal until we see a double/float
            if (agg.Distinct)
            {
                _distinctSets[i] = new HashSet<string>();
            }

            // Initialize GROUP_CONCAT accumulators
            if (agg.Function == AggregateFunction.GroupConcat)
            {
                _concatValues[i] = new List<string>();
                // Extract separator from source, default to space
                _separators[i] = agg.SeparatorLength > 0
                    ? source.Substring(agg.SeparatorStart, agg.SeparatorLength)
                    : " ";
            }
        }
    }

    public void UpdateAggregates(BindingTable bindings, string source)
    {
        for (int i = 0; i < _aggCount; i++)
        {
            var func = _aggFunctions[i];
            var varHash = _aggVarHashes[i];

            // Find the value for this aggregate's variable
            string? valueStr = null;
            double numValue = 0;
            decimal decimalValue = 0;
            bool hasNumValue = false;
            bool isDouble = false;

            // For COUNT(*), we don't need a specific variable
            if (varHash != ComputeHash("*".AsSpan()))
            {
                var idx = bindings.FindBindingByHash(varHash);
                if (idx >= 0)
                {
                    valueStr = bindings.GetString(idx).ToString();
                    // Use RDF-aware numeric parsing to handle typed literals
                    hasNumValue = TryParseRdfNumeric(valueStr, out numValue, out decimalValue, out isDouble);
                }
                else
                {
                    // Variable not bound - skip for most aggregates
                    if (func != AggregateFunction.Count)
                        continue;
                }
            }

            // Handle DISTINCT
            if (_distinctSets[i] != null)
            {
                var val = valueStr ?? "";
                if (!_distinctSets[i]!.Add(val))
                    continue; // Already seen this value
            }

            // If we encounter a double/float value, switch to double mode
            if (hasNumValue && isDouble)
                _useDecimal[i] = false;

            // Update accumulator based on function
            switch (func)
            {
                case AggregateFunction.Count:
                    _counts[i]++;
                    break;
                case AggregateFunction.Sum:
                    if (hasNumValue)
                    {
                        _sums[i] += numValue;
                        _decimalSums[i] += decimalValue;
                    }
                    break;
                case AggregateFunction.Avg:
                    if (hasNumValue)
                    {
                        _sums[i] += numValue;
                        _decimalSums[i] += decimalValue;
                        _counts[i]++;
                    }
                    break;
                case AggregateFunction.Min:
                    if (hasNumValue)
                    {
                        // Use decimal comparison if in decimal mode, else double
                        bool isNewMin = _useDecimal[i]
                            ? decimalValue < _decimalMins[i]
                            : numValue < _mins[i];
                        if (isNewMin)
                        {
                            _mins[i] = numValue;
                            _decimalMins[i] = decimalValue;
                            _minLiterals[i] = valueStr;  // Preserve original literal with datatype
                        }
                    }
                    break;
                case AggregateFunction.Max:
                    if (hasNumValue)
                    {
                        // Use decimal comparison if in decimal mode, else double
                        bool isNewMax = _useDecimal[i]
                            ? decimalValue > _decimalMaxes[i]
                            : numValue > _maxes[i];
                        if (isNewMax)
                        {
                            _maxes[i] = numValue;
                            _decimalMaxes[i] = decimalValue;
                            _maxLiterals[i] = valueStr;  // Preserve original literal with datatype
                        }
                    }
                    break;
                case AggregateFunction.GroupConcat:
                    if (valueStr != null)
                        _concatValues[i]!.Add(valueStr);
                    break;
                case AggregateFunction.Sample:
                    // SAMPLE returns an arbitrary value - we take the first one
                    if (_sampleValues[i] == null && valueStr != null)
                        _sampleValues[i] = valueStr;
                    break;
            }
        }
    }

    public void FinalizeAggregates()
    {
        for (int i = 0; i < _aggCount; i++)
        {
            _aggValues[i] = _aggFunctions[i] switch
            {
                AggregateFunction.Count => FormatTypedLiteral(_counts[i].ToString(), XsdInteger),
                AggregateFunction.Sum => _useDecimal[i]
                    ? FormatTypedLiteral(FormatDecimal(_decimalSums[i]), XsdDecimal)
                    : FormatTypedLiteral(_sums[i].ToString(CultureInfo.InvariantCulture), XsdDouble),
                AggregateFunction.Avg => _counts[i] > 0
                    ? (_useDecimal[i]
                        ? FormatTypedLiteral(FormatDecimal(_decimalSums[i] / _counts[i]), XsdDecimal)
                        : FormatTypedLiteral((_sums[i] / _counts[i]).ToString(CultureInfo.InvariantCulture), XsdDouble))
                    : FormatTypedLiteral("0", XsdInteger),
                AggregateFunction.Min => _minLiterals[i] ?? "",  // Preserve original literal with datatype
                AggregateFunction.Max => _maxLiterals[i] ?? "",  // Preserve original literal with datatype
                AggregateFunction.GroupConcat => _concatValues[i] != null
                    ? string.Join(_separators[i], _concatValues[i]!)
                    : "",
                AggregateFunction.Sample => _sampleValues[i] ?? "",
                _ => ""
            };
        }
    }

    private const string XsdInteger = "http://www.w3.org/2001/XMLSchema#integer";
    private const string XsdDecimal = "http://www.w3.org/2001/XMLSchema#decimal";
    private const string XsdDouble = "http://www.w3.org/2001/XMLSchema#double";

    private static string FormatTypedLiteral(string value, string datatype)
    {
        return $"\"{value}\"^^<{datatype}>";
    }

    private static string FormatDecimal(decimal value)
    {
        return value.ToString("G29", CultureInfo.InvariantCulture);
    }

    public int GetKeyHash(int index) => _keyHashes[index];
    public ReadOnlySpan<char> GetKeyValue(int index) => _keyValues[index];
    public int GetAggregateHash(int index) => _aggHashes[index];
    public ReadOnlySpan<char> GetAggregateValue(int index) => _aggValues[index];

    /// <summary>
    /// Converts this grouped row to a MaterializedRow with all key and aggregate bindings.
    /// </summary>
    public MaterializedRow ToMaterializedRow()
    {
        var bindings = new Binding[16];
        var buffer = new char[512];
        var table = new BindingTable(bindings, buffer);

        // Add group key bindings
        for (int i = 0; i < _keyCount; i++)
        {
            table.BindWithHash(_keyHashes[i], _keyValues[i]);
        }

        // Add aggregate bindings
        for (int i = 0; i < _aggCount; i++)
        {
            table.BindWithHash(_aggHashes[i], _aggValues[i]);
        }

        return new MaterializedRow(table);
    }

    private static int ComputeHash(ReadOnlySpan<char> s)
    {
        uint hash = 2166136261;
        foreach (var ch in s)
        {
            hash ^= ch;
            hash *= 16777619;
        }
        return (int)hash;
    }

    /// <summary>
    /// Try to parse a numeric value from an RDF literal string.
    /// Returns both double and decimal values for precision control.
    /// </summary>
    private static bool TryParseRdfNumeric(string str, out double doubleResult, out decimal decimalResult, out bool isDouble)
    {
        doubleResult = 0;
        decimalResult = 0;
        isDouble = false;

        if (string.IsNullOrEmpty(str))
            return false;

        string valueStr;
        string? datatype = null;

        // Handle typed literals: "value"^^<datatype>
        if (str.StartsWith('"'))
        {
            // Find end of quoted value - it's either ^^ (typed), @ (language), or closing quote
            int endQuote = str.IndexOf('"', 1);
            if (endQuote <= 0)
                return false;

            // Extract the value between quotes
            valueStr = str.Substring(1, endQuote - 1);

            // Check for datatype
            var suffix = str.AsSpan(endQuote + 1);
            if (suffix.StartsWith("^^"))
            {
                var dtStr = suffix.Slice(2).ToString();
                if (dtStr.StartsWith('<') && dtStr.EndsWith('>'))
                    datatype = dtStr.Substring(1, dtStr.Length - 2);
                else
                    datatype = dtStr;
            }
        }
        else
        {
            valueStr = str;
        }

        // Determine if this is a double/float type
        isDouble = datatype != null &&
            (datatype.EndsWith("double", StringComparison.OrdinalIgnoreCase) ||
             datatype.EndsWith("float", StringComparison.OrdinalIgnoreCase));

        // Also check for scientific notation (indicates double)
        if (!isDouble && (valueStr.Contains('e') || valueStr.Contains('E')))
            isDouble = true;

        // Try to parse as double (always)
        if (!double.TryParse(valueStr, NumberStyles.Float, CultureInfo.InvariantCulture, out doubleResult))
            return false;

        // Try to parse as decimal (may fail for very large/small numbers or scientific notation)
        if (!decimal.TryParse(valueStr, NumberStyles.Float, CultureInfo.InvariantCulture, out decimalResult))
        {
            // If decimal parse fails, use the double value converted to decimal
            // This will lose precision but at least gives us a value
            try
            {
                decimalResult = (decimal)doubleResult;
            }
            catch
            {
                decimalResult = 0;
                isDouble = true; // Force double mode since decimal can't represent this
            }
        }

        return true;
    }
}

/// <summary>
/// Executes a subquery and yields only projected variable bindings.
/// Conforms to <see cref="IScan"/> contract (duck typing).
/// Handles variable scoping: only SELECT-ed variables are visible to outer query.
///
/// Design note: Results are materialized eagerly during Initialize() by delegating
/// to BoxedSubQueryExecutor, which isolates large scan operator stack usage.
/// </summary>
internal ref struct SubQueryScan
{
    private readonly QuadStore _store;
    private readonly ReadOnlySpan<char> _source;
    private readonly SubSelect _subSelect;
    private readonly PrefixMapping[]? _prefixes;
    // Materialized results - populated during Initialize() via BoxedSubQueryExecutor
    private List<MaterializedRow>? _materializedResults;
    private int _currentIndex;
    private bool _initialized;
    private bool _exhausted;

    public SubQueryScan(QuadStore store, ReadOnlySpan<char> source, SubSelect subSelect)
        : this(store, source, subSelect, null)
    {
    }

    public SubQueryScan(QuadStore store, ReadOnlySpan<char> source, SubSelect subSelect, PrefixMapping[]? prefixes)
    {
        _store = store;
        _source = source;
        _subSelect = subSelect;
        _prefixes = prefixes;
        _materializedResults = null;
        _currentIndex = 0;
        _initialized = false;
        _exhausted = false;
    }

    public bool MoveNext(ref BindingTable outerBindings)
    {
        if (_exhausted)
            return false;

        if (!_initialized)
        {
            Initialize();
            _initialized = true;
        }

        if (_materializedResults == null || _currentIndex >= _materializedResults.Count)
        {
            _exhausted = true;
            return false;
        }

        // Clear outer bindings before projecting new values
        outerBindings.Clear();

        // Copy bindings from materialized row to outer bindings
        var row = _materializedResults[_currentIndex++];
        for (int i = 0; i < row.BindingCount; i++)
        {
            outerBindings.BindWithHash(row.GetHash(i), row.GetValue(i));
        }

        return true;
    }

    /// <summary>
    /// Materializes all subquery results during initialization.
    /// Delegates to BoxedSubQueryExecutor to isolate large scan operator stack usage.
    /// </summary>
    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
    private void Initialize()
    {
        // Convert span to string for boxed executor (one allocation per subquery is acceptable)
        var sourceString = _source.ToString();

        // Use boxed executor to isolate scan operator stack usage
        // The class methods have fresh stack frames without accumulated ref struct overhead
        // Pass prefix mappings for expanding prefixed names in subquery patterns
        var executor = new BoxedSubQueryExecutor(_store, sourceString, _subSelect, _prefixes);
        _materializedResults = executor.Execute();
    }

    public void Dispose()
    {
        // No-op: scans are created and disposed in BoxedSubQueryExecutor
        // Results are stored in _materializedResults (managed List<T>)
    }
}

/// <summary>
/// Joins subquery results with outer triple patterns using nested loop join.
/// Conforms to <see cref="IScan"/> contract (duck typing).
/// For queries like: SELECT * WHERE { ?s ?p ?o . { SELECT ?s WHERE { ... } } }
/// Subquery is the driving (outer) relation; outer patterns are filtered using bound variables.
/// </summary>
internal ref struct SubQueryJoinScan
{
    private readonly QuadStore _store;
    private readonly ReadOnlySpan<char> _source;
    private readonly GraphPattern _pattern;
    private readonly SubSelect _subSelect;
    private readonly PrefixMapping[]? _prefixes;

    // Subquery execution state
    private SubQueryScan _subQueryScan;
    private Binding[] _subBindingStorage;
    private char[] _subStringBuffer;
    private BindingTable _subBindings;

    // Outer pattern execution state
    private MultiPatternScan _outerScan;
    private TriplePatternScan _singleOuterScan;
    private GraphPattern _outerPattern;
    private bool _outerInitialized;
    private bool _useMultiPattern;

    // Current binding checkpoint for rollback
    private int _bindingCheckpoint;

    // Store subquery bindings so we can restore them if caller clears bindings externally
    // This is needed because ExecuteSubQueryJoinCore calls bindingTable.Clear() after each result
    private int _subBindingsCount;
    private int[] _storedSubBindingHashes;
    private string[] _storedSubBindingValues;

    public SubQueryJoinScan(QuadStore store, ReadOnlySpan<char> source,
        GraphPattern pattern, SubSelect subSelect)
        : this(store, source, pattern, subSelect, null)
    {
    }

    public SubQueryJoinScan(QuadStore store, ReadOnlySpan<char> source,
        GraphPattern pattern, SubSelect subSelect, PrefixMapping[]? prefixes)
    {
        _store = store;
        _source = source;
        _pattern = pattern;
        _subSelect = subSelect;
        _prefixes = prefixes;

        // Initialize subquery state with prefix mappings
        _subQueryScan = new SubQueryScan(store, source, subSelect, prefixes);
        _subBindingStorage = new Binding[16];
        _subStringBuffer = PooledBufferManager.Shared.Rent<char>(512).Array!;
        _subBindings = new BindingTable(_subBindingStorage, _subStringBuffer);

        // Build outer pattern from non-subquery patterns
        // Preserve optional flags so OPTIONAL patterns are handled correctly
        _outerPattern = new GraphPattern();
        for (int i = 0; i < pattern.PatternCount; i++)
        {
            if (pattern.IsOptional(i))
                _outerPattern.AddOptionalPattern(pattern.GetPattern(i));
            else
                _outerPattern.AddPattern(pattern.GetPattern(i));
        }
        _useMultiPattern = _outerPattern.PatternCount > 1;

        _outerScan = default;
        _singleOuterScan = default;
        _outerInitialized = false;
        _bindingCheckpoint = 0;

        // Initialize storage for subquery bindings (max 16 bindings)
        _subBindingsCount = 0;
        _storedSubBindingHashes = new int[16];
        _storedSubBindingValues = new string[16];
    }

    public bool MoveNext(ref BindingTable bindings)
    {
        // If no outer patterns, just return subquery results directly
        if (_outerPattern.PatternCount == 0)
        {
            if (!_subQueryScan.MoveNext(ref _subBindings))
                return false;
            CopySubQueryBindings(ref bindings);
            return true;
        }

        while (true)
        {
            QueryCancellation.ThrowIfCancellationRequested();

            // Try to get next result from current outer pattern scan
            if (_outerInitialized)
            {
                // BUGFIX: Restore subquery bindings if caller cleared bindings externally
                // This happens when ExecuteSubQueryJoinCore calls bindingTable.Clear() after each result
                // Without this, TruncateTo in MultiPatternScan fails because count > _count after Clear()
                if (bindings.Count < _subBindingsCount)
                {
                    RestoreSubQueryBindings(ref bindings);
                }

                bool hasOuter;
                if (_useMultiPattern)
                    hasOuter = _outerScan.MoveNext(ref bindings);
                else
                    hasOuter = _singleOuterScan.MoveNext(ref bindings);

                if (hasOuter)
                {
                    // Try to match OPTIONAL patterns (left outer join semantics)
                    TryMatchOptionalPatterns(ref bindings);

                    // We have a joined result: subquery bindings + outer pattern bindings
                    return true;
                }

                // Outer patterns exhausted for this subquery row
                // Reset for next subquery row
                _outerInitialized = false;
                if (_useMultiPattern)
                    _outerScan.Dispose();
                else
                    _singleOuterScan.Dispose();
                bindings.TruncateTo(_bindingCheckpoint);
            }

            // Get next subquery result
            if (!_subQueryScan.MoveNext(ref _subBindings))
            {
                return false;
            }

            // Save checkpoint and copy subquery bindings to outer bindings
            _bindingCheckpoint = bindings.Count;
            CopySubQueryBindings(ref bindings);

            // Initialize outer pattern scan with current bindings
            InitializeOuterScan(ref bindings);
            _outerInitialized = true;
        }
    }

    private void CopySubQueryBindings(ref BindingTable bindings)
    {
        // Store subquery bindings so we can restore them if caller clears bindings
        _subBindingsCount = _subBindings.Count;
        for (int i = 0; i < _subBindings.Count; i++)
        {
            var hash = _subBindings.GetVariableHash(i);
            var value = _subBindings.GetString(i);

            // Store for potential restoration
            _storedSubBindingHashes[i] = hash;
            _storedSubBindingValues[i] = value.ToString();

            // Copy to outer binding table
            bindings.BindWithHash(hash, value);
        }
        _subBindings.Clear();
    }

    private void RestoreSubQueryBindings(ref BindingTable bindings)
    {
        // Restore previously stored subquery bindings
        for (int i = 0; i < _subBindingsCount; i++)
        {
            bindings.BindWithHash(_storedSubBindingHashes[i], _storedSubBindingValues[i].AsSpan());
        }
    }

    private void InitializeOuterScan(ref BindingTable bindings)
    {
        if (_useMultiPattern)
        {
            // MultiPatternScan with initial bindings and prefix mappings
            // MultiPatternScan resolves variables from bindings in ResolveAndQuery
            _outerScan = new MultiPatternScan(_store, _source, _outerPattern,
                unionMode: false, graph: default, prefixes: _prefixes);
        }
        else if (_outerPattern.PatternCount == 1)
        {
            var tp = _outerPattern.GetPattern(0);
            // Pass prefix mappings to enable prefix expansion (e.g., ex:p → <http://...>)
            _singleOuterScan = new TriplePatternScan(_store, _source, tp, bindings, default,
                TemporalQueryMode.Current, default, default, default, _prefixes);
        }
    }

    /// <summary>
    /// Try to match OPTIONAL patterns (left outer join semantics).
    /// Called after required patterns have been matched.
    /// </summary>
    private void TryMatchOptionalPatterns(ref BindingTable bindings)
    {
        // Check each pattern to see if it's optional
        for (int i = 0; i < _outerPattern.PatternCount; i++)
        {
            if (!_outerPattern.IsOptional(i)) continue;

            var tp = _outerPattern.GetPattern(i);
            TryMatchSingleOptionalPattern(ref tp, ref bindings);
        }
    }

    /// <summary>
    /// Try to match a single optional pattern against the store.
    /// If it matches, bind any unbound variables.
    /// If it doesn't match, the row is still returned (left outer join).
    /// Uses TriplePatternScan for proper prefix expansion and variable resolution.
    /// </summary>
    private void TryMatchSingleOptionalPattern(ref TriplePattern tp, ref BindingTable bindings)
    {
        // Use TriplePatternScan which handles:
        // - Prefix expansion (foaf:mbox → <http://xmlns.com/foaf/0.1/mbox>)
        // - Variable binding resolution
        // - Proper term resolution
        var scan = new TriplePatternScan(_store, _source, tp, bindings, default,
            TemporalQueryMode.Current, default, default, default, _prefixes);

        try
        {
            // Try to match the pattern
            if (scan.MoveNext(ref bindings))
            {
                // Pattern matched - bindings are already extended by MoveNext
                // Nothing more to do
            }
            // If no match, variables remain unbound (left outer join semantics)
        }
        finally
        {
            scan.Dispose();
        }
    }

    public void Dispose()
    {
        _subQueryScan.Dispose();
        if (_outerInitialized)
        {
            if (_useMultiPattern)
                _outerScan.Dispose();
            else
                _singleOuterScan.Dispose();
        }
        if (_subStringBuffer != null)
            PooledBufferManager.Shared.Return(_subStringBuffer);
    }
}

/// <summary>
/// Scans triple patterns across multiple default graphs (FROM clauses), unioning results.
/// Conforms to <see cref="IScan"/> contract (duck typing).
/// This is a streaming operator that avoids materializing all results upfront.
/// </summary>
internal ref struct DefaultGraphUnionScan
{
    private readonly QuadStore _store;
    private readonly ReadOnlySpan<char> _source;
    private readonly GraphPattern _pattern;
    private readonly string[] _defaultGraphs;
    private int _currentGraphIndex;
    private TriplePatternScan _singleScan;
    private MultiPatternScan _multiScan;
    private bool _isMultiPattern;
    private bool _initialized;
    private bool _exhausted;

    public DefaultGraphUnionScan(QuadStore store, ReadOnlySpan<char> source, GraphPattern pattern, string[] defaultGraphs)
    {
        _store = store;
        _source = source;
        _pattern = pattern;
        _defaultGraphs = defaultGraphs;
        _currentGraphIndex = 0;
        _singleScan = default;
        _multiScan = default;
        _isMultiPattern = pattern.RequiredPatternCount > 1;
        _initialized = false;
        _exhausted = false;
    }

    public bool MoveNext(ref BindingTable bindings)
    {
        if (_exhausted)
            return false;

        while (true)
        {
            QueryCancellation.ThrowIfCancellationRequested();

            // Try to get next result from current graph's scan
            if (_initialized)
            {
                bool hasNext = _isMultiPattern
                    ? _multiScan.MoveNext(ref bindings)
                    : _singleScan.MoveNext(ref bindings);

                if (hasNext)
                    return true;

                // Current graph exhausted, dispose and move to next
                if (_isMultiPattern)
                    _multiScan.Dispose();
                else
                    _singleScan.Dispose();
                _initialized = false;
            }

            // Move to next graph
            if (_currentGraphIndex >= _defaultGraphs.Length)
            {
                _exhausted = true;
                return false;
            }

            // Clear bindings before switching to new graph
            // Each graph should start fresh (FROM semantics = union of independent queries)
            bindings.Clear();

            // Initialize scan for new graph
            var graphIri = _defaultGraphs[_currentGraphIndex++].AsSpan();
            InitializeScan(graphIri, ref bindings);
            _initialized = true;
        }
    }

    private void InitializeScan(ReadOnlySpan<char> graphIri, ref BindingTable bindings)
    {
        if (_isMultiPattern)
        {
            _multiScan = new MultiPatternScan(_store, _source, _pattern, false, graphIri);
        }
        else
        {
            // Find the first required pattern
            int requiredIdx = 0;
            for (int i = 0; i < _pattern.PatternCount; i++)
            {
                if (!_pattern.IsOptional(i)) { requiredIdx = i; break; }
            }

            var tp = _pattern.GetPattern(requiredIdx);
            _singleScan = new TriplePatternScan(_store, _source, tp, bindings, graphIri);
        }
    }

    public void Dispose()
    {
        if (_initialized)
        {
            if (_isMultiPattern)
                _multiScan.Dispose();
            else
                _singleScan.Dispose();
        }
    }
}

/// <summary>
/// Scans triple patterns across multiple graphs with cross-graph joins.
/// Conforms to <see cref="IScan"/> contract (duck typing).
/// Unlike DefaultGraphUnionScan which runs each complete pattern against each graph independently,
/// this operator allows joins where one pattern matches in graph1 and another in graph2.
///
/// For example, with FROM graph1 FROM graph2 and pattern { ?s name ?name . ?s age ?age }:
/// - First pattern queries both graph1 and graph2
/// - For each match, second pattern also queries both graph1 and graph2
/// This allows joining ?s=Alice from graph1's name with ?s=Alice from graph2's age.
/// </summary>
internal ref struct CrossGraphMultiPatternScan
{
    private readonly QuadStore _store;
    private readonly ReadOnlySpan<char> _source;
    private readonly GraphPattern _pattern;
    private readonly string[] _graphs;

    // Current state for each pattern level
    private TemporalResultEnumerator _enum0;
    private TemporalResultEnumerator _enum1;
    private TemporalResultEnumerator _enum2;
    private TemporalResultEnumerator _enum3;

    // Current graph index at each level
    private int _graphIndex0, _graphIndex1, _graphIndex2, _graphIndex3;

    private int _currentLevel;
    private bool _init0, _init1, _init2, _init3;
    private bool _exhausted;

    // Track binding count at entry to each level for rollback
    private int _bindingCount0, _bindingCount1, _bindingCount2, _bindingCount3;

    public CrossGraphMultiPatternScan(QuadStore store, ReadOnlySpan<char> source, GraphPattern pattern, string[] graphs)
    {
        _store = store;
        _source = source;
        _pattern = pattern;
        _graphs = graphs;
        _currentLevel = 0;
        _init0 = _init1 = _init2 = _init3 = false;
        _exhausted = false;
        _enum0 = default;
        _enum1 = default;
        _enum2 = default;
        _enum3 = default;
        _graphIndex0 = _graphIndex1 = _graphIndex2 = _graphIndex3 = 0;
        _bindingCount0 = _bindingCount1 = _bindingCount2 = _bindingCount3 = 0;
    }

    public bool MoveNext(ref BindingTable bindings)
    {
        if (_exhausted)
            return false;

        var patternCount = Math.Min(_pattern.RequiredPatternCount, 4);
        if (patternCount == 0)
            return false;

        while (true)
        {
            QueryCancellation.ThrowIfCancellationRequested();

            bool advanced;
            switch (_currentLevel)
            {
                case 0: advanced = TryAdvanceLevel0(ref bindings); break;
                case 1: advanced = TryAdvanceLevel1(ref bindings); break;
                case 2: advanced = TryAdvanceLevel2(ref bindings); break;
                case 3: advanced = TryAdvanceLevel3(ref bindings); break;
                default: advanced = false; break;
            }

            if (advanced)
            {
                if (_currentLevel == patternCount - 1)
                {
                    // At deepest level - we have a complete result
                    return true;
                }
                else
                {
                    // Go deeper
                    _currentLevel++;
                    SetInitialized(_currentLevel, false);
                    SetGraphIndex(_currentLevel, 0);
                }
            }
            else
            {
                // Current level exhausted across all graphs, backtrack
                if (_currentLevel == 0)
                {
                    _exhausted = true;
                    return false;
                }

                // Go up
                _currentLevel--;
            }
        }
    }

    private void SetInitialized(int level, bool value)
    {
        switch (level)
        {
            case 0: _init0 = value; break;
            case 1: _init1 = value; break;
            case 2: _init2 = value; break;
            case 3: _init3 = value; break;
        }
    }

    private void SetGraphIndex(int level, int value)
    {
        switch (level)
        {
            case 0: _graphIndex0 = value; break;
            case 1: _graphIndex1 = value; break;
            case 2: _graphIndex2 = value; break;
            case 3: _graphIndex3 = value; break;
        }
    }

    private bool TryAdvanceLevel0(scoped ref BindingTable bindings)
    {
        var pattern = GetRequiredPattern(0);

        while (true)
        {
            QueryCancellation.ThrowIfCancellationRequested();

            if (!_init0)
            {
                _bindingCount0 = bindings.Count;
                if (_graphIndex0 >= _graphs.Length)
                    return false; // All graphs exhausted at this level
                InitializeEnumerator(pattern, ref bindings, _graphs[_graphIndex0].AsSpan(), out _enum0);
                _init0 = true;
            }
            else
            {
                // Rolling back bindings from previous attempt
                bindings.TruncateTo(_bindingCount0);
            }

            if (TryAdvanceEnumerator(ref _enum0, pattern, ref bindings))
                return true;

            // Current graph exhausted, try next graph
            _enum0.Dispose();
            _graphIndex0++;
            _init0 = false;

            if (_graphIndex0 >= _graphs.Length)
                return false;
        }
    }

    private bool TryAdvanceLevel1(scoped ref BindingTable bindings)
    {
        var pattern = GetRequiredPattern(1);

        while (true)
        {
            QueryCancellation.ThrowIfCancellationRequested();

            if (!_init1)
            {
                _bindingCount1 = bindings.Count;
                if (_graphIndex1 >= _graphs.Length)
                    return false;
                InitializeEnumerator(pattern, ref bindings, _graphs[_graphIndex1].AsSpan(), out _enum1);
                _init1 = true;
            }
            else
            {
                bindings.TruncateTo(_bindingCount1);
            }

            if (TryAdvanceEnumerator(ref _enum1, pattern, ref bindings))
                return true;

            _enum1.Dispose();
            _graphIndex1++;
            _init1 = false;

            if (_graphIndex1 >= _graphs.Length)
                return false;
        }
    }

    private bool TryAdvanceLevel2(scoped ref BindingTable bindings)
    {
        var pattern = GetRequiredPattern(2);

        while (true)
        {
            QueryCancellation.ThrowIfCancellationRequested();

            if (!_init2)
            {
                _bindingCount2 = bindings.Count;
                if (_graphIndex2 >= _graphs.Length)
                    return false;
                InitializeEnumerator(pattern, ref bindings, _graphs[_graphIndex2].AsSpan(), out _enum2);
                _init2 = true;
            }
            else
            {
                bindings.TruncateTo(_bindingCount2);
            }

            if (TryAdvanceEnumerator(ref _enum2, pattern, ref bindings))
                return true;

            _enum2.Dispose();
            _graphIndex2++;
            _init2 = false;

            if (_graphIndex2 >= _graphs.Length)
                return false;
        }
    }

    private bool TryAdvanceLevel3(scoped ref BindingTable bindings)
    {
        var pattern = GetRequiredPattern(3);

        while (true)
        {
            QueryCancellation.ThrowIfCancellationRequested();

            if (!_init3)
            {
                _bindingCount3 = bindings.Count;
                if (_graphIndex3 >= _graphs.Length)
                    return false;
                InitializeEnumerator(pattern, ref bindings, _graphs[_graphIndex3].AsSpan(), out _enum3);
                _init3 = true;
            }
            else
            {
                bindings.TruncateTo(_bindingCount3);
            }

            if (TryAdvanceEnumerator(ref _enum3, pattern, ref bindings))
                return true;

            _enum3.Dispose();
            _graphIndex3++;
            _init3 = false;

            if (_graphIndex3 >= _graphs.Length)
                return false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private TriplePattern GetRequiredPattern(int index)
    {
        // Find the nth required (non-optional) pattern
        int found = 0;
        for (int i = 0; i < _pattern.PatternCount; i++)
        {
            if (!_pattern.IsOptional(i))
            {
                if (found == index)
                    return _pattern.GetPattern(i);
                found++;
            }
        }
        return default;
    }

    private void InitializeEnumerator(TriplePattern pattern, scoped ref BindingTable bindings,
        ReadOnlySpan<char> graph, out TemporalResultEnumerator enumerator)
    {
        ReadOnlySpan<char> subject, predicate, obj;

        // Resolve subject - named blank nodes (_:name) match literal, anonymous ([]) are wildcards
        if (pattern.Subject.IsBlankNode)
        {
            var bnSpan = _source.Slice(pattern.Subject.Start, pattern.Subject.Length);
            subject = (bnSpan.Length >= 2 && bnSpan[0] == '_' && bnSpan[1] == ':') ? bnSpan : ReadOnlySpan<char>.Empty;
        }
        else if (!pattern.Subject.IsVariable)
            subject = _source.Slice(pattern.Subject.Start, pattern.Subject.Length);
        else
        {
            var varName = _source.Slice(pattern.Subject.Start, pattern.Subject.Length);
            var idx = bindings.FindBinding(varName);
            subject = idx >= 0 ? bindings.GetString(idx) : ReadOnlySpan<char>.Empty;
        }

        // Resolve predicate - named blank nodes match literal, anonymous are wildcards
        if (pattern.Predicate.IsBlankNode)
        {
            var bnSpan = _source.Slice(pattern.Predicate.Start, pattern.Predicate.Length);
            predicate = (bnSpan.Length >= 2 && bnSpan[0] == '_' && bnSpan[1] == ':') ? bnSpan : ReadOnlySpan<char>.Empty;
        }
        else if (!pattern.Predicate.IsVariable)
            predicate = _source.Slice(pattern.Predicate.Start, pattern.Predicate.Length);
        else
        {
            var varName = _source.Slice(pattern.Predicate.Start, pattern.Predicate.Length);
            var idx = bindings.FindBinding(varName);
            predicate = idx >= 0 ? bindings.GetString(idx) : ReadOnlySpan<char>.Empty;
        }

        // Resolve object - named blank nodes match literal, anonymous are wildcards
        if (pattern.Object.IsBlankNode)
        {
            var bnSpan = _source.Slice(pattern.Object.Start, pattern.Object.Length);
            obj = (bnSpan.Length >= 2 && bnSpan[0] == '_' && bnSpan[1] == ':') ? bnSpan : ReadOnlySpan<char>.Empty;
        }
        else if (!pattern.Object.IsVariable)
            obj = _source.Slice(pattern.Object.Start, pattern.Object.Length);
        else
        {
            var varName = _source.Slice(pattern.Object.Start, pattern.Object.Length);
            var idx = bindings.FindBinding(varName);
            obj = idx >= 0 ? bindings.GetString(idx) : ReadOnlySpan<char>.Empty;
        }

        enumerator = _store.QueryCurrent(subject, predicate, obj, graph);
    }

    private bool TryAdvanceEnumerator(ref TemporalResultEnumerator enumerator,
        TriplePattern pattern, scoped ref BindingTable bindings)
    {
        while (enumerator.MoveNext())
        {
            var triple = enumerator.Current;

            if (TryBindVariable(pattern.Subject, triple.Subject, ref bindings) &&
                TryBindVariable(pattern.Predicate, triple.Predicate, ref bindings) &&
                TryBindVariable(pattern.Object, triple.Object, ref bindings))
            {
                return true;
            }
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool TryBindVariable(Term term, ReadOnlySpan<char> value, scoped ref BindingTable bindings)
    {
        if (!term.IsVariable)
            return true;

        var varName = _source.Slice(term.Start, term.Length);
        var existingIndex = bindings.FindBinding(varName);

        if (existingIndex >= 0)
        {
            var existingValue = bindings.GetString(existingIndex);
            return value.SequenceEqual(existingValue);
        }

        bindings.Bind(varName, value);
        return true;
    }

    public void Dispose()
    {
        if (_init0) _enum0.Dispose();
        if (_init1) _enum1.Dispose();
        if (_init2) _enum2.Dispose();
        if (_init3) _enum3.Dispose();
    }
}

// NOTE: ServiceScan operator was removed and replaced with ServicePatternScan in ServiceMaterializer.cs.
// The new implementation separates fetching (FetchServiceResults) from iteration (ServicePatternScan),
// enabling optimizations like fetching SERVICE results once for join scenarios.
// See QueryExecutor.Service.cs for the integration.

// NOTE: ServiceJoinScan operator was replaced with materialization pattern.
// The QueryResults ref struct (~22KB) combined with large GraphPattern (~4KB) can
// exceed stack limits in complex query paths. The fix is to materialize SERVICE
// results to List<MaterializedRow> early, returning only heap pointers through the
// call chain. See docs/mercury-adr-buffer-pattern.md for the pattern details.
