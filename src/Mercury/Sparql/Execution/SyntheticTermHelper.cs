using System.Runtime.CompilerServices;

namespace SkyOmega.Mercury.Sparql.Execution;

/// <summary>
/// Helper for resolving synthetic terms generated by SPARQL-star expansion.
/// Synthetic terms use negative Start offsets to indicate they're not in the source.
/// </summary>
internal static class SyntheticTermHelper
{
    // RDF namespace IRIs for reification patterns
    public const string RdfType = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#type>";
    public const string RdfStatement = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#Statement>";
    public const string RdfSubject = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#subject>";
    public const string RdfPredicate = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate>";
    public const string RdfObject = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#object>";

    // RDF namespace IRIs for RDF collections (lists)
    public const string RdfFirst = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#first>";
    public const string RdfRest = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#rest>";
    public const string RdfNil = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#nil>";

    // Pre-allocated synthetic variable names for reifier bindings (up to 32 per query)
    private static readonly string[] SyntheticVarNames = new string[32];

    // Pre-allocated synthetic variable names for sequence path intermediates (up to 32 per query)
    private static readonly string[] SyntheticSeqVarNames = new string[32];

    // Pre-allocated synthetic variable names for blank node property lists (up to 32 per query)
    private static readonly string[] SyntheticBnVarNames = new string[32];

    // Pre-allocated synthetic blank node names for RDF list nodes in CONSTRUCT templates (up to 32)
    private static readonly string[] SyntheticListNodeNames = new string[32];

    static SyntheticTermHelper()
    {
        for (int i = 0; i < SyntheticVarNames.Length; i++)
            SyntheticVarNames[i] = $"?_qt{i}";
        for (int i = 0; i < SyntheticSeqVarNames.Length; i++)
            SyntheticSeqVarNames[i] = $"?_seq{i}";
        for (int i = 0; i < SyntheticBnVarNames.Length; i++)
            SyntheticBnVarNames[i] = $"?_bn{i}";
        for (int i = 0; i < SyntheticListNodeNames.Length; i++)
            SyntheticListNodeNames[i] = $"_:list{i}";
    }

    /// <summary>
    /// Check if a term has a synthetic (negative) offset.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsSynthetic(int start) => start < 0;

    /// <summary>
    /// Get the synthetic IRI for a negative offset.
    /// Offsets: -1 = rdf:type, -2 = rdf:Statement, -3 = rdf:subject, -4 = rdf:predicate, -5 = rdf:object
    ///          -6 = rdf:first, -7 = rdf:rest, -8 = rdf:nil
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan<char> GetSyntheticIri(int start)
    {
        return start switch
        {
            -1 => RdfType.AsSpan(),
            -2 => RdfStatement.AsSpan(),
            -3 => RdfSubject.AsSpan(),
            -4 => RdfPredicate.AsSpan(),
            -5 => RdfObject.AsSpan(),
            -6 => RdfFirst.AsSpan(),
            -7 => RdfRest.AsSpan(),
            -8 => RdfNil.AsSpan(),
            _ => ReadOnlySpan<char>.Empty
        };
    }

    /// <summary>
    /// Get the synthetic variable name for a negative offset.
    /// Reifier variables: -100 to -131 = ?_qt0 to ?_qt31
    /// Sequence variables: -200 to -231 = ?_seq0 to ?_seq31
    /// Blank node property list variables: -300 to -331 = ?_bn0 to ?_bn31
    /// List node blank nodes: -400 to -431 = _:list0 to _:list31
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan<char> GetSyntheticVarName(int start)
    {
        // Check for list node blank nodes (-400 to -431)
        if (start <= -400 && start > -432)
        {
            var index = -start - 400;
            if (index < SyntheticListNodeNames.Length)
                return SyntheticListNodeNames[index].AsSpan();
        }

        // Check for blank node property list variables first (-300 to -331)
        if (start <= -300 && start > -332)
        {
            var index = -start - 300;
            if (index < SyntheticBnVarNames.Length)
                return SyntheticBnVarNames[index].AsSpan();
        }

        // Check for sequence variables (-200 to -231)
        if (start <= -200 && start > -232)
        {
            var index = -start - 200;
            if (index < SyntheticSeqVarNames.Length)
                return SyntheticSeqVarNames[index].AsSpan();
        }

        // Reifier variables (-100 to -131)
        var qtIndex = -start - 100;
        if (qtIndex >= 0 && qtIndex < SyntheticVarNames.Length)
            return SyntheticVarNames[qtIndex].AsSpan();
        return ReadOnlySpan<char>.Empty;
    }

    /// <summary>
    /// Get the synthetic offset for a list node blank node.
    /// Index 0 = offset -400, index 1 = offset -401, etc.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int GetListNodeOffset(int index) => -(400 + index);

    /// <summary>
    /// Check if offset is a list node blank node (-400 to -431).
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsListNodeOffset(int start) => start <= -400 && start > -432;

    /// <summary>
    /// Get the synthetic offset for a sequence intermediate variable.
    /// Index 0 = offset -200, index 1 = offset -201, etc.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int GetSeqVarOffset(int index) => -(200 + index);

    /// <summary>
    /// Get the synthetic offset for a blank node property list variable.
    /// Index 0 = offset -300, index 1 = offset -301, etc.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int GetBnVarOffset(int index) => -(300 + index);
}
